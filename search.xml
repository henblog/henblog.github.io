<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库概述</title>
      <link href="/2022/07/17/di-01-zhang-shu-ju-ku-gai-shu/"/>
      <url>/2022/07/17/di-01-zhang-shu-ju-ku-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="第01章-数据库概述"><a href="#第01章-数据库概述" class="headerlink" title="第01章_数据库概述"></a>第01章_数据库概述</h1><h2 id="1-为什么要使用数据库"><a href="#1-为什么要使用数据库" class="headerlink" title="1. 为什么要使用数据库"></a>1. 为什么要使用数据库</h2><hr><ul><li>持久化（persistence）：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。</li><li>持久化的主要作用是<strong>将内存中的数据存储在关系型数据库中</strong>，当然也可以存储在磁盘文件、XML数据文件中。<br><img src="/../pic/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/1649251937911.png" alt="1649251937911"></li></ul><hr><h2 id="2-数据库与数据库管理系统"><a href="#2-数据库与数据库管理系统" class="headerlink" title="2. 数据库与数据库管理系统"></a>2. 数据库与数据库管理系统</h2><hr><h3 id="2-1-数据库的相关概念"><a href="#2-1-数据库的相关概念" class="headerlink" title="2.1 数据库的相关概念"></a>2.1 数据库的相关概念</h3><table><thead><tr><th>DB：数据库（Database）</th></tr></thead><tbody><tr><td>即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。</td></tr><tr><td><strong>DBMS：数据库管理系统（Database Management System）</strong></td></tr><tr><td>是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和 控制。用户通过数据库管理系统访问数据库中表内的数据。</td></tr><tr><td><strong>SQL：结构化查询语言（Structured Query Language）</strong></td></tr><tr><td>专门用来与数据库通信的语言。</td></tr></tbody></table><h3 id="2-2-数据库与数据库管理系统的关系"><a href="#2-2-数据库与数据库管理系统的关系" class="headerlink" title="2.2 数据库与数据库管理系统的关系"></a>2.2 数据库与数据库管理系统的关系</h3><p>数据库管理系统（DBMS）可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。</p><p>数据库管理系统、数据库和表的关系如图所示：</p><p><img src="/../pic/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/1649252774392.png" alt="1649252774392"></p><h3 id="2-3-常见的数据库管理系统排名（DBMS）"><a href="#2-3-常见的数据库管理系统排名（DBMS）" class="headerlink" title="2.3 常见的数据库管理系统排名（DBMS）"></a>2.3 常见的数据库管理系统排名（DBMS）</h3><p>目前互联网上常见的数据库管理软件有 Oracle、MySQL、MS SQL Server、DB2、PostgreSQL、Access、SyBase、Informix这几种。以下是2021年*DB-Engines Ranking对各数据库受欢迎程度进行调查后的统计结果：（查看数据库最新排名：<a href="https://db-engines.com/en/ranking%EF%BC%89">https://db-engines.com/en/ranking）</a></p><p><img src="/../pic/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/1649253190945.png" alt="1649253190945"></p><h3 id="2-4-常见的数据库介绍"><a href="#2-4-常见的数据库介绍" class="headerlink" title="2.4 常见的数据库介绍"></a>2.4 常见的数据库介绍</h3><p><strong>Oracle</strong></p><p>1979年，Oracle 2诞生，它是第一个商用的RDBMS（关系型数据库管理系统）。随着Oracle软件的名气越来越大，公司也改名叫Oracle公司。</p><p>2007年，总计85亿美金收购BEA System。</p><p>2009年，总计74亿美金收购SUN。此前的2008年，SUN以10亿美金收购MySQL。意味着Oracle同时拥有了MySQL的管理权，至此Oracle在数据库领域中成为绝对的领导者。</p><p>2013年，甲骨文超越IBM，成为继Microsoft后全球第二大软件公司。</p><p>如今Oracle的年收入达到了400亿美金，足以证明商用（收费）数据库软件的价值。</p><p><strong>SQL Server</strong></p><p>SQL Server是微软开发的大型商业数据库，诞生于1989年。C#、.net等语言常使用，与WinNT完全集成，也可以很好地与Microsoft BackOffice产品集成。</p><p><strong>DB2</strong></p><p>IBM公司的数据库产品，收费的。常应用在银行系统中。</p><p><strong>PostgreSQL</strong></p><p>PostgreSQL的稳定性极强，最符合SQL标准，开放源码，具备商业级DBMS质量。PG对数据量大的文本以及SQL处理较快。</p><p><strong>SyBase</strong></p><p>已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。</p><p><strong>SQLite</strong></p><p>嵌入式的小型数据库，应用在手机端。零配置，SQLite3不用安装，不用配置，不用启动、关闭或者配置数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自恢复。</p><p><strong>Informix</strong></p><p>IBM公司出品，取自Information和Unix的结合，它是第一个被移植到Linux上的商业数据库产品。仅运行与Unix&#x2F;Linux平台，命令行操作。性能较高，支持集群 ，适应与安全性要求极高的系统，尤其是银行，证券系统的应用。</p><h2 id="3-MySQL介绍"><a href="#3-MySQL介绍" class="headerlink" title="3. MySQL介绍"></a>3. MySQL介绍</h2><p><img src="/../pic/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/1649254603612.png" alt="1649254603612"></p><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><ul><li>MySQL是一个<code>开放源码的关系型数据库管理系统</code>，由瑞典 MySQL AB（创始人Michael Widenius）公司1995年开发，迅速成为开源数据库的No.1。</li><li>2008年被<code>Sun</code>收购（10亿美金），2009年Sun被<code>Oracle</code>收购。<code>MariaDB</code>应运而生。（MySQL的创造者担心MySQL有闭源的风险，因此创建了MySQL的分支项目MariaDB）</li><li>MySQL6.x版本之后分为<code>社区版</code>和<code>商业版</code>。</li><li>MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</li><li>MySQL是开源的，所以你不需要支付额外的费用。</li><li>MySQL是可以定制的，采用了<code>GPL（GUN General Public License）</code>协议，你可以需改源码来开发自己的MySQL系统。</li><li>MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li><li>MySQL支持大型数据库，支持5000万条记录的数据仓库 ，32位系统表文件最大可支持<code>4GB</code>，64位系统支持最大的表文件为<code>8TB</code>。</li><li>MySQL使用<code>标准的SQL数据语言</code>形式。</li><li>MySQL可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP、和Ruby等。</li></ul><h3 id="3-2-MySQL发展史重大事件"><a href="#3-2-MySQL发展史重大事件" class="headerlink" title="3.2 MySQL发展史重大事件"></a>3.2 MySQL发展史重大事件</h3><p><img src="/../pic/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/1649255680817.png" alt="1649255680817"></p><hr><h2 id="4-RDBMS与非RDBMS"><a href="#4-RDBMS与非RDBMS" class="headerlink" title="4.RDBMS与非RDBMS"></a>4.RDBMS与非RDBMS</h2><hr><p>从排名中我们能看出来，关系型数据库绝对是DBMS的主流，其中使用最多的DBMS分贝是Oracle、MySQL和SQL Server。这些都是关系型数据库（RDBMS）。</p><h3 id="4-1-关系型数据库（RDBMS）"><a href="#4-1-关系型数据库（RDBMS）" class="headerlink" title="4.1 关系型数据库（RDBMS）"></a>4.1 关系型数据库（RDBMS）</h3><h4 id="4-1-1-实质"><a href="#4-1-1-实质" class="headerlink" title="4.1.1 实质"></a>4.1.1 实质</h4><ul><li><p>这种类型的数据库是<code>最古老</code>的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的<code>二元关系</code>（即二维表格形式）。</p><p><img src="/../pic/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/1649296654071.png" alt="1649296654071"></p></li><li><p>关系型数据库以<code>行（row）</code>和<code>列（column）</code>的形式存储数据，以便于用户理解。这一系列的行和列被称为<code>表（table）</code>，一组表组成了一个<code>库（database）</code>。</p></li><li><p>表与表之间的数据记录有关系（relationship）。现实世界中的各种实体以及实体之间的各种联系均用<code>关系模型</code>来表示。关系型数据库就是建立在<code>关系模型</code>基础上的数据库。</p></li><li><p>SQL就是关系型数据库的查询语言。<br><img src="/../pic/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/1649296954469.png" alt="1649296954469"></p></li></ul><h4 id="4-1-2-优势"><a href="#4-1-2-优势" class="headerlink" title="4.1.2 优势"></a>4.1.2 优势</h4><ul><li><strong>复杂查询</strong>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li><li><strong>事务支持</strong>使得对于安全性能很高的数据访问要求得以实现。</li></ul><h3 id="4-2-非关系型数据库（非RDBMS）"><a href="#4-2-非关系型数据库（非RDBMS）" class="headerlink" title="4.2 非关系型数据库（非RDBMS）"></a>4.2 非关系型数据库（非RDBMS）</h3><h4 id="4-2-1-介绍"><a href="#4-2-1-介绍" class="headerlink" title="4.2.1 介绍"></a>4.2.1 介绍</h4><p><strong>非关系型数据库</strong>，可看成传统关系型数据库的功能<code>阉割版本</code>，基于键值对存储数据，不需要经过SQL层的解析，<code>性能非常高</code>。同时通过减少不常用的功能，进一步提高性能。</p><p>目前基本上大部分主流的非关系型数据库都是免费的。</p><h4 id="4-2-2-有哪些非关系型数据库"><a href="#4-2-2-有哪些非关系型数据库" class="headerlink" title="4.2.2 有哪些非关系型数据库"></a>4.2.2 有哪些非关系型数据库</h4><p>相比于SQL，NoSQL泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。也只有用NoSQL一词才能将这些技术囊括进来。</p><p><strong>键值型数据库</strong></p><p>键值型数据库通过Key-Value键值的方式来存储数据，其中Key和Value可以是简单的对象，也可以是复杂的对象，Key作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。</p><p>键值型数据库典型的使用场景是作为<code>内存缓存</code>。<code>Redis</code>是最流行的键值型数据库。</p><p><img src="/../pic/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/1649297904390.png" alt="1649297904390"></p><p><strong>文档型数据库</strong></p><p>此类型数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB是最流行的文档型数据库。此外，还有CouchDB等。</p><p><strong>搜索引擎数据库</strong></p><p>虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。</p><p>典型产品：Solr、Elasticsearch、Splunk等。</p><p><strong>列式数据库</strong></p><p>列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的I&#x2F;O，适合于分布式文件系统，不足在于功能相对有限。典型产品：HBase等。</p><p><img src="/../pic/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/1649298542419.png" alt="1649298542419"></p><p><strong>图形数据库</strong></p><p>图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效的解决复杂的关系问题。典型产品：Neo4J、InfoGrid等。</p><p><img src="/../pic/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/1649299045508.png" alt="1649299045508"></p><h3 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a>4.3 小结</h3><p>NoSQL的分类很多，即便如此，在DBMS排名中，还是SQL阵营的比重更大，影响力前五的DBMS中有4个是关系型数据库，而排名前二十的DBMS中也有12个是关系型数据库。所以说，掌握SQL是非常有必要的。</p><hr><h2 id="5-关系型数据库设计规则"><a href="#5-关系型数据库设计规则" class="headerlink" title="5. 关系型数据库设计规则"></a>5. 关系型数据库设计规则</h2><hr><ul><li>关系型数据库的典型数据结构就是<code>数据表</code>，这些数据表的组成都是结构化的（Structured）。</li><li>将数据放到表中，再放到库中。</li><li>一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。</li><li>表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中“类”的设计。</li></ul><h3 id="5-1-表、记录、字段"><a href="#5-1-表、记录、字段" class="headerlink" title="5.1 表、记录、字段"></a>5.1 表、记录、字段</h3><ul><li>E-R（entity-relationship，实体-联系）模型中有三个主要概念是：<code>实体集</code>、<code>属性</code>、<code>联系集</code>。</li><li>一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也成为一个字段（field）。</li></ul><p><img src="/../pic/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/1649299778965.png" alt="1649299778965"></p><pre class="line-numbers language-none"><code class="language-none">ORM思想（Object Relational Mapping）体现：数据库中的一个表  &lt;---&gt;  Java或Python中的一个类表中的一条数据    &lt;---&gt;  类中的一个对象（或实体）表中的一个列      &lt;---&gt;  类中的一个字段、属性（field)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-表的关联关系"><a href="#5-2-表的关联关系" class="headerlink" title="5.2 表的关联关系"></a>5.2 表的关联关系</h3><ul><li>表与表之间的数据记录有关系（relationship）。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。</li><li>四种：一对一关联、一对多关联、多对多关联、自我引用</li></ul><h4 id="5-2-1-一对一关系（one-to-one）"><a href="#5-2-1-一对一关系（one-to-one）" class="headerlink" title="5.2.1 一对一关系（one-to-one）"></a>5.2.1 一对一关系（one-to-one）</h4><ul><li><p>在实际的开发中应用不多，因为一对一可以创建成一张表。</p></li><li><p>举例：设计</p><pre class="line-numbers language-none"><code class="language-none">学生表<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人……</p><ul><li>拆分为两个表：两个表的记录是一一对应关系</li><li><code>基础信息表</code>（常用信息）：学号、姓名、手机号码、班级、系别</li><li><code>档案信息表</code>（不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人……</li></ul></li><li><p>两种建表原则：</p><ul><li>外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。</li><li>外键是主键：主表的主键和从表的主键，形成主外键关系。</li></ul></li></ul><p><img src="/../pic/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/1649300994707.png" alt="1649300994707"></p><h4 id="5-2-2-一对多关系（one-to-many）"><a href="#5-2-2-一对多关系（one-to-many）" class="headerlink" title="5.2.2 一对多关系（one-to-many）"></a>5.2.2 一对多关系（one-to-many）</h4><ul><li>常见实例场景：<code>客户表和订单表</code>，<code>分类表和商品表</code>，<code>部门表和员工表</code>。</li><li>举例：<ul><li>员工表：编号、姓名、……、所属部门</li><li>部门表：编号、名称、简介</li></ul></li><li>一对多建表原则：在从表（多方）创建一个字段，字段作为外键指向主表（一方）的主键<br><img src="/../pic/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/1649301232967.png" alt="1649301232967"></li></ul><p><img src="/../pic/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/1649301263616.png" alt="1649301263616"></p><p><img src="/../pic/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/1649301279508.png" alt="1649301279508"></p><h4 id="5-2-3-多对多关系（many-to-many）"><a href="#5-2-3-多对多关系（many-to-many）" class="headerlink" title="5.2.3 多对多关系（many-to-many）"></a>5.2.3 多对多关系（many-to-many）</h4><p>要表示多对多关系必须创建第三个表，该表通常称为<code>联接表</code>，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。</p><p><img src="/../pic/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/1649301487428.png" alt="1649301487428"></p><ul><li><p><strong>举例1：学生-课程</strong></p><ul><li><code>学生信息表</code>：一行代表一个学生的信息（学号、姓名、手机号码、班级、系别 ……）</li><li><code>课程信息表</code>：一行代表一个课程的信息（课程编号、授课老师、简介 ……）</li><li><code>选课信息表</code>：一个学生可以选多门课，一门课可以被多个学生选择</li></ul><pre class="line-numbers language-none"><code class="language-none">学号      课程编号1         10012         10011         1002<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>举例2：产品-订单</strong><br>“订单 ”表和“产品”表有一种多对多的关系，这种关系是通过与“订单明细”表建立两个一对多关系来定义的。一个订单可以有多个产品，每个产品可以出现在多个订单中。</p><ul><li><code>产品表</code>：产品表中的每条记录表示一个产品。</li><li><code>订单表</code>：订单表中的每条记录表示一个订单。</li><li><code>订单明细表</code>：每个产品可以与订单表中的多条记录对应，即出现在多个订单中。一个订单可以与产品表中的多条记录对应，即包含多个产品。</li></ul><p><img src="/../pic/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/1649302124634.png" alt="1649302124634"></p></li></ul><h4 id="5-3-4-自我引用（Self-reference）"><a href="#5-3-4-自我引用（Self-reference）" class="headerlink" title="5.3.4 自我引用（Self reference）"></a>5.3.4 自我引用（Self reference）</h4><p><img src="/../pic/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/1649302203297.png" alt="1649302203297"></p><ul><li>在实际的开发中应用不多，因为一对一可以创建成一张表。</li><li>举例：设计<code>学生表</code>：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人、……</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL环境搭建</title>
      <link href="/2022/07/17/di-02-zhang-mysql-huan-jing-da-jian/"/>
      <url>/2022/07/17/di-02-zhang-mysql-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="第02章-MySQL环境搭建"><a href="#第02章-MySQL环境搭建" class="headerlink" title="第02章_MySQL环境搭建"></a>第02章_MySQL环境搭建</h1><h2 id="1-MySQL的卸载"><a href="#1-MySQL的卸载" class="headerlink" title="1. MySQL的卸载"></a>1. MySQL的卸载</h2><hr><h3 id="步骤-1-：停止MySQL服务"><a href="#步骤-1-：停止MySQL服务" class="headerlink" title="步骤 1 ：停止MySQL服务"></a>步骤 1 ：停止MySQL服务</h3><p>在卸载之前，先停止MySQL8.0的服务。按键盘上的“Ctrl + Alt + Delete”组合键，打开“任务管理器”对话框，可以在“服务”列表找到“MySQL8.0”的服务，如果现在“正在运行”状态，可以右键单击服务，选择“停止”选项停止MySQL8.0的服务，如图所示。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649303026758.png" alt="1649303026758"></p><h3 id="步骤-2-：软件的卸载"><a href="#步骤-2-：软件的卸载" class="headerlink" title="步骤 2 ：软件的卸载"></a>步骤 2 ：软件的卸载</h3><p><strong>方式 1 ：通过控制面板方式</strong></p><p>卸载MySQL8.0的程序可以和其他桌面应用程序一样直接在“控制面板”选择“卸载程序”，并在程序列表中找到MySQL8.0服务器程序，直接双击卸载即可，如图所示。这种方式删除，数据目录下的数据不会跟着删除。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649303153973.png" alt="1649303153973"></p><p><strong>方式 2 ：通过 360 或电脑管家等软件卸载</strong></p><p><strong>方式 3 ：通过安装包提供的卸载功能卸载</strong></p><p>你也可以通过安装向导程序进行MySQL8.0服务器程序的卸载。</p><p>① 再次双击下载的mysql-installer-community-8.0.26.0.msi文件，打开安装向导。安装向导会自动检测已安装的MySQL服务器程序。</p><p>② 选择要卸载的MySQL服务器程序，单击“Remove”（移除），即可进行卸载。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649303254527.png" alt="1649303254527"></p><p>③ 单击“Next”（下一步）按钮，确认卸载。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649303271446.png" alt="1649303271446"></p><p>④ 弹出是否同时移除数据目录选择窗口。如果想要同时删除MySQL服务器中的数据，则勾选“Remove the data directory”，如图所示。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649303304473.png" alt="1649303304473"></p><p>⑤ 执行卸载。单击“Execute”（执行）按钮进行卸载。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649303323942.png" alt="1649303323942"></p><p>⑥ 完成卸载。单击“Finish”（完成）按钮即可。如果想要同时卸载MySQL8.0的安装向导程序，勾选“Yes，Uninstall MySQL Installer”即可，如图所示。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649303349934.png" alt="1649303349934"></p><h3 id="步骤-3-：残余文件的清理"><a href="#步骤-3-：残余文件的清理" class="headerlink" title="步骤 3 ：残余文件的清理"></a>步骤 3 ：残余文件的清理</h3><p>如果再次安装不成功，可以卸载后对残余文件进行清理后再安装。</p><ul><li>服务目录：mysql服务的安装目录</li><li>数据目录：默认在C:\ProgramData\MySQL</li></ul><p>如果自己单独指定过数据目录，就找到自己的数据目录进行删除即可。</p><p><strong>注意：请在卸载前做好数据备份</strong><br>在操作完以后，需要重启计算机，然后进行安装即可。<strong>如果仍然安装失败，需要继续操作如下步骤 4</strong></p><h3 id="步骤-4-：清理注册表（选做）"><a href="#步骤-4-：清理注册表（选做）" class="headerlink" title="步骤 4 ：清理注册表（选做）"></a>步骤 4 ：清理注册表（选做）</h3><p>如果前几步做了，再次安装还是失败，那么可以清理注册表。</p><p>如何打开注册表编辑器：在系统的搜索框中输入<code>regedit</code></p><pre class="line-numbers language-reg" data-language="reg"><code class="language-reg">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL服务 目录删除HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\MySQL服务 目录删除HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL服务 目录删除HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\MySQL服务 目录删除HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL服务 目录删除HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MySQL服务删除注册表中的ControlSet001,ControlSet002,不一定是 001 和002,可能是ControlSet005、 006之类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="步骤-5-：删除环境变量配置"><a href="#步骤-5-：删除环境变量配置" class="headerlink" title="步骤 5 ：删除环境变量配置"></a>步骤 5 ：删除环境变量配置</h3><p>找到path环境变量，将其中关于mysql的环境变量删除， <strong>切记不要全部删除。</strong></p><p>例如：删除 D:\develop_tools\mysql\MySQLServer8.0.26\bin 这个部分</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649303824570.png" alt="1649303824570"></p><hr><h2 id="2-MySQL的下载、安装、配置"><a href="#2-MySQL的下载、安装、配置" class="headerlink" title="2. MySQL的下载、安装、配置"></a>2. MySQL的下载、安装、配置</h2><hr><h3 id="2-1-MySQL的-4-大版本"><a href="#2-1-MySQL的-4-大版本" class="headerlink" title="2. 1 MySQL的 4 大版本"></a>2. 1 MySQL的 4 大版本</h3><ul><li><strong>MySQL Community Server 社区版本</strong> ，开源免费，自由下载，但不提供官方技术支持，适用于大多数普通用户。</li><li><strong>MySQL Enterprise Edition 企业版本</strong> ，需付费，不能在线下载，可以试用 30 天。提供了更多的功能和更完备的技术支持，更适合于对数据库的功能和可靠性要求较高的企业客户。</li><li><strong>MySQL Cluster 集群版</strong> ，开源免费。用于架设集群服务器，可将几个MySQL Server封装成一个Server。需要在社区版或企业版的基础上使用。</li><li><strong>MySQL Cluster CGE 高级集群版</strong> ，需付费。</li></ul><p>目前最新版本为<code>8.0.27</code>，发布时间 <code>2021 年 10 月</code>。此前，8.0.0 在 2016.9.12日就发布了。</p><p>此外，官方还提供了<code>MySQL Workbench</code>（GUITOOL）一款专为MySQL设计的<code>图形界面管理工具</code>。MySQLWorkbench又分为两个版本，分别是<code>社区版</code>（MySQL Workbench OSS）、<code>商用版</code>（MySQLWorkbenchSE）。</p><h3 id="2-2-软件的下载"><a href="#2-2-软件的下载" class="headerlink" title="2. 2 软件的下载"></a>2. 2 软件的下载</h3><p><strong>1. 下载地址</strong></p><p>官网： <a href="https://www.mysql.com/">https://www.mysql.com</a></p><p><strong>2. 打开官网，点击DOWNLOADS</strong></p><p>然后，点击<code>MySQL Community(GPL) Downloads</code></p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649304333457.png" alt="1649304333457"></p><p><strong>3. 点击 MySQL Community Server</strong></p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649304358116.png" alt="1649304358116"></p><p><strong>4. 在General Availability(GA) Releases中选择适合的版本</strong></p><p>Windows平台下提供两种安装文件：MySQL二进制分发版（.msi安装文件）和免安装版（.zip压缩文件）。一般来讲，应当使用二进制分发版，因为该版本提供了图形化的安装向导过程，比其他的分发版使用起来要简单，不再需要其他工具启动就可以运行MySQL。</p><ul><li>这里在Windows 系统下推荐下载<code>MSI安装程序</code>；点击<code>Go to Download Page</code>进行下载即可</li></ul><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649304434342.png" alt="1649304434342"></p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649304454538.png" alt="1649304454538"></p><ul><li><p>Windows下的MySQL 8. 0 安装有两种安装程序</p><ul><li><code>mysql-installer-web-community-8.0.26.0.msi</code> 下载程序大小： 2. 4 M；安装时需要联网安装组件。</li><li><code>mysql-installer-community-8.0.26.0.msi</code> 下载程序大小： 450. 7 M；安装时离线安装即<br>可。 <strong>推荐</strong>。</li></ul></li><li><p>如果安装MySQL 5. 7 版本的话，选择<code>Archives</code>，接着选择MySQL 5. 7 的相应版本即可。这里下载最近期的MySQL 5. 7. 34 版本。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649307495198.png" alt="1649307495198"></p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649307522933.png" alt="1649307522933"></p></li></ul><h3 id="2-3-MySQL-8-0-版本的安装"><a href="#2-3-MySQL-8-0-版本的安装" class="headerlink" title="2. 3 MySQL 8. 0 版本的安装"></a>2. 3 MySQL 8. 0 版本的安装</h3><p>MySQL下载完成后，找到下载文件，双击进行安装，具体操作步骤如下。</p><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h4><p>双击下载的mysql-installer-community-8.0.26.0.msi文件，打开安装向导。</p><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h4><p>打开“Choosing a Setup Type”（选择安装类型）窗口，在其中列出了 5 种安装类型，分别是Developer Default（默认安装类型）、Server only（仅作为服务器）、Client only（仅作为客户端）、Full（完全安装）、Custom（自定义安装）。这里选择“Custom（自定义安装）”类型按钮，单击“Next(下一步)”按钮。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649307637871.png" alt="1649307637871"></p><h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h4><p>打开“Select Products” （选择产品）窗口，可以定制需要安装的产品清单。例如，选择“MySQL Server 8.0.26-X64”后，单击“→”添加按钮，即可选择安装MySQL服务器，如图所示。采用通用的方法，可以添加其他你需要安装的产品。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649307675772.png" alt="1649307675772"></p><p>此时如果直接“Next”（下一步），则产品的安装路径是默认的。如果想要自定义安装目录，则可以选中对应的产品，然后在下面会出现“Advanced Options”（高级选项）的超链接。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649307702104.png" alt="1649307702104"></p><p>单击“Advanced Options”（高级选项）则会弹出安装目录的选择窗口，如图所示，此时你可以分别设置MySQL的服务程序安装目录和数据存储目录。如果不设置，默认分别在C盘的Program Files目录和ProgramData目录（这是一个隐藏目录）。如果自定义安装目录，请避免“中文”目录。另外，建议服务目录和数据目录分开存放。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649307732585.png" alt="1649307732585"></p><h4 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h4><p>在上一步选择好要安装的产品之后，单击“Next”（下一步）进入确认窗口，如图所示。单击<br>“Execute”（执行）按钮开始安装。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649307762968.png" alt="1649307762968"></p><h4 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h4><p>安装完成后在“Status”（状态）列表下将显示“Complete”（安装完成），如图所示。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649307787117.png" alt="1649307787117"></p><h3 id="2-4-配置MySQL-8-0"><a href="#2-4-配置MySQL-8-0" class="headerlink" title="2. 4 配置MySQL 8. 0"></a>2. 4 配置MySQL 8. 0</h3><p>MySQL安装之后，需要对服务器进行配置。具体的配置步骤如下。</p><h4 id="步骤-1-1"><a href="#步骤-1-1" class="headerlink" title="步骤 1"></a>步骤 1</h4><p>在上一个小节的最后一步，单击“Next”（下一步）按钮，就可以进入产品配置窗口。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649307826152.png" alt="1649307826152"></p><h4 id="步骤-2-1"><a href="#步骤-2-1" class="headerlink" title="步骤 2"></a>步骤 2</h4><p>单击“Next”（下一步）按钮，进入MySQL服务器类型配置窗口，如图所示。端口号一般选择默认<br>端口号 3306 。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649307859122.png" alt="1649307859122"></p><p>其中，“Config Type”选项用于设置服务器的类型。单击该选项右侧的下三角按钮，即可查看 3 个选项，如图所示。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649307876000.png" alt="1649307876000"></p><ul><li><code>Development Machine（开发机器）</code>：该选项代表典型个人用桌面工作站。此时机器上需要运行多个应用程序，那么MySQL服务器将占用最少的系统资源。</li><li><code>Server Machine（服务器）</code>：该选项代表服务器，MySQL服务器可以同其他服务器应用程序一起运行，例如Web服务器等。MySQL服务器配置成适当比例的系统资源。</li><li><code>Dedicated Machine（专用服务器）</code>：该选项代表只运行MySQL服务的服务器。MySQL服务器配置成使用所有可用系统资源。</li></ul><h4 id="步骤-3-1"><a href="#步骤-3-1" class="headerlink" title="步骤 3"></a>步骤 3</h4><p>单击“Next”（下一步）按钮，打开设置授权方式窗口。其中，上面的选项是MySQL8.0提供的新的授权方式，采用SHA256基础的密码加密方法；下面的选项是传统授权方法（保留5.x版本兼容性）。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649307976040.png" alt="1649307976040"></p><h4 id="步骤-4-1"><a href="#步骤-4-1" class="headerlink" title="步骤 4"></a>步骤 4</h4><p>单击“Next”（下一步）按钮，打开设置服务器root超级管理员的密码窗口，如图所示，需要输入两次同样的登录密码。也可以通过“Add User”添加其他用户，添加其他用户时，需要指定用户名、允许该用户名在哪台&#x2F;哪些主机上登录，还可以指定用户角色等。此处暂不添加用户，用户管理在MySQL高级特性篇中讲解。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649308004239.png" alt="1649308004239"></p><h4 id="步骤-5-1"><a href="#步骤-5-1" class="headerlink" title="步骤 5"></a>步骤 5</h4><p>单击“Next”（下一步）按钮，打开设置服务器名称窗口，如图所示。该服务名会出现在Windows服务列表中，也可以在命令行窗口中使用该服务名进行启动和停止服务。本书将服务名设置为“MySQL80”。如果希望开机自启动服务，也可以勾选“Start the MySQL Server at System Startup”选项（推荐）。</p><p>下面是选择以什么方式运行服务？可以选择“Standard System Account”(标准系统用户)或者“Custom User”(自定义用户)中的一个。这里推荐前者。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649308064878.png" alt="1649308064878"></p><h4 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h4><p>单击“Next”（下一步）按钮，打开确认设置服务器窗口，单击“Execute”（执行）按钮。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649308088656.png" alt="1649308088656"></p><h4 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤 7"></a>步骤 7</h4><p>完成配置，如图所示。单击“Finish”（完成）按钮，即可完成服务器的配置。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649308108259.png" alt="1649308108259"></p><h4 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤 8"></a>步骤 8</h4><p>如果还有其他产品需要配置，可以选择其他产品，然后继续配置。如果没有，直接选择“Next”（下一步），直接完成整个安装和配置过程。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649308137634.png" alt="1649308137634"></p><h4 id="步骤-9"><a href="#步骤-9" class="headerlink" title="步骤 9"></a>步骤 9</h4><p>结束安装和配置。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649308169934.png" alt="1649308169934"></p><h3 id="2-5-配置MySQL-8-0-环境变量"><a href="#2-5-配置MySQL-8-0-环境变量" class="headerlink" title="2. 5 配置MySQL 8. 0 环境变量"></a>2. 5 配置MySQL 8. 0 环境变量</h3><p>如果不配置MySQL环境变量，就不能在命令行直接输入MySQL登录命令。下面说如何配置MySQL的环境变量：</p><ul><li>步骤 1 ：在桌面上右击【此电脑】图标，在弹出的快捷菜单中选择【属性】菜单命令。</li><li>步骤 2 ：打开【系统】窗口，单击【高级系统设置】链接。</li><li>步骤 3 ：打开【系统属性】对话框，选择【高级】选项卡，然后单击【环境变量】按钮。</li><li>步骤 4 ：打开【环境变量】对话框，在系统变量列表中选择path变量。</li><li>步骤5 ：单击【编辑】按钮，在【编辑环境变量】对话框中，将MySQL应用程序的bin目录（C:\ProgramFiles\MySQL\MySQL Server 8.0\bin）添加到变量值中，用分号将其与其他路径分隔开。</li><li>步骤 6 ：添加完成之后，单击【确定】按钮，这样就完成了配置path变量的操作，然后就可以直接输入MySQL命令来登录数据库了。</li></ul><hr><h2 id="3-MySQL的登录"><a href="#3-MySQL的登录" class="headerlink" title="3. MySQL的登录"></a>3. MySQL的登录</h2><hr><h3 id="3-1-服务的启动与停止"><a href="#3-1-服务的启动与停止" class="headerlink" title="3. 1 服务的启动与停止"></a>3. 1 服务的启动与停止</h3><p>MySQL安装完毕之后，需要启动服务器进程，不然客户端无法连接数据库。</p><p>在前面的配置过程中，已经将MySQL安装为Windows服务，并且勾选当Windows启动、停止时，MySQL也自动启动、停止。</p><h4 id="方式-1-：使用图形界面工具"><a href="#方式-1-：使用图形界面工具" class="headerlink" title="方式 1 ：使用图形界面工具"></a>方式 1 ：使用图形界面工具</h4><ul><li><p>步骤 1 ：打开windows服务</p><ul><li>方式 1 ：计算机（点击鼠标右键）→ 管理（点击）→ 服务和应用程序（点击）→ 服务（点击）</li><li>方式 2 ：控制面板（点击）→ 系统和安全（点击）→ 管理工具（点击）→ 服务（点击）</li><li>方式 3 ：任务栏（点击鼠标右键）→ 启动任务管理器（点击）→ 服务（点击）</li><li>方式 4 ：单击【开始】菜单，在搜索框中输入“services.msc”，按Enter键确认</li></ul></li><li><p>步骤 2 ：找到MySQL80（点击鼠标右键）→ 启动或停止（点击）</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649308460985.png" alt="1649308460985"></p></li></ul><h4 id="方式-2-：使用命令行工具"><a href="#方式-2-：使用命令行工具" class="headerlink" title="方式 2 ：使用命令行工具"></a>方式 2 ：使用命令行工具</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启动　MySQL　服务命令</span>net　start　MySQL服务名<span class="token comment"># 停止　MySQL　服务命令</span>net　stop　MySQL服务名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649308814635.png" alt="1649308814635"></p><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><ul><li>start和stop后面的服务名应与之前配置时指定的服务名一致。</li><li>如果当你输入命令后，提示“拒绝服务”，请以<code>系统管理员身份</code>打开命令提示符界面重新尝试。</li></ul><h3 id="3-2-自带客户端的登录与退出"><a href="#3-2-自带客户端的登录与退出" class="headerlink" title="3. 2 自带客户端的登录与退出"></a>3. 2 自带客户端的登录与退出</h3><p>当MySQL服务启动完成后，便可以通过客户端来登录MySQL数据库。注意：确认服务是开启的。</p><h4 id="登录方式-1-：MySQL自带客户端"><a href="#登录方式-1-：MySQL自带客户端" class="headerlink" title="登录方式 1 ：MySQL自带客户端"></a>登录方式 1 ：MySQL自带客户端</h4><p>开始菜单 → 所有程序 → MySQL → MySQL 8.0 Command Line Client</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649308894051.png" alt="1649308894051"></p><ul><li>说明：仅限于root用户</li></ul><h4 id="登录方式-2-：windows命令行"><a href="#登录方式-2-：windows命令行" class="headerlink" title="登录方式 2 ：windows命令行"></a>登录方式 2 ：windows命令行</h4><ul><li><p>格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -h 主机名 -P 端口号 -u 用户名 -p密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>举例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -h localhost -P <span class="token number">3306</span> -u root -pabc123  <span class="token comment"># 这里我设置的root用户的密码是abc123</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649309163663.png" alt="1649309163663"></p></li><li><p>注意：<br>1．-p与密码之间不能有空格，其他参数名与参数值之间可以有空格也可以没有空格。如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -hlocalhost -P3306 -uroot -pabc123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>２．密码建议在下一行输入，保证安全</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -h localhost -P <span class="token number">3306</span> -u root -pEnter password:****<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>3．客户端和服务器在同一台机器上，所以输入localhost或者IP地址127.0.0.1。同时，因为是连接本机： -hlocalhost就可以省略，如果端口号没有修改：-P3306也可以省略</p><p>简写成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -u root -pEnter password:****<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>连接成功后，有关于MySQL Server服务版本的信息，还有第几次连接的id标识。</p><p>也可以在命令行通过以下方式获取MySQL Server服务版本的信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">c:<span class="token punctuation">\</span><span class="token operator">></span> mysql -V<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">c:<span class="token punctuation">\</span><span class="token operator">></span> mysql --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或<strong>登录</strong>后，通过以下方式查看当前版本信息：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select version();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">exit或quit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="4-MySQL演示使用"><a href="#4-MySQL演示使用" class="headerlink" title="4. MySQL演示使用"></a>4. MySQL演示使用</h2><hr><h3 id="4-1-MySQL的使用演示"><a href="#4-1-MySQL的使用演示" class="headerlink" title="4. 1 MySQL的使用演示"></a>4. 1 MySQL的使用演示</h3><h4 id="1-查看所有的数据库"><a href="#1-查看所有的数据库" class="headerlink" title="1 .查看所有的数据库"></a>1 .查看所有的数据库</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show databases;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>“information_schema”是 MySQL 系统自带的数据库，主要保存 MySQL 数据库服务器的系统信息，比如数据库的名称、数据表的名称、字段名称、存取权限、数据文件 所在的文件夹和系统使用的文件夹，等等。</li><li>“performance_schema”是 MySQL 系统自带的数据库，可以用来监控 MySQL 的各类性能指标。</li><li>“sys”数据库是 MySQL 系统自带的数据库，主要作用是以一种更容易被理解的方式展示 MySQL 数据库服务器的各类性能指标，帮助系统管理员和开发人员监控 MySQL 的技术性能。</li><li>“mysql”数据库保存了 MySQL 数据库服务器运行时需要的系统信息，比如数据文件夹、当前使用的字符集、约束检查信息，等等。</li></ul><p>为什么 Workbench 里面我们只能看到“demo”和“sys”这 2 个数据库呢？</p><p>这是因为，Workbench 是图形化的管理工具，主要面向开发人 员，“demo”和“sys”这 2 个数据库已经够用了。如果有特殊需求，比如，需要监控 MySQL 数据库各项性能指标、直接操作 MySQL 数据库系统文件等，可以由 DBA 通过 SQL 语句，查看其它的系统数据库。</p><h4 id="2-、创建自己的数据库"><a href="#2-、创建自己的数据库" class="headerlink" title="2 、创建自己的数据库"></a>2 、创建自己的数据库</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create database 数据库名;#创建atguigudb数据库，该名称不能与已经存在的数据库重名。create database atguigudb;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-、使用自己的数据库"><a href="#3-、使用自己的数据库" class="headerlink" title="3 、使用自己的数据库"></a>3 、使用自己的数据库</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">use 数据库名;#使用atguigudb数据库use atguigudb;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>说明：如果没有使用use语句，后面针对数据库的操作也没有加“数据名”的限定，那么会报“ERROR 1046(3D000): No database selected”（没有选择数据库）</p><p>使用完use语句之后，如果接下来的SQL都是针对一个数据库操作的，那就不用重复use了，如果要针对另一个数据库操作，那么要重新use。</p><h4 id="4-、查看某个库的所有表格"><a href="#4-、查看某个库的所有表格" class="headerlink" title="4 、查看某个库的所有表格"></a>4 、查看某个库的所有表格</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show tables;  #要求前面有use语句show tables from 数据库名;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="5-、创建新的表格"><a href="#5-、创建新的表格" class="headerlink" title="5 、创建新的表格"></a>5 、创建新的表格</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create table 表名称(字段名 数据类型,字段名 数据类型);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>说明：如果是最后一个字段，后面就用加逗号，因为逗号的作用是分割每个字段。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#创建学生表create table student(id int,name varchar( 20 )  #说名字最长不超过 20 个字符);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-、查看一个表的数据"><a href="#6-、查看一个表的数据" class="headerlink" title="6 、查看一个表的数据"></a>6 、查看一个表的数据</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select * from 数据库表名称;#查看学生表的数据select * from student;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-、添加一条记录"><a href="#7-、添加一条记录" class="headerlink" title="7 、添加一条记录"></a>7 、添加一条记录</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">insert into 表名称 values(值列表);#添加两条记录到student表中insert into student values( 1 ,&#39;张三&#39;);insert into student values( 2 ,&#39;李四&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>报错：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; insert into student values( 1 ,&#39;张三&#39;);ERROR 1366 (HY000): Incorrect string value: &#39;\xD5\xC5\xC8\xFD&#39; for column &#39;name&#39; at　row 1mysql&gt; insert into student values( 2 ,&#39;李四&#39;);ERROR 1366 (HY000): Incorrect string value: &#39;\xC0\xEE\xCB\xC4&#39; for column &#39;name&#39; at　row 1mysql&gt; show create table student;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符集的问题。</p><h4 id="8-、查看表的创建信息"><a href="#8-、查看表的创建信息" class="headerlink" title="8 、查看表的创建信息"></a>8 、查看表的创建信息</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show create table 表名称\G#查看student表的详细创建信息show create table student\G#结果如下*************************** 1. row ***************************Table: studentCreate Table: CREATE TABLE &#96;student&#96; (&#96;id&#96; int( 11 ) DEFAULT NULL,&#96;name&#96; varchar( 20 ) DEFAULT NULL) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;latin11 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的结果显示student的表格的默认字符集是“latin1”不支持中文。</p><h4 id="9-、查看数据库的创建信息"><a href="#9-、查看数据库的创建信息" class="headerlink" title="9 、查看数据库的创建信息"></a>9 、查看数据库的创建信息</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show create database 数据库名\G#查看atguigudb数据库的详细创建信息show create database atguigudb\G<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面的结果显示atguigudb数据库也不支持中文，字符集默认是latin1。</p><h4 id="10-、删除表格"><a href="#10-、删除表格" class="headerlink" title="10 、删除表格"></a>10 、删除表格</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">drop table 表名称;#删除学生表drop table student;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="11-、删除数据库"><a href="#11-、删除数据库" class="headerlink" title="11 、删除数据库"></a>11 、删除数据库</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">drop database 数据库名;#删除atguigudb数据库drop database atguigudb;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-MySQL的编码设置"><a href="#4-2-MySQL的编码设置" class="headerlink" title="4. 2 MySQL的编码设置"></a>4. 2 MySQL的编码设置</h3><p><strong>MySQL 8. 0 中</strong></p><p>在MySQL 8.0版本之前，默认字符集为latin1，utf8字符集指向的是utf8mb3。网站开发人员在数据库设计的时候往往会将编码修改为utf8字符集。如果遗忘修改默认的编码，就会出现乱码的问题。从MySQL 8.0开始，数据库的默认编码改为<code>utf8mb4</code>，从而避免了上述的乱码问题。</p><hr><h2 id="5-MySQL图形化管理工具"><a href="#5-MySQL图形化管理工具" class="headerlink" title="5. MySQL图形化管理工具"></a>5. MySQL图形化管理工具</h2><hr><p>MySQL图形化管理工具极大地方便了数据库的操作与管理，常用的图形化管理工具有：MySQL<br>Workbench、phpMyAdmin、Navicat Preminum、MySQLDumper、SQLyog、dbeaver、MySQL ODBCConnector。</p><h3 id="Navicat"><a href="#Navicat" class="headerlink" title="Navicat"></a>Navicat</h3><p>Navicat MySQL是一个强大的MySQL数据库服务器管理和开发工具。它可以与任何3.21或以上版本的MySQL一起工作，支持触发器、存储过程、函数、事件、视图、管理用户等，对新手来说易学易用。其精心设计的图形用户界面可以让用户用一种安全简便的方式来快速方便地创建、组织、访问和共享信息。Navicat支持中文，有免费版本提供。下载地址：**<a href="http://www.navicat.com/">http://www.navicat.com/</a>** 。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649310749563.png" alt="1649310749563"></p><h3 id="可能出现连接问题"><a href="#可能出现连接问题" class="headerlink" title="可能出现连接问题"></a>可能出现连接问题</h3><p>有些图形界面工具，特别是旧版本的图形界面工具，在连接MySQL8时出现“Authentication plugin ‘caching_sha2_password’ cannot be loaded”错误。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649310934310.png" alt="1649310934310"></p><p>出现这个原因是MySQL8之前的版本中加密规则是mysql_native_password，而在MySQL8之后，加密规则是caching_sha2_password。解决问题方法有两种，第一种是升级图形界面工具版本，第二种是把MySQL8用户登录密码加密规则还原成mysql_native_password。</p><p>第二种解决方案如下，用命令行登录MySQL数据库之后，执行如下命令修改用户密码加密规则并更新用户密码，这里修改用户名为“root@localhost”的用户密码规则为“mysql_native_password”，密码值为“123456”，如图所示。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#使用mysql数据库USE mysql;#修改&#39;root&#39;@&#39;localhost&#39;用户的密码规则和密码ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;abc123&#39;;#刷新权限FLUSH PRIVILEGES;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649311079248.png" alt="1649311079248"></p><hr><h2 id="6-MySQL目录结构与源码"><a href="#6-MySQL目录结构与源码" class="headerlink" title="6. MySQL目录结构与源码"></a>6. MySQL目录结构与源码</h2><hr><h3 id="6-1-主要目录结构"><a href="#6-1-主要目录结构" class="headerlink" title="6. 1 主要目录结构"></a>6. 1 主要目录结构</h3><table><thead><tr><th>MySQL的目录结构</th><th>说明</th></tr></thead><tbody><tr><td>bin目录</td><td>所有MySQL的可执行文件。如：mysql.exe</td></tr><tr><td>MySQLInstanceConfig.exe</td><td>数据库的配置向导，在安装时出现的内容</td></tr><tr><td>data目录</td><td>系统数据库所在的目录</td></tr><tr><td>my.ini文件</td><td>MySQL的主要配置文件</td></tr><tr><td>c:\ProgramData\MySQL\MySQL Server 8.0\data\</td><td>用户创建的数据库所在的目录</td></tr></tbody></table><h3 id="6-2-MySQL-源代码获取"><a href="#6-2-MySQL-源代码获取" class="headerlink" title="6. 2 MySQL 源代码获取"></a>6. 2 MySQL 源代码获取</h3><p>首先，你要进入 MySQL下载界面。 这里你不要选择用默认的“Microsoft Windows”，而是要通过下拉栏，找到“Source Code”，在下面的操作系统版本里面， 选择 Windows（Architecture Independent），然后点击下载。</p><p>接下来，把下载下来的压缩文件解压，我们就得到了 MySQL 的源代码。</p><p>MySQL 是用 C++ 开发而成的，我简单介绍一下源代码的组成。</p><p>mysql-8.0.22 目录下的各个子目录，包含了 MySQL 各部分组件的源代码：</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649311641907.png" alt="1649311641907"></p><ul><li>sql 子目录是 MySQL 核心代码；</li><li>libmysql 子目录是客户端程序 API；</li><li>mysql-test 子目录是测试工具；</li><li>mysys 子目录是操作系统相关函数和辅助函数；</li></ul><p>源代码可以用记事本打开查看，如果你有 C++ 的开发环境，也可以在开发环境中打开查看。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649311674506.png" alt="1649311674506"></p><p>如上图所示，源代码并不神秘，就是普通的 C++ 代码，跟你熟悉的一样，而且有很多注释，可以帮助你理解。阅读源代码就像在跟 MySQL 的开发人员对话一样，十分有趣。</p><hr><h2 id="7-常见问题的解决-课外内容"><a href="#7-常见问题的解决-课外内容" class="headerlink" title="7. 常见问题的解决(课外内容)"></a>7. 常见问题的解决(课外内容)</h2><hr><h3 id="问题-1-：root用户密码忘记，重置的操作"><a href="#问题-1-：root用户密码忘记，重置的操作" class="headerlink" title="问题 1 ：root用户密码忘记，重置的操作"></a>问题 1 ：root用户密码忘记，重置的操作</h3><ol><li>通过任务管理器或者服务管理，关掉mysqld(服务进程)</li><li>通过命令行+特殊参数开启mysqld mysqld – defaults-file&#x3D;”D:\ProgramFiles\mysql\MySQLServer5.7Data\my.ini” –skip-grant-tables</li><li>此时，mysqld服务进程已经打开。并且不需要权限检查</li><li>mysql -uroot 无密码登陆服务器。另启动一个客户端进行</li><li>修改权限表 （ 1 ） use mysql; （ 2 ）update user set authentication_string&#x3D;password(‘新密码’) where user&#x3D;’root’ and Host&#x3D;’localhost’; （ 3 ）flush privileges;</li><li>通过任务管理器，关掉mysqld服务进程。</li><li>再次通过服务管理，打开mysql服务。</li><li>即可用修改后的新密码登陆。</li></ol><h3 id="问题-2-：mysql命令报“不是内部或外部命令”"><a href="#问题-2-：mysql命令报“不是内部或外部命令”" class="headerlink" title="问题 2 ：mysql命令报“不是内部或外部命令”"></a>问题 2 ：mysql命令报“不是内部或外部命令”</h3><p>如果输入mysql命令报“不是内部或外部命令”，把mysql安装目录的bin目录配置到环境变量path中。如下：</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649311870661.png" alt="1649311870661"></p><h3 id="问题-3-：错误ERROR-：没有选择数据库就操作表格和数据"><a href="#问题-3-：错误ERROR-：没有选择数据库就操作表格和数据" class="headerlink" title="问题 3 ：错误ERROR ：没有选择数据库就操作表格和数据"></a>问题 3 ：错误ERROR ：没有选择数据库就操作表格和数据</h3><table><thead><tr><th>ERROR 1046 (3D000): No database selected</th></tr></thead><tbody><tr><td>解决方案一：就是使用“USE 数据库名;”语句，这样接下来的语句就默认针对这个数据库进行操作</td></tr><tr><td>解决方案二：就是所有的表对象前面都加上“数据库.”</td></tr></tbody></table><h3 id="问题-4-：命令行客户端的字符集问题"><a href="#问题-4-：命令行客户端的字符集问题" class="headerlink" title="问题 4 ：命令行客户端的字符集问题"></a>问题 4 ：命令行客户端的字符集问题</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; INSERT INTO t_stu VALUES( 1 ,&#39;张三&#39;,&#39;男&#39;);ERROR 1366 (HY000): Incorrect string value: &#39;\xD5\xC5\xC8\xFD&#39; for column &#39;sname&#39; at row 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>原因：服务器端认为你的客户端的字符集是utf- 8 ，而实际上你的客户端的字符集是GBK。</p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649311972853.png" alt="1649311972853"></p><p>查看所有字符集： <strong>SHOW VARIABLES LIKE ‘character_set_%’;</strong></p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649311995332.png" alt="1649311995332"></p><p>解决方案，设置当前连接的客户端字符集 <strong>“SET NAMES GBK;”</strong></p><p><img src="/../pic/%E7%AC%AC02%E7%AB%A0_MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1649312040335.png" alt="1649312040335"></p><h3 id="问题-5-：修改数据库和表的字符编码"><a href="#问题-5-：修改数据库和表的字符编码" class="headerlink" title="问题 5 ：修改数据库和表的字符编码"></a>问题 5 ：修改数据库和表的字符编码</h3><p>修改编码：</p><ol><li>先停止服务</li><li>修改my.ini文件</li><li>重新启动服务</li></ol><p>说明：</p><p>如果是在修改my.ini之前建的库和表，那么库和表的编码还是原来的Latin1，要么删了重建，要么使用alter语句修改编码。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">create</span> <span class="token keyword">database</span> <span class="token number">0728</span> db <span class="token keyword">charset</span> Latin1<span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">use</span> <span class="token number">0728</span>db<span class="token punctuation">;</span><span class="token keyword">Database</span> changedmysql<span class="token operator">></span> <span class="token keyword">create</span> <span class="token keyword">table</span> student <span class="token punctuation">(</span>id <span class="token keyword">int</span> <span class="token punctuation">,</span> name <span class="token keyword">varchar</span><span class="token punctuation">(</span> <span class="token number">20</span> <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">charset</span> Latin1<span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.02</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">show</span> <span class="token keyword">create</span> <span class="token keyword">table</span> student\G<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token keyword">Table</span>: student<span class="token keyword">Create</span> <span class="token keyword">Table</span>: <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>student<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span> <span class="token number">11</span> <span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span> <span class="token number">20</span> <span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>latin1<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">alter</span> <span class="token keyword">table</span> student <span class="token keyword">charset</span> utf8<span class="token punctuation">;</span> <span class="token comment">#修改表字符编码为UTF8</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>Records: <span class="token number">0</span> Duplicates: <span class="token number">0</span> <span class="token keyword">Warnings</span>: <span class="token number">0</span>mysql<span class="token operator">></span> <span class="token keyword">show</span> <span class="token keyword">create</span> <span class="token keyword">table</span> student\G<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token keyword">Table</span>: student<span class="token keyword">Create</span> <span class="token keyword">Table</span>: <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>student<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span> <span class="token number">11</span> <span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span> <span class="token number">20</span> <span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> latin1 <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token comment">#字段仍然是latin1编码</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">alter</span> <span class="token keyword">table</span> student <span class="token keyword">modify</span> name <span class="token keyword">varchar</span><span class="token punctuation">(</span> <span class="token number">20</span> <span class="token punctuation">)</span> <span class="token keyword">charset</span> utf8<span class="token punctuation">;</span> <span class="token comment">#修改字段字符编码为UTF8</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.05</span> sec<span class="token punctuation">)</span>Records: <span class="token number">0</span> Duplicates: <span class="token number">0</span> <span class="token keyword">Warnings</span>: <span class="token number">0</span>mysql<span class="token operator">></span> <span class="token keyword">show</span> <span class="token keyword">create</span> <span class="token keyword">table</span> student\G<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token keyword">Table</span>: student<span class="token keyword">Create</span> <span class="token keyword">Table</span>: <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>student<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span> <span class="token number">11</span> <span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span> <span class="token number">20</span> <span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">show</span> <span class="token keyword">create</span> <span class="token keyword">database</span> <span class="token number">0728</span> db<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------+-----------------------------------------------------------------+</span><span class="token operator">|</span><span class="token keyword">Database</span><span class="token operator">|</span> <span class="token keyword">Create</span> <span class="token keyword">Database</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------+-------------------------------------------------------------------+</span><span class="token operator">|</span> <span class="token number">0728</span> db<span class="token operator">|</span> <span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token identifier"><span class="token punctuation">`</span>0728db<span class="token punctuation">`</span></span> <span class="token comment">/*!40100 DEFAULT CHARACTER SET latin1 */</span><span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------+-------------------------------------------------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">alter</span> <span class="token keyword">database</span> <span class="token number">0728</span> db <span class="token keyword">charset</span> utf8<span class="token punctuation">;</span> <span class="token comment">#修改数据库的字符编码为utf8</span>Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">show</span> <span class="token keyword">create</span> <span class="token keyword">database</span> <span class="token number">0728</span> db<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------+-----------------------------------------------------------------+</span><span class="token operator">|</span><span class="token keyword">Database</span><span class="token operator">|</span> <span class="token keyword">Create</span> <span class="token keyword">Database</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+-----------------------------------------------------------------+</span><span class="token operator">|</span> <span class="token number">0728</span> db <span class="token operator">|</span> <span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token identifier"><span class="token punctuation">`</span>0728db<span class="token punctuation">`</span></span> <span class="token comment">/*!40100 DEFAULT CHARACTER SET utf8 */</span><span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+-----------------------------------------------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本的SELECT语句</title>
      <link href="/2022/07/17/di-03-zhang-ji-ben-de-select-yu-ju/"/>
      <url>/2022/07/17/di-03-zhang-ji-ben-de-select-yu-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="第03章-基本的SELECT语句"><a href="#第03章-基本的SELECT语句" class="headerlink" title="第03章_基本的SELECT语句"></a>第03章_基本的SELECT语句</h1><h2 id="1-SQL概述"><a href="#1-SQL概述" class="headerlink" title="1. SQL概述"></a>1. SQL概述</h2><hr><h3 id="1-1-SQL背景知识"><a href="#1-1-SQL背景知识" class="headerlink" title="1. 1 SQL背景知识"></a>1. 1 SQL背景知识</h3><ul><li>1946 年，世界上第一台电脑诞生，如今，借由这台电脑发展起来的互联网已经自成江湖。在这几十年里，无数的技术、产业在这片江湖里沉浮，有的方兴未艾，有的已经几幕兴衰。但在这片浩荡的波动里，有一门技术从未消失，甚至“老当益壮”，那就是 SQL。<ul><li>45 年前，也就是 1974 年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语言，<code>SQL 的半衰期可以说是非常长</code>了。</li></ul></li><li>不论是前端工程师，还是后端算法工程师，都一定会和数据打交道，都需要了解如何又快又准确地提取自己想要的数据。更别提数据分析师了，他们的工作就是和数据打交道，整理不同的报告，以便指导业务决策。</li><li>SQL（Structured Query Language，结构化查询语言）是使用关系模型的数据库应用语言，<code>与数据直接打交道</code>，由<code>IBM</code>上世纪 70 年代开发出来。后由美国国家标准局（ANSI）开始着手制定SQL标准，先后有<code>SQL- 86</code> ，<code>SQL- 89</code> ，<code>SQL- 92</code> ，<code>SQL- 99</code> 等标准。<ul><li>SQL 有两个重要的标准，分别是 SQL92 和 SQL99，它们分别代表了 92 年和 99 年颁布的 SQL 标准，我们今天使用的 SQL 语言依然遵循这些标准。</li></ul></li><li>不同的数据库生产厂商都支持SQL语句，但都有特有内容。</li></ul><p><img src="/../pic/%E7%AC%AC03%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%9A%84SELECT%E8%AF%AD%E5%8F%A5/1649480531430.png" alt="1649480531430"></p><h3 id="1-2-SQL语言排行榜"><a href="#1-2-SQL语言排行榜" class="headerlink" title="1. 2 SQL语言排行榜"></a>1. 2 SQL语言排行榜</h3><p>自从 SQL 加入了 TIOBE 编程语言排行榜，就一直保持在 Top 10。</p><p><img src="/../pic/%E7%AC%AC03%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%9A%84SELECT%E8%AF%AD%E5%8F%A5/1649480552889.png" alt="1649480552889"></p><h3 id="1-3-SQL-分类"><a href="#1-3-SQL-分类" class="headerlink" title="1. 3 SQL 分类"></a>1. 3 SQL 分类</h3><p>SQL语言在功能上主要分为如下 3 大类：</p><ul><li><strong>DDL（Data Definition Languages、数据定义语言）</strong> ，这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。<ul><li>主要的语句关键字包括<code>CREATE</code>、<code>DROP</code>、<code>ALTER</code>等。</li></ul></li><li><strong>DML（Data Manipulation Language、数据操作语言）</strong> ，用于添加、删除、更新和查询数据库记录，并检查数据完整性。<ul><li>主要的语句关键字包括<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>、<code>SELECT</code>等。</li><li><strong>SELECT是SQL语言的基础，最为重要。</strong></li></ul></li><li><code>DCL（Data Control Language、数据控制语言）</code> ，用于定义数据库、表、字段、用户的访问权限和安全级别。<ul><li>主要的语句关键字包括<code>GRANT</code>、<code>REVOKE</code>、<code>COMMIT</code>、<code>ROLLBACK</code>、<code>SAVEPOINT</code>等。</li></ul></li></ul><blockquote><p>因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。还有单独将<code>COMMIT</code>、<code>ROLLBACK</code> 取出来称为TCL （Transaction Control Language，事务控制语言）。</p></blockquote><hr><h2 id="2-SQL语言的规则与规范"><a href="#2-SQL语言的规则与规范" class="headerlink" title="2. SQL语言的规则与规范"></a>2. SQL语言的规则与规范</h2><hr><h3 id="2-1-基本规则"><a href="#2-1-基本规则" class="headerlink" title="2. 1 基本规则"></a>2. 1 基本规则</h3><ul><li>SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进</li><li>每条命令以 ; 或 \g 或 \G 结束</li><li>关键字不能被缩写也不能分行</li><li>关于标点符号<ul><li>必须保证所有的()、单引号、双引号是成对结束的</li><li>必须使用英文状态下的半角输入方式</li><li>字符串型和日期时间类型的数据可以使用单引号（’ ‘）表示</li><li>列的别名，尽量使用双引号（” “），而且不建议省略as</li></ul></li></ul><h3 id="2-2-SQL大小写规范-（建议遵守）"><a href="#2-2-SQL大小写规范-（建议遵守）" class="headerlink" title="2. 2 SQL大小写规范 （建议遵守）"></a>2. 2 SQL大小写规范 （建议遵守）</h3><ul><li><strong>MySQL 在 Windows 环境下是大小写不敏感的</strong></li><li>MySQL 在 Linux 环境下是大小写敏感的<ul><li>数据库名、表名、表的别名、变量名是严格区分大小写的</li><li>关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。</li></ul></li><li>推荐采用统一的书写规范：<ul><li>数据库名、表名、表别名、字段名、字段别名等都小写</li><li>SQL 关键字、函数名、绑定变量等都大写</li></ul></li></ul><h3 id="2-3-注-释"><a href="#2-3-注-释" class="headerlink" title="2. 3 注 释"></a>2. 3 注 释</h3><p>可以使用如下格式的注释结构</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">单行注释：<span class="token comment">#注释文字(MySQL特有的方式)</span>单行注释：<span class="token comment">-- 注释文字(--后面必须包含一个空格。)</span>多行注释：<span class="token comment">/* 注释文字 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-4-命名规则（暂时了解）"><a href="#2-4-命名规则（暂时了解）" class="headerlink" title="2. 4 命名规则（暂时了解）"></a>2. 4 命名规则（暂时了解）</h3><ul><li>数据库、表名不得超过 30 个字符，变量名限制为 29 个</li><li>必须只能包含 A–Z, a–z, 0–9, _共 63 个字符</li><li>数据库名、表名、字段名等对象名中间不要包含空格</li><li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li><li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用&#96;（着重号）引起来</li><li>保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li></ul><p>举例：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#以下两句是一样的，不区分大小写show databases;SHOW DATABASES;#创建表格#create table student info(...); #表名错误，因为表名有空格create table student_info(...);#其中order使用&#96;&#96;飘号，因为order和系统关键字或系统函数名等预定义标识符重名了CREATE TABLE &#96;order&#96;(id INT,lname VARCHAR( 20 ));select id as &quot;编号&quot;, &#96;name&#96; as &quot;姓名&quot; from t_stu; #起别名时，as都可以省略select id as 编号, &#96;name&#96; as 姓名 from t_stu; #如果字段别名中没有空格，那么可以省略&quot;&quot;select id as 编 号, &#96;name&#96; as 姓 名 from t_stu; #错误，如果字段别名中有空格，那么不能省略&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-数据导入指令"><a href="#2-5-数据导入指令" class="headerlink" title="2. 5 数据导入指令"></a>2. 5 数据导入指令</h3><p>在命令行客户端登录mysql，使用source指令导入</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; source d:\mysqldb.sqlmysql&gt; desc employees;+----------------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------------+-------------+------+-----+---------+-------+| employee_id | int( 6 ) | NO | PRI | 0 | || first_name | varchar( 20 ) | YES | | NULL | || last_name | varchar( 25 ) | NO | | NULL | || email | varchar( 25 ) | NO | UNI | NULL | || phone_number | varchar( 20 ) | YES | | NULL | || hire_date | date | NO | | NULL | || job_id | varchar( 10 ) | NO | MUL | NULL | || salary | double( 8 , 2 ) | YES | | NULL | || commission_pct | double( 2 , 2 ) | YES | | NULL | || manager_id | int( 6 ) | YES | MUL | NULL | || department_id | int( 4 ) | YES | MUL | NULL | |+----------------+-------------+------+-----+---------+-------+11 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="3-基本的SELECT语句"><a href="#3-基本的SELECT语句" class="headerlink" title="3. 基本的SELECT语句"></a>3. 基本的SELECT语句</h2><hr><h3 id="3-0-SELECT…"><a href="#3-0-SELECT…" class="headerlink" title="3. 0 SELECT…"></a>3. 0 SELECT…</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token punctuation">;</span> <span class="token comment">#没有任何子句</span><span class="token keyword">SELECT</span> <span class="token number">9</span> <span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">#没有任何子句</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-1-SELECT-…-FROM"><a href="#3-1-SELECT-…-FROM" class="headerlink" title="3. 1 SELECT … FROM"></a>3. 1 SELECT … FROM</h3><ul><li><p>语法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> 标识选择哪些列<span class="token keyword">FROM</span> 标识从哪个表中选择<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>选择全部列：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> departments<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p><img src="/../pic/%E7%AC%AC03%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%9A%84SELECT%E8%AF%AD%E5%8F%A5/1649481543665.png" alt="1649481543665"></p><blockquote><p>一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。</p><p>在生产环境下，不推荐你直接使用SELECT *进行查询。</p></blockquote><ul><li><p>选择特定的列：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> department_id<span class="token punctuation">,</span> location_id<span class="token keyword">FROM</span> departments<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC03%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%9A%84SELECT%E8%AF%AD%E5%8F%A5/1649481593581.png" alt="1649481593581"></p></li></ul><blockquote><p>MySQL中的SQL语句是不区分大小写的，因此SELECT和select的作用是相同的，但是，许多开发人员习惯将关键字大写、数据列和表名小写，读者也应该养成一个良好的编程习惯，这样写出来的代码更容易阅读和维护。</p></blockquote><h3 id="3-2-列的别名"><a href="#3-2-列的别名" class="headerlink" title="3. 2 列的别名"></a>3. 2 列的别名</h3><ul><li>重命名一个列</li><li>便于计算</li><li>紧跟列名，也可以 在列名和别名之间加入关键字AS，别名使用双引号 ，以便在别名中包含空格或特殊的字符并区分大小写。</li><li>AS 可以省略</li><li>建议别名简短，见名知意</li><li>举例</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> last_name <span class="token keyword">AS</span> name<span class="token punctuation">,</span> commission_pct comm<span class="token keyword">FROM</span> employees<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC03%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%9A%84SELECT%E8%AF%AD%E5%8F%A5/1649481658412.png" alt="1649481658412"></p><p><img src="/../pic/%E7%AC%AC03%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%9A%84SELECT%E8%AF%AD%E5%8F%A5/1649481677528.png" alt="1649481677528"></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> last_name <span class="token string">"Name"</span><span class="token punctuation">,</span> salary<span class="token operator">*</span> <span class="token number">12</span> <span class="token string">"Annual Salary"</span><span class="token keyword">FROM</span> employees<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC03%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%9A%84SELECT%E8%AF%AD%E5%8F%A5/1649481740418.png" alt="1649481740418"></p><h3 id="3-3-去除重复行"><a href="#3-3-去除重复行" class="headerlink" title="3. 3 去除重复行"></a>3. 3 去除重复行</h3><p>默认情况下，查询会返回全部行，包括重复行。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> department_id<span class="token keyword">FROM</span> employees<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC03%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%9A%84SELECT%E8%AF%AD%E5%8F%A5/1649481814105.png" alt="1649481814105"></p><p><strong>在SELECT语句中使用关键字DISTINCT去除重复行</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> department_id<span class="token keyword">FROM</span> employees<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC03%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%9A%84SELECT%E8%AF%AD%E5%8F%A5/1649481902475.png" alt="1649481902475"></p><p>针对于：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> department_id<span class="token punctuation">,</span>salary<span class="token keyword">FROM</span> employees<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里有两点需要注意：</p><ol><li>DISTINCT 需要放到所有列名的前面，如果写成<code>SELECT salary, DISTINCT department_id FROM employees</code>会报错。</li><li>DISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 74 条，因为这 74 个部门id不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门（department_id），只需要写<code>DISTINCT department_id</code>即可，后面不需要再加其他的列名了。</li></ol><h3 id="3-4-空值参与运算"><a href="#3-4-空值参与运算" class="headerlink" title="3.4 空值参与运算"></a>3.4 空值参与运算</h3><ul><li><p>所有运算符或列值遇到null值，运算的结果都为null</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>salary<span class="token punctuation">,</span>commission_pct<span class="token punctuation">,</span><span class="token number">12</span> <span class="token operator">*</span> salary <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token number">1</span> <span class="token operator">+</span> commission_pct<span class="token punctuation">)</span> <span class="token string">"annual_sal"</span><span class="token keyword">FROM</span> employees<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>这里你一定要注意，在 MySQL 里面， 空值不等于空字符串。一个空字符串的长度是 0 ，而一个空值的长度是空。而且，在 MySQL 里面，空值是占用空间的。</p><h3 id="3-5-着重号"><a href="#3-5-着重号" class="headerlink" title="3. 5 着重号"></a>3. 5 着重号</h3><ul><li><p>错误的</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">ORDER</span><span class="token punctuation">;</span>ERROR <span class="token number">1064</span> <span class="token punctuation">(</span> <span class="token number">42000</span> <span class="token punctuation">)</span>: You have an error <span class="token operator">in</span> your <span class="token keyword">SQL</span> syntax<span class="token punctuation">;</span> <span class="token keyword">check</span> the manual thatcorresponds <span class="token keyword">to</span> your MySQL server version <span class="token keyword">for</span> the <span class="token keyword">right</span> syntax <span class="token keyword">to</span> <span class="token keyword">use</span> near <span class="token string">'ORDER'</span> atline <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>正确的</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>ORDER<span class="token punctuation">`</span></span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----------+------------+</span><span class="token operator">|</span> order_id <span class="token operator">|</span> order_name <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------+------------+</span><span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> shkstart <span class="token operator">|</span><span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> tomcat <span class="token operator">|</span><span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> dubbo <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------+------------+</span><span class="token number">3</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>order<span class="token punctuation">`</span></span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----------+------------+</span><span class="token operator">|</span> order_id <span class="token operator">|</span> order_name <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------+------------+</span><span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> shkstart <span class="token operator">|</span><span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> tomcat <span class="token operator">|</span><span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> dubbo <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------+------------+</span><span class="token number">3</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>结论<br>我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在SQL语句中使用一对&#96;&#96;（着重号）引起来。</p></li></ul><h3 id="3-6-查询常数"><a href="#3-6-查询常数" class="headerlink" title="3. 6 查询常数"></a>3. 6 查询常数</h3><p>SELECT 查询还可以对常数进行查询。对的，就是在 SELECT 查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的。</p><p>你可能会问为什么我们还要对常数进行查询呢？</p><p>SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。</p><p>比如说，我们想对 employees 数据表中的员工姓名进行查询，同时增加一列字段corporation，这个字段固定值为“尚硅谷”，可以这样写：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token string">'尚硅谷'</span> <span class="token keyword">as</span> corporation<span class="token punctuation">,</span> last_name <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="4-显示表结构"><a href="#4-显示表结构" class="headerlink" title="4. 显示表结构"></a>4. 显示表结构</h2><hr><p>使用DESCRIBE 或 DESC 命令，表示表结构。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DESCRIBE</span> employees<span class="token punctuation">;</span>或<span class="token keyword">DESC</span> employees<span class="token punctuation">;</span>mysql<span class="token operator">></span> <span class="token keyword">desc</span> employees<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----------------+-------------+------+-----+---------+-------+</span><span class="token operator">|</span> Field <span class="token operator">|</span> <span class="token keyword">Type</span> <span class="token operator">|</span> <span class="token boolean">Null</span> <span class="token operator">|</span> <span class="token keyword">Key</span> <span class="token operator">|</span> <span class="token keyword">Default</span> <span class="token operator">|</span> Extra <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------+-------------+------+-----+---------+-------+</span><span class="token operator">|</span> employee_id <span class="token operator">|</span> <span class="token keyword">int</span><span class="token punctuation">(</span> <span class="token number">6</span> <span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token keyword">NO</span> <span class="token operator">|</span> PRI <span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">|</span> first_name <span class="token operator">|</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span> <span class="token number">20</span> <span class="token punctuation">)</span> <span class="token operator">|</span> YES <span class="token operator">|</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">|</span> last_name <span class="token operator">|</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span> <span class="token number">25</span> <span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token keyword">NO</span> <span class="token operator">|</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">|</span> email <span class="token operator">|</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span> <span class="token number">25</span> <span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token keyword">NO</span> <span class="token operator">|</span> UNI <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">|</span> phone_number <span class="token operator">|</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span> <span class="token number">20</span> <span class="token punctuation">)</span> <span class="token operator">|</span> YES <span class="token operator">|</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">|</span> hire_date <span class="token operator">|</span> <span class="token keyword">date</span> <span class="token operator">|</span> <span class="token keyword">NO</span> <span class="token operator">|</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">|</span> job_id <span class="token operator">|</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span> <span class="token number">10</span> <span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token keyword">NO</span> <span class="token operator">|</span> MUL <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">|</span> salary <span class="token operator">|</span> <span class="token keyword">double</span><span class="token punctuation">(</span> <span class="token number">8</span> <span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token operator">|</span> YES <span class="token operator">|</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">|</span> commission_pct <span class="token operator">|</span> <span class="token keyword">double</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token operator">|</span> YES <span class="token operator">|</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">|</span> manager_id <span class="token operator">|</span> <span class="token keyword">int</span><span class="token punctuation">(</span> <span class="token number">6</span> <span class="token punctuation">)</span> <span class="token operator">|</span> YES <span class="token operator">|</span> MUL <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">|</span> department_id <span class="token operator">|</span> <span class="token keyword">int</span><span class="token punctuation">(</span> <span class="token number">4</span> <span class="token punctuation">)</span> <span class="token operator">|</span> YES <span class="token operator">|</span> MUL <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------+-------------+------+-----+---------+-------+</span><span class="token number">11</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，各个字段的含义分别解释如下：</p><ul><li>Field：表示字段名称。</li><li>Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。</li><li>Null：表示该列是否可以存储NULL值。</li><li>Key：表示该列是否已编制索引。PRI表示该列是表主键的一部分；UNI表示该列是UNIQUE索引的一部分；MUL表示在列中某个给定值允许出现多次。</li><li>Default：表示该列是否有默认值，如果有，那么值是多少。</li><li>Extra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。</li></ul><hr><h2 id="5-过滤数据"><a href="#5-过滤数据" class="headerlink" title="5. 过滤数据"></a>5. 过滤数据</h2><hr><ul><li><p>背景：<br><img src="/../pic/%E7%AC%AC03%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%9A%84SELECT%E8%AF%AD%E5%8F%A5/1649482409823.png" alt="1649482409823"></p></li><li><p>语法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> 字段<span class="token number">1</span><span class="token punctuation">,</span>字段 <span class="token number">2</span><span class="token keyword">FROM</span> 表名<span class="token keyword">WHERE</span> 过滤条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>使用WHERE 子句，将不满足条件的行过滤掉</li><li><strong>WHERE子句紧随 FROM子句</strong></li></ul></li><li><p>举例</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">xSELECT employee_id<span class="token punctuation">,</span> last_name<span class="token punctuation">,</span> job_id<span class="token punctuation">,</span> department_idFROM employeesWHERE department_id <span class="token operator">=</span> <span class="token number">90</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC03%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%9A%84SELECT%E8%AF%AD%E5%8F%A5/1649482509162.png" alt="1649482509162"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL运算符</title>
      <link href="/2022/07/17/di-04-zhang-yun-suan-fu/"/>
      <url>/2022/07/17/di-04-zhang-yun-suan-fu/</url>
      
        <content type="html"><![CDATA[<h1 id="第04章-运算符"><a href="#第04章-运算符" class="headerlink" title="第04章_运算符"></a>第04章_运算符</h1><h2 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h2><hr><p>算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（*）、除（&#x2F;）和取模（%）运算。</p><p><img src="/../pic/%E7%AC%AC04%E7%AB%A0_%E8%BF%90%E7%AE%97%E7%AC%A6/1649482983589.png" alt="1649482983589"></p><h3 id="1-1加法与减法运算符"><a href="#1-1加法与减法运算符" class="headerlink" title="1.1加法与减法运算符"></a>1.1加法与减法运算符</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token number">100</span> <span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">0</span> <span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">-</span> <span class="token number">0</span> <span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">50</span> <span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">50</span> <span class="token operator">-</span> <span class="token number">30</span> <span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">35.5</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">-</span> <span class="token number">35.</span><span class="token keyword">FROM</span> dual<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-----+---------+---------+----------+--------------+------------+------------+</span><span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">-</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">50</span> <span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">50</span> <span class="token operator">-</span> <span class="token number">30</span> <span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">35.5</span> <span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">-</span> <span class="token number">35.5</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----+---------+---------+----------+--------------+------------+------------+</span><span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">|</span> <span class="token number">150</span> <span class="token operator">|</span> <span class="token number">120</span> <span class="token operator">|</span>  <span class="token number">135.5</span> <span class="token operator">|</span> <span class="token number">64.5</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----+---------+---------+----------+--------------+------------+------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由运算结果可以得出如下结论：</p><blockquote><ul><li>一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；</li><li>一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；</li><li>加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；</li><li>在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按 0 计算。（补充：MySQL中字符串拼接要使用字符串函数CONCAT()实现）</li></ul></blockquote><h3 id="1-2乘法与除法运算符"><a href="#1-2乘法与除法运算符" class="headerlink" title="1.2乘法与除法运算符"></a>1.2乘法与除法运算符</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token number">100</span> <span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">*</span> <span class="token number">1</span> <span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">*</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">/</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">5</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">DIV</span> <span class="token number">0</span> <span class="token keyword">FROM</span> dual<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-----+---------+-----------+-----------+---------+-----------------+---------+-----------+</span><span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">*</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">*</span> <span class="token number">1.0</span> <span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">/</span> <span class="token number">1.0</span> <span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">5</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">/</span><span class="token number">3</span> <span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">DIV</span> <span class="token number">0</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----+---------+-----------+-----------+---------+-----------------+---------+-----------+</span><span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">|</span> <span class="token number">100</span> <span class="token operator">|</span> <span class="token number">100.0</span> <span class="token operator">|</span>  <span class="token number">100.0000</span> <span class="token operator">|</span> <span class="token number">50.0000</span> <span class="token operator">|</span>  <span class="token number">105.0000</span> <span class="token operator">|</span> <span class="token number">33.3333</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----+---------+-----------+-----------+---------+-----------------+---------+-----------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span class="token comment">#计算出员工的年基本工资</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>salary<span class="token punctuation">,</span>salary <span class="token operator">*</span> <span class="token number">12</span> annual_sal<span class="token keyword">FROM</span> employees<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由运算结果可以得出如下结论：</p><blockquote><ul><li>一个数乘以整数 1 和除以整数 1 后仍得原数；</li><li>一个数乘以浮点数 1 和除以浮点数 1 后变成浮点数，数值与原数相等；</li><li>一个数除以整数后，不管是否能除尽，结果都为一个浮点数；</li><li>一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后 4 位；</li><li>乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。</li><li>在数学运算中， 0 不能用作除数，在MySQL中，一个数除以 0 为NULL。</li></ul></blockquote><h3 id="1-3求模（求余）运算符"><a href="#1-3求模（求余）运算符" class="headerlink" title="1.3求模（求余）运算符"></a>1.3求模（求余）运算符</h3><p>将t22表中的字段 i 对 3 和 5 进行求模（求余）运算。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token number">12</span> <span class="token operator">%</span> <span class="token number">3</span> <span class="token punctuation">,</span> <span class="token number">12</span> MOD <span class="token number">5</span> <span class="token keyword">FROM</span> dual<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------+----------+</span><span class="token operator">|</span> <span class="token number">12</span> <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">12</span> MOD <span class="token number">5</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+----------+</span><span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+----------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span class="token comment">#筛选出employee_id是偶数的员工</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees<span class="token keyword">WHERE</span> employee_id MOD <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到， 100 对 3 求模后的结果为 3 ，对 5 求模后的结果为 0 。</p><hr><h2 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a>2. 比较运算符</h2><hr><p>比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回 1 ，比较的结果为假则返回 0 ，其他情况则返回NULL。</p><p>比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。<br><img src="/../pic/%E7%AC%AC04%E7%AB%A0_%E8%BF%90%E7%AE%97%E7%AC%A6/1649483597988.png" alt="1649483597988"></p><h3 id="2-1-等号运算符"><a href="#2-1-等号运算符" class="headerlink" title="2.1 等号运算符"></a>2.1 等号运算符</h3><ul><li>等号运算符（&#x3D;）判断等号两边的值、字符串或表达式是否相等，如果相等则返回 1 ，不相等则返回0 。</li><li>在使用等号运算符时，遵循如下规则：<ul><li>如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。</li><li>如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。</li><li>如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。</li><li>如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。</li></ul></li><li>对比：SQL中赋值符号使用 :&#x3D;</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">,</span> <span class="token string">'a'</span> <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">3</span> <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">6</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">''</span> <span class="token operator">=</span> <span class="token boolean">NULL</span> <span class="token punctuation">,</span> <span class="token boolean">NULL</span> <span class="token operator">=</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-------+---------+-------+-----------+-------------------+-----------+-------------+</span><span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token string">'1'</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token string">'a'</span> <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">|</span> <span class="token punctuation">(</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">3</span> <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">6</span> <span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token string">''</span> <span class="token operator">=</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">=</span> <span class="token boolean">NULL</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-------+---------+-------+-----------+-------------------+-----------+-------------+</span><span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span>  <span class="token boolean">NULL</span> <span class="token operator">|</span>  <span class="token boolean">NULL</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-------+---------+-------+-----------+-------------------+-----------+-------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">,</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token string">'abc'</span> <span class="token keyword">FROM</span> dual<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-------+-----------+-----------+</span><span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token string">'abc'</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token string">'abc'</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-------+-----------+-----------+</span><span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-------+-----------+-----------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token keyword">warnings</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span class="token comment">#查询salary=10000，注意在Java中比较是==</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>salary <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> salary <span class="token operator">=</span> <span class="token number">10000</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-安全等于运算符"><a href="#2-2-安全等于运算符" class="headerlink" title="2.2 安全等于运算符"></a>2.2 安全等于运算符</h3><p>安全等于运算符（&lt;&#x3D;&gt;）与等于运算符（&#x3D;）的作用是相似的，<code>唯一的区别</code>是‘&lt;&#x3D;&gt;’可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为 1 ，而不为NULL；当一个操作数为NULL时，其返回值为 0 ，而不为NULL。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token operator">&lt;=></span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">&lt;=></span> <span class="token number">0</span> <span class="token punctuation">,</span> <span class="token string">'a'</span> <span class="token operator">&lt;=></span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">3</span> <span class="token punctuation">)</span> <span class="token operator">&lt;=></span> <span class="token punctuation">(</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">6</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">''</span> <span class="token operator">&lt;=></span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token boolean">NULL</span> <span class="token operator">&lt;=></span> <span class="token boolean">NULL</span> <span class="token keyword">FROM</span> dual<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-----------+---------+-------------+---------------------+-------------+---------------+</span><span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">&lt;=></span> <span class="token string">'1'</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">&lt;=></span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token string">'a'</span> <span class="token operator">&lt;=></span> <span class="token string">'a'</span> <span class="token operator">|</span> <span class="token punctuation">(</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">3</span> <span class="token punctuation">)</span> <span class="token operator">&lt;=></span> <span class="token punctuation">(</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">6</span> <span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token string">''</span> <span class="token operator">&lt;=></span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">&lt;=></span> <span class="token boolean">NULL</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------+---------+-------------+---------------------+-------------+---------------+</span><span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------+---------+-------------+---------------------+-------------+---------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span class="token comment">#查询commission_pct等于0.</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>commission_pct <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> commission_pct <span class="token operator">=</span> <span class="token number">0.40</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>commission_pct <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> commission_pct <span class="token operator">&lt;=></span> <span class="token number">0.40</span><span class="token punctuation">;</span><span class="token comment">#如果把0.40改成 NULL 呢？</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，使用安全等于运算符时，两边的操作数的值都为NULL时，返回的结果为 1 而不是NULL，其他返回结果与等于运算符相同。</p><h3 id="2-3-不等于运算符"><a href="#2-3-不等于运算符" class="headerlink" title="2.3 不等于运算符"></a>2.3 不等于运算符</h3><p>不等于运算符（&lt;&gt;和!&#x3D;）用于判断两边的数字、字符串或者表达式的值是否不相等，如果不相等则返回 1 ，相等则返回 0 。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL，或两边都为NULL，则结果为NULL。 SQL语句示例如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token operator">&lt;></span> <span class="token number">1</span> <span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">!=</span> <span class="token number">2</span> <span class="token punctuation">,</span> <span class="token string">'a'</span> <span class="token operator">!=</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token punctuation">)</span> <span class="token operator">&lt;></span> <span class="token punctuation">(</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">6</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'a'</span> <span class="token operator">!=</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span> <span class="token operator">&lt;></span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------+--------+------------+----------------+-------------+--------------+</span><span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">&lt;></span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">!=</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token string">'a'</span> <span class="token operator">!=</span> <span class="token string">'b'</span> <span class="token operator">|</span> <span class="token punctuation">(</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token punctuation">)</span> <span class="token operator">&lt;></span> <span class="token punctuation">(</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">6</span> <span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token string">'a'</span> <span class="token operator">!=</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">&lt;></span> <span class="token boolean">NULL</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+--------+------------+----------------+-------------+--------------+</span><span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------+--------+------------+----------------+-------------+--------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，还有非符号类型的运算符：<br><img src="/../pic/%E7%AC%AC04%E7%AB%A0_%E8%BF%90%E7%AE%97%E7%AC%A6/1649483964872.png" alt="1649483964872"><br><img src="/../pic/%E7%AC%AC04%E7%AB%A0_%E8%BF%90%E7%AE%97%E7%AC%A6/1649483982335.png" alt="1649483982335"></p><h3 id="2-4-空运算符"><a href="#2-4-空运算符" class="headerlink" title="2.4 空运算符"></a>2.4 空运算符</h3><p>空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回 1 ，否则返回0 。 SQL语句示例如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span> <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> ISNULL<span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ISNULL<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------+--------------+-------------+-----------+</span><span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">IS</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> ISNULL<span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">)</span> <span class="token operator">|</span> ISNULL<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">IS</span> <span class="token boolean">NULL</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+--------------+-------------+-----------+</span><span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------+--------------+-------------+-----------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span class="token comment">#查询commission_pct等于NULL。比较如下的四种写法</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>commission_pct <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> commission_pct <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>commission_pct <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> commission_pct <span class="token operator">&lt;=></span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>commission_pct <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> ISNULL<span class="token punctuation">(</span>commission_pct<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>commission_pct <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> commission_pct <span class="token operator">=</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span> manager_id<span class="token keyword">FROM</span> employees<span class="token keyword">WHERE</span> manager_id <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-非空运算符"><a href="#2-5-非空运算符" class="headerlink" title="2.5 非空运算符"></a>2.5 非空运算符</h3><p>非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回 1 ，否则返回 0 。 SQL语句示例如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token string">'a'</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">------------------+-----------------+---------------+</span><span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token string">'a'</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------+-----------------+---------------+</span><span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------+-----------------+---------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span><span class="token comment">#查询commission_pct不等于NULL</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>commission_pct <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> commission_pct <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>commission_pct <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> <span class="token operator">NOT</span> commission_pct <span class="token operator">&lt;=></span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>commission_pct <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> <span class="token operator">NOT</span> ISNULL<span class="token punctuation">(</span>commission_pct<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-最小值运算符"><a href="#2-6-最小值运算符" class="headerlink" title="2.6 最小值运算符"></a>2.6 最小值运算符</h3><p>语法格式为：LEAST(值 1 ，值 2 ，…，值n)。其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; SELECT LEAST ( 1 , 0 , 2 ), LEAST(&#39;b&#39;,&#39;a&#39;,&#39;c&#39;), LEAST( 1 ,NULL, 2 );+---------------+--------------------+-----------------+| LEAST ( 1 , 0 , 2 ) | LEAST(&#39;b&#39;,&#39;a&#39;,&#39;c&#39;) | LEAST( 1 ,NULL, 2 ) |+---------------+--------------------+-----------------+| 0 | a |  NULL |+---------------+--------------------+-----------------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由结果可以看到，当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p><h3 id="2-7-最大值运算符"><a href="#2-7-最大值运算符" class="headerlink" title="2.7 最大值运算符"></a>2.7 最大值运算符</h3><p>语法格式为：GREATEST(值 1 ，值 2 ，…，值n)。其中，n表示参数列表中有n个值。当有两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; SELECT GREATEST( 1 , 0 , 2 ), GREATEST(&#39;b&#39;,&#39;a&#39;,&#39;c&#39;), GREATEST( 1 ,NULL, 2 );+-----------------+-----------------------+--------------------+| GREATEST( 1 , 0 , 2 ) | GREATEST(&#39;b&#39;,&#39;a&#39;,&#39;c&#39;) | GREATEST( 1 ,NULL, 2 ) |+-----------------+-----------------------+--------------------+| 2 | c | NULL |+-----------------+-----------------------+--------------------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由结果可以看到，当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时，返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p><h3 id="2-8-BETWEEN-AND运算符"><a href="#2-8-BETWEEN-AND运算符" class="headerlink" title="2.8 BETWEEN AND运算符"></a>2.8 BETWEEN AND运算符</h3><p>BETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND B，此时，当C大于或等于A，并且C小于或等于B时，结果为 1 ，否则结果为 0 。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT 1 BETWEEN 0 AND 1 , 10 BETWEEN 11 AND 12 , &#39;b&#39; BETWEEN &#39;a&#39; AND &#39;c&#39;;+-------------------+----------------------+-------------------------+| 1 BETWEEN 0 AND 1 | 10 BETWEEN 11 AND 12 | &#39;b&#39; BETWEEN &#39;a&#39; AND &#39;c&#39; |+-------------------+----------------------+-------------------------+| 1 | 0 | 1 |+-------------------+----------------------+-------------------------+1 row in set (0.00 sec)SELECT last_name, salaryFROM employeesWHERE salary BETWEEN 2500 AND 3500 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-9-IN运算符"><a href="#2-9-IN运算符" class="headerlink" title="2.9 IN运算符"></a>2.9 IN运算符</h3><p>IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回 1 ，否则返回 0 。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token string">'a'</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">IN</span> <span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'a'</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----------------------+------------+-------------------+--------------------+</span><span class="token operator">|</span> <span class="token string">'a'</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">IN</span> <span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token string">'a'</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------------+------------+-------------------+--------------------+</span><span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------------+------------+-------------------+--------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span> last_name<span class="token punctuation">,</span> salary<span class="token punctuation">,</span> manager_id<span class="token keyword">FROM</span> employees<span class="token keyword">WHERE</span> manager_id <span class="token operator">IN</span> <span class="token punctuation">(</span> <span class="token number">100</span> <span class="token punctuation">,</span> <span class="token number">101</span> <span class="token punctuation">,</span> <span class="token number">201</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-10-NOT-IN运算符"><a href="#2-10-NOT-IN运算符" class="headerlink" title="2.10 NOT IN运算符"></a>2.10 NOT IN运算符</h3><p>NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回 1 ，否则返回 0 。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token string">'a'</span> <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------------------+----------------+</span><span class="token operator">|</span> <span class="token string">'a'</span> <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------------------+----------------+</span><span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------------------+----------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-11-LIKE运算符"><a href="#2-11-LIKE运算符" class="headerlink" title="2.11 LIKE运算符"></a>2.11 LIKE运算符</h3><p>LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回 1 ，否则返回0 。如果给定的值或者匹配条件为NULL，则返回结果为NULL。</p><p>LIKE运算符通常使用如下通配符：</p><pre class="line-numbers language-none"><code class="language-none">“%”：匹配 0 个或多个字符。“_”：只能匹配一个字符。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>SQL语句示例如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span> <span class="token operator">LIKE</span> <span class="token string">'abc'</span><span class="token punctuation">,</span> <span class="token string">'abc'</span> <span class="token operator">LIKE</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-----------------+-----------------+</span><span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">LIKE</span> <span class="token string">'abc'</span> <span class="token operator">|</span> <span class="token string">'abc'</span> <span class="token operator">LIKE</span> <span class="token boolean">NULL</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------------+-----------------+</span><span class="token operator">|</span>  <span class="token boolean">NULL</span> <span class="token operator">|</span>  <span class="token boolean">NULL</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------------+-----------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span class="token keyword">SELECT</span> first_name<span class="token keyword">FROM</span> employees<span class="token keyword">WHERE</span> first_name <span class="token operator">LIKE</span> <span class="token string">'S%'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> last_name<span class="token keyword">FROM</span> employees<span class="token keyword">WHERE</span> last_name <span class="token operator">LIKE</span> <span class="token string">'_o%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ESCAPE</strong></p><ul><li><p>回避特殊符号的： 使用转义符 。例如：将[%]转为[$%]、[]转为[$]，然后再加上[ESCAPE‘$’]即可。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> job_id<span class="token keyword">FROM</span> jobs<span class="token keyword">WHERE</span> job_id <span class="token operator">LIKE</span> ‘IT\_<span class="token operator">%</span>‘<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>如果使用\表示转义，要省略ESCAPE。如果不是\，则要加上ESCAPE。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> job_id<span class="token keyword">FROM</span> jobs<span class="token keyword">WHERE</span> job_id <span class="token operator">LIKE</span> ‘IT$_<span class="token operator">%</span>‘ <span class="token keyword">escape</span> ‘$‘<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="2-12-REGEXP运算符"><a href="#2-12-REGEXP运算符" class="headerlink" title="2.12 REGEXP运算符"></a>2.12 REGEXP运算符</h3><p>REGEXP运算符用来匹配字符串，语法格式为：expr REGEXP 匹配条件。如果expr满足匹配条件，返回1 ；如果不满足，则返回 0 。若expr或匹配条件任意一个为NULL，则结果为NULL。</p><p>REGEXP运算符在进行匹配时，常用的有下面几种通配符：</p><pre class="line-numbers language-none"><code class="language-none">（ 1 ）‘^’匹配以该字符后面的字符开头的字符串。（ 2 ）‘$’匹配以该字符前面的字符结尾的字符串。（ 3 ）‘.’匹配任何一个单字符。（ 4 ）“[...]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。（ 5 ）‘*’匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“[0-9]*”匹配任何数量的数字，而“*”匹配任何数量的任何字符。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SQL语句示例如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token string">'shkstart'</span> <span class="token operator">REGEXP</span> <span class="token string">'^s'</span><span class="token punctuation">,</span> <span class="token string">'shkstart'</span> <span class="token operator">REGEXP</span> <span class="token string">'t$'</span><span class="token punctuation">,</span> <span class="token string">'shkstart'</span> <span class="token operator">REGEXP</span> <span class="token string">'hk'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">------------------------+------------------------+-------------------------+</span><span class="token operator">|</span> <span class="token string">'shkstart'</span> <span class="token operator">REGEXP</span> <span class="token string">'^s'</span> <span class="token operator">|</span> <span class="token string">'shkstart'</span> <span class="token operator">REGEXP</span> <span class="token string">'t$'</span> <span class="token operator">|</span> <span class="token string">'shkstart'</span> <span class="token operator">REGEXP</span> <span class="token string">'hk'</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------------+------------------------+-------------------------+</span><span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------------+------------------------+-------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token string">'atguigu'</span> <span class="token operator">REGEXP</span> <span class="token string">'gu.gu'</span><span class="token punctuation">,</span> <span class="token string">'atguigu'</span> <span class="token operator">REGEXP</span> <span class="token string">'[ab]'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------------------+-------------------------+</span><span class="token operator">|</span> <span class="token string">'atguigu'</span> <span class="token operator">REGEXP</span> <span class="token string">'gu.gu'</span> <span class="token operator">|</span> <span class="token string">'atguigu'</span> <span class="token operator">REGEXP</span> <span class="token string">'[ab]'</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------------------+-------------------------+</span><span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------------------+-------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3.逻辑运算符"></a>3.逻辑运算符</h2><hr><p>逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为 1 、 0 或者NULL。</p><p>MySQL中支持 4 种逻辑运算符如下：<br><img src="/../pic/%E7%AC%AC04%E7%AB%A0_%E8%BF%90%E7%AE%97%E7%AC%A6/1649484718411.png" alt="1649484718411"></p><h3 id="3-1-逻辑非运算符"><a href="#3-1-逻辑非运算符" class="headerlink" title="3.1 逻辑非运算符"></a>3.1 逻辑非运算符</h3><p>逻辑非（NOT或!）运算符表示当给定的值为 0 时返回 1 ；当给定的值为非 0 值时返回 0 ；当给定的值为NULL时，返回NULL。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT NOT 1 , NOT 0 , NOT( 1 + 1 ), NOT! 1 , NOT NULL;+-------+-------+----------+--------+----------+| NOT 1 | NOT 0 | NOT( 1 + 1 ) | NOT! 1 | NOT NULL |+-------+-------+----------+--------+----------+| 0 | 1 | 0 | 1 | NULL |+-------+-------+----------+--------+----------+1 row in set, 1 warning (0.00 sec)SELECT last_name, job_idFROM employeesWHERE job_id NOT IN (&#39;IT_PROG&#39;, &#39;ST_CLERK&#39;, &#39;SA_REP&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-逻辑与运算符"><a href="#3-2-逻辑与运算符" class="headerlink" title="3.2 逻辑与运算符"></a>3.2 逻辑与运算符</h3><p>逻辑与（AND或&amp;&amp;）运算符是当给定的所有值均为非 0 值，并且都不为NULL时，返回1 ；当给定的一个值或者多个值为 0 时则返回 0 ；否则返回NULL。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT 1 AND - 1 , 0 AND 1 , 0 AND NULL, 1 AND NULL;+----------+---------+------------+------------+| 1 AND - 1 | 0 AND 1 | 0 AND NULL | 1 AND NULL |+----------+---------+------------+------------+| 1 | 0 | 0 | NULL |+----------+---------+------------+------------+1 row in set (0.00 sec)SELECT employee_id, last_name, job_id, salaryFROM employeesWHERE salary &gt;&#x3D; 10000AND job_id LIKE &#39;%MAN%&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-逻辑或运算符"><a href="#3-3-逻辑或运算符" class="headerlink" title="3.3 逻辑或运算符"></a>3.3 逻辑或运算符</h3><p>逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非 0 值时，则返回 1 ，否则返回 0 ；当一个值为NULL，并且另一个值为非 0 值时，返回 1 ，否则返回NULL；当两个值都为NULL时，返回NULL。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT 1 OR - 1 , 1 OR 0 , 1 OR NULL, 0 || NULL, NULL || NULL;+---------+--------+-----------+-----------+--------------+| 1 OR - 1 | 1 OR 0 | 1 OR NULL | 0 || NULL | NULL || NULL |+---------+--------+-----------+-----------+--------------+| 1 | 1 | 1 |  NULL | NULL |+---------+--------+-----------+-----------+--------------+1 row in set, 2 warnings (0.00 sec)#查询基本薪资不在9000-12000之间的员工编号和基本薪资SELECT employee_id,salary FROM employeesWHERE NOT (salary &gt;&#x3D; 9000 AND salary &lt;&#x3D; 12000 );SELECT employee_id,salary FROM employeesWHERE salary &lt; 9000 OR salary &gt; 12000 ;SELECT employee_id,salary FROM employeesWHERE salary NOT BETWEEN 9000 AND 12000 ;SELECT employee_id, last_name, job_id, salaryFROM employeesWHERE salary &gt;&#x3D; 10000OR job_id LIKE &#39;%MAN%&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><p>OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合。</p></blockquote><h3 id="3-4-逻辑异或运算符"><a href="#3-4-逻辑异或运算符" class="headerlink" title="3.4 逻辑异或运算符"></a>3.4 逻辑异或运算符</h3><p>逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是 0 或者都不等于 0 时，则返回 0 ；如果一个值为 0 ，另一个值不为 0 时，则返回 1 。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT 1 XOR - 1 , 1 XOR 0 , 0 XOR 0 , 1 XOR NULL, 1 XOR 1 XOR 1 , 0 XOR 0 XOR 0 ;+----------+---------+---------+------------+---------------+---------------+| 1 XOR - 1 | 1 XOR 0 | 0 XOR 0 | 1 XOR NULL | 1 XOR 1 XOR 1 | 0 XOR 0 XOR 0 |+----------+---------+---------+------------+---------------+---------------+| 0 | 1 | 0 | NULL | 1 | 0 |+----------+---------+---------+------------+---------------+---------------+1 row in set (0.00 sec)select last_name,department_id,salaryfrom employeeswhere department_id in ( 10 , 20 ) XOR salary &gt; 8000 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a>4. 位运算符</h2><hr><p>位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，最后将计算结果从二进制变回十进制数。</p><p>MySQL支持的位运算符如下：<br><img src="/../pic/%E7%AC%AC04%E7%AB%A0_%E8%BF%90%E7%AE%97%E7%AC%A6/1649485117026.png" alt="1649485117026"></p><h3 id="4-1-按位与运算符"><a href="#4-1-按位与运算符" class="headerlink" title="4.1 按位与运算符"></a>4.1 按位与运算符</h3><p>按位与（&amp;）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二进制位的数值都为 1 时，则该位返回 1 ，否则返回 0 。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT 1 &amp; 10 , 20 &amp; 30 ;+--------+---------+| 1 &amp; 10 | 20 &amp; 30 |+--------+---------+| 0 | 20 |+--------+---------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1 的二进制数为 0001 ， 10 的二进制数为 1010 ，所以 1 &amp; 10 的结果为 0000 ，对应的十进制数为 0 。 20 的二进制数为 10100 ， 30 的二进制数为 11110 ，所以 20 &amp; 30 的结果为 10100 ，对应的十进制数为 20 。</p><h3 id="4-2-按位或运算符"><a href="#4-2-按位或运算符" class="headerlink" title="4.2 按位或运算符"></a>4.2 按位或运算符</h3><p>按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的二进制位的数值有一个或两个为 1 时，则该位返回 1 ，否则返回 0 。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT 1 | 10 , 20 | 30 ;+--------+---------+| 1 | 10 | 20 | 30 |+--------+---------+| 11 | 30 |+--------+---------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1 的二进制数为 0001 ， 10 的二进制数为 1010 ，所以 1 | 10 的结果为 1011 ，对应的十进制数为 11 。 20 的二进制数为 10100 ， 30 的二进制数为 11110 ，所以 20 | 30 的结果为 11110 ，对应的十进制数为 30 。</p><h3 id="4-3-按位异或运算符"><a href="#4-3-按位异或运算符" class="headerlink" title="4.3 按位异或运算符"></a>4.3 按位异或运算符</h3><p>按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值对应的二进制位的数值不同时，则该位返回 1 ，否则返回 0 。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT 1 ^ 10 , 20 ^ 30 ;+--------+---------+| 1 ^ 10 | 20 ^ 30 |+--------+---------+| 11 | 10 |+--------+---------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1 的二进制数为 0001 ， 10 的二进制数为 1010 ，所以 1 ^ 10 的结果为 1011 ，对应的十进制数为 11 。 20 的二进制数为 10100 ， 30 的二进制数为 11110 ，所以 20 ^ 30 的结果为 01010 ，对应的十进制数为 10 。</p><p>再举例：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT 12 &amp; 5 , 12 | 5 , 12 ^ 5 FROM DUAL;+--------+--------+--------+| 12 &amp; 5 | 12 | 5 | 12 ^ 5 |+--------+--------+--------+| 4 | 13 | 9 |+--------+--------+--------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC04%E7%AB%A0_%E8%BF%90%E7%AE%97%E7%AC%A6/1649485313457.png" alt="1649485313457"></p><h3 id="4-4-按位取反运算符"><a href="#4-4-按位取反运算符" class="headerlink" title="4.4 按位取反运算符"></a>4.4 按位取反运算符</h3><p>按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将 1 变为 0 ，将 0 变为 1 。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT 10 &amp; ~1;+---------+| 10 &amp; ~1 |+---------+| 10 |+---------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于按位取反（~）运算符的优先级高于按位与（&amp;）运算符的优先级，所以 10 &amp; ~ 1 ，首先，对数字 1 进行按位取反操作，结果除了最低位为 0 ，其他位都为 1 ，然后与 10 进行按位与操作，结果为 10 。</p><h3 id="4-5-按位右移运算符"><a href="#4-5-按位右移运算符" class="headerlink" title="4.5 按位右移运算符"></a>4.5 按位右移运算符</h3><p>按位右移（&gt;&gt;）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用 0 补齐。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT 1 &gt;&gt; 2 , 4 &gt;&gt; 2 ;+--------+--------+| 1 &gt;&gt; 2 | 4 &gt;&gt; 2 |+--------+--------+| 0 | 1 |+--------+--------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1 的二进制数为 0000 0001 ，右移 2 位为 0000 0000 ，对应的十进制数为 0 。 4 的二进制数为 0000 0100 ，右移 2位为 0000 0001 ，对应的十进制数为 1 。</p><h3 id="4-6-按位左移运算符"><a href="#4-6-按位左移运算符" class="headerlink" title="4.6 按位左移运算符"></a>4.6 按位左移运算符</h3><p>按位左移（&lt;&lt;）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用 0 补齐。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT 1 &lt;&lt; 2 , 4 &lt;&lt; 2 ;+--------+--------+| 1 &lt;&lt; 2 | 4 &lt;&lt; 2 |+--------+--------+| 4 | 16 |+--------+--------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1 的二进制数为 0000 0001 ，左移两位为 0000 0100 ，对应的十进制数为 4 。 4 的二进制数为 0000 0100 ，左移两位为 0001 0000 ，对应的十进制数为 16 。</p><hr><h2 id="5-运算符的优先级"><a href="#5-运算符的优先级" class="headerlink" title="5. 运算符的优先级"></a>5. 运算符的优先级</h2><hr><p><img src="/../pic/%E7%AC%AC04%E7%AB%A0_%E8%BF%90%E7%AE%97%E7%AC%A6/1649485461220.png" alt="1649485461220"></p><p>数字编号越大，优先级越高，优先级高的运算符先进行计算。可以看到，赋值运算符的优先级最低，使用“()”括起来的表达式的优先级最高。</p><hr><h2 id="6-拓展：使用正则表达式查询"><a href="#6-拓展：使用正则表达式查询" class="headerlink" title="6. 拓展：使用正则表达式查询"></a>6. 拓展：使用正则表达式查询</h2><hr><p>正则表达式通常被用来检索或替换那些符合某个模式的文本内容，根据指定的匹配模式匹配文本中符合要求的特殊字符串。例如，从一个文本文件中提取电话号码，查找一篇文章中重复的单词或者替换用户输入的某些敏感词语等，这些地方都可以使用正则表达式。正则表达式强大而且灵活，可以应用于非常复杂的查询。</p><p>MySQL中使用REGEXP关键字指定正则表达式的字符匹配模式。下表列出了REGEXP操作符中常用字符匹配列表。</p><p><img src="/../pic/%E7%AC%AC04%E7%AB%A0_%E8%BF%90%E7%AE%97%E7%AC%A6/1649485516739.png" alt="1649485516739"></p><h3 id="6-1-查询以特定字符或字符串开头的记录"><a href="#6-1-查询以特定字符或字符串开头的记录" class="headerlink" title="6.1 查询以特定字符或字符串开头的记录"></a>6.1 查询以特定字符或字符串开头的记录</h3><p>字符‘^’匹配以特定字符或者字符串开头的文本。</p><p>在fruits表中，查询f_name字段以字母‘b’开头的记录，SQL语句如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#39;^b&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-2-查询以特定字符或字符串结尾的记录"><a href="#6-2-查询以特定字符或字符串结尾的记录" class="headerlink" title="6.2 查询以特定字符或字符串结尾的记录"></a>6.2 查询以特定字符或字符串结尾的记录</h3><p>字符‘$’匹配以特定字符或者字符串结尾的文本。</p><p>在fruits表中，查询f_name字段以字母‘y’结尾的记录，SQL语句如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#39;y$&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-3-用符号”-”来替代字符串中的任意一个字符"><a href="#6-3-用符号”-”来替代字符串中的任意一个字符" class="headerlink" title="6.3 用符号”.”来替代字符串中的任意一个字符"></a>6.3 用符号”.”来替代字符串中的任意一个字符</h3><p>字符‘.’匹配任意一个字符。 在fruits表中，查询f_name字段值</p><p>包含字母‘a’与‘g’且两个字母之间只有一个字母的记录，SQL语句如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#39;a.g&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-4-使用”-”和”-”来匹配多个字符"><a href="#6-4-使用”-”和”-”来匹配多个字符" class="headerlink" title="6.4 使用”*”和”+”来匹配多个字符"></a>6.4 使用”*”和”+”来匹配多个字符</h3><p>星号‘*’匹配前面的字符任意多次，包括 0 次。加号‘+’匹配前面的字符至少一次。</p><p>在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’的记录，SQL语句如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#39;^ba*&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’至少一次的记录，SQL语句如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#39;^ba+&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-5-匹配指定字符串"><a href="#6-5-匹配指定字符串" class="headerlink" title="6.5 匹配指定字符串"></a>6.5 匹配指定字符串</h3><p>正则表达式可以匹配指定字符串，只要这个字符串在查询文本中即可，如要匹配多个字符串，多个字符串之间使用分隔符‘|’隔开。</p><p>在fruits表中，查询f_name字段值包含字符串“on”的记录，SQL语句如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#39;on&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在fruits表中，查询f_name字段值包含字符串“on”或者“ap”的记录，SQL语句如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#39;on|ap&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之前介绍过，LIKE运算符也可以匹配指定的字符串，但与REGEXP不同，LIKE匹配的字符串如果在文本中间出现，则找不到它，相应的行也不会返回。REGEXP在文本内进行匹配，如果被匹配的字符串在文本中出现，REGEXP将会找到它，相应的行也会被返回。对比结果如下所示。</p><p>在fruits表中，使用LIKE运算符查询f_name字段值为“on”的记录，SQL语句如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM fruits WHERE f_name like &#39;on&#39;;Empty set(0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-6-匹配指定字符中的任意一个"><a href="#6-6-匹配指定字符中的任意一个" class="headerlink" title="6.6 匹配指定字符中的任意一个"></a>6.6 匹配指定字符中的任意一个</h3><p>方括号“[]”指定一个字符集合，只匹配其中任何一个字符，即为所查找的文本。</p><p>在fruits表中，查找f_name字段中包含字母‘o’或者‘t’的记录，SQL语句如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#39;[ot]&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在fruits表中，查询s_id字段中包含 4 、 5 或者 6 的记录，SQL语句如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM fruits WHERE s_id REGEXP &#39;[456]&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-7-匹配指定字符以外的字符"><a href="#6-7-匹配指定字符以外的字符" class="headerlink" title="6.7 匹配指定字符以外的字符"></a>6.7 匹配指定字符以外的字符</h3><p><img src="/../pic/%E7%AC%AC04%E7%AB%A0_%E8%BF%90%E7%AE%97%E7%AC%A6/1649486052580.png" alt="1649486052580">匹配不在指定集合中的任何字符。</p><p>在fruits表中，查询f_id字段中包含字母a<del>e和数字1</del>2以外字符的记录，SQL语句如下：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; SELECT * FROM fruits WHERE f_id REGEXP &#39;[^a-e1-2]&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-8-使用-n-或者-n-m-来指定字符串连续出现的次数"><a href="#6-8-使用-n-或者-n-m-来指定字符串连续出现的次数" class="headerlink" title="6.8 使用{n,}或者{n,m}来指定字符串连续出现的次数"></a>6.8 使用{n,}或者{n,m}来指定字符串连续出现的次数</h3><p>“字符串{n,}”表示至少匹配n次前面的字符；“字符串{n,m}”表示匹配前面的字符串不少于n次，不多于m次。例如，a{2,}表示字母a连续出现至少 2 次，也可以大于 2 次；a{2,4}表示字母a连续出现最少 2 次，最多不能超过 4 次。</p><p>在fruits表中，查询f_name字段值出现字母‘x’至少 2 次的记录，SQL语句如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> fruits <span class="token keyword">WHERE</span> f_name <span class="token operator">REGEXP</span> <span class="token string">'x&#123;2,&#125;'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在fruits表中，查询f_name字段值出现字符串“ba”最少 1 次、最多 3 次的记录，SQL语句如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> fruits <span class="token keyword">WHERE</span> f_name <span class="token operator">REGEXP</span> <span class="token string">'ba&#123;1,3&#125;'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序与分页</title>
      <link href="/2022/07/17/di-05-zhang-pai-xu-yu-fen-ye/"/>
      <url>/2022/07/17/di-05-zhang-pai-xu-yu-fen-ye/</url>
      
        <content type="html"><![CDATA[<h1 id="第05章-排序与分页"><a href="#第05章-排序与分页" class="headerlink" title="第05章_排序与分页"></a>第05章_排序与分页</h1><h2 id="1-排序数据"><a href="#1-排序数据" class="headerlink" title="1. 排序数据"></a>1. 排序数据</h2><hr><h3 id="1-1-排序规则"><a href="#1-1-排序规则" class="headerlink" title="1. 1 排序规则"></a>1. 1 排序规则</h3><ul><li>使用 ORDER BY 子句排序<ul><li><strong>ASC（ascend）: 升序</strong></li><li><strong>DESC（descend）:降序</strong></li></ul></li><li><strong>ORDER BY 子句在SELECT语句的结尾。</strong></li></ul><h3 id="1-2-单列排序"><a href="#1-2-单列排序" class="headerlink" title="1. 2 单列排序"></a>1. 2 单列排序</h3><pre class="line-numbers language-none"><code class="language-none">SELECT last_name, job_id, department_id, hire_dateFROM employeesORDER BY hire_date ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC05%E7%AB%A0_%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%88%86%E9%A1%B5/1649486373781.png" alt="1649486373781"></p><pre class="line-numbers language-none"><code class="language-none">SELECT last_name, job_id, department_id, hire_dateFROM employeesORDER BY hire_date DESC ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC05%E7%AB%A0_%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%88%86%E9%A1%B5/1649486392806.png" alt="1649486392806"></p><pre class="line-numbers language-none"><code class="language-none">SELECT employee_id, last_name, salary* 12 annsalFROM employeesORDER BY annsal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC05%E7%AB%A0_%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%88%86%E9%A1%B5/1649486423273.png" alt="1649486423273"></p><h3 id="1-3-多列排序"><a href="#1-3-多列排序" class="headerlink" title="1. 3 多列排序"></a>1. 3 多列排序</h3><pre class="line-numbers language-none"><code class="language-none">SELECT last_name, department_id, salaryFROM employeesORDER BY department_id, salary DESC;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC05%E7%AB%A0_%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%88%86%E9%A1%B5/1649486490754.png" alt="1649486490754"></p><ul><li>可以使用不在SELECT列表中的列排序。</li><li>在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。</li></ul><hr><h2 id="2-分页"><a href="#2-分页" class="headerlink" title="2. 分页"></a>2. 分页</h2><hr><h3 id="2-1-背景"><a href="#2-1-背景" class="headerlink" title="2. 1 背景"></a>2. 1 背景</h3><p>背景 1 ：查询返回的记录太多了，查看起来很不方便，怎么样能够实现分页查询呢？</p><p>背景 2 ：表里有 4 条数据，我们只想要显示第 2 、 3 条数据怎么办呢？</p><h3 id="2-2-实现规则"><a href="#2-2-实现规则" class="headerlink" title="2. 2 实现规则"></a>2. 2 实现规则</h3><ul><li><p>分页原理<br>所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。</p></li><li><p>MySQL中使用 LIMIT 实现分页</p></li><li><p>格式：</p><pre class="line-numbers language-none"><code class="language-none">LIMIT [位置偏移量,] 行数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一个“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是 0 ，第二条记录的位置偏移量是1 ，以此类推）；第二个参数“行数”指示返回的记录条数。</p></li><li><p>举例</p><pre class="line-numbers language-none"><code class="language-none">--前 10 条记录：SELECT * FROM 表名 LIMIT 0 , 10 ;或者SELECT * FROM 表名 LIMIT 10 ;--第 11 至 20 条记录：SELECT * FROM 表名 LIMIT 10 , 10 ;--第 21 至 30 条记录：SELECT * FROM 表名 LIMIT 20 , 10 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第 5 条记录开始后面的 3 条记录，和“LIMIT 4,3;”返回的结果相同。</p></blockquote></li><li><p>分页显式公式 ：（<strong>当前页数- 1 ）*每页条数，每页条数</strong></p><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM tableLIMIT(PageNo - 1 )*PageSize,PageSize;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>注意：LIMIT 子句必须放在整个SELECT语句的最后！</strong></p></li><li><p>使用 LIMIT 的好处<br>约束返回结果的数量可以减少数据表的网络传输量，也可以提升查询效率。如果我们知道返回结果只有1 条，就可以使用LIMIT 1，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回。</p></li></ul><h3 id="2-3-拓展"><a href="#2-3-拓展" class="headerlink" title="2. 3 拓展"></a>2. 3 拓展</h3><p>在不同的 DBMS 中使用的关键字可能不同。在 MySQL、PostgreSQL、MariaDB 和 SQLite 中使用 LIMIT 关键字，而且需要放到 SELECT 语句的最后面。</p><ul><li><p>如果是 SQL Server 和 Access，需要使用 TOP 关键字，比如：</p><pre class="line-numbers language-none"><code class="language-none">SELECT TOP 5 name, hp_max FROM heros ORDER BY hp_max DESC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>如果是 DB2，使用FETCH FIRST 5 ROWS ONLY这样的关键字：</p><pre class="line-numbers language-none"><code class="language-none">SELECT name, hp_max FROM heros ORDER BY hp_max DESC FETCH FIRST 5 ROWS ONLY<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>如果是 Oracle，你需要基于 ROWNUM 来统计行数：</p><pre class="line-numbers language-none"><code class="language-none">SELECT rownum,last_name,salary FROM employees WHERE rownum &lt; 5 ORDER BY salary DESC;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要说明的是，这条语句是先取出来前 5 条数据行，然后再按照 hp_max 从高到低的顺序进行排序。但这样产生的结果和上述方法的并不一样。我会在后面讲到子查询，你可以使用</p><pre class="line-numbers language-none"><code class="language-none">SELECT rownum, last_name,salaryFROM (SELECT last_name,salaryFROM employeesORDER BY salary DESC)WHERE rownum &lt; 10 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到与上述方法一致的结果。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多表查询</title>
      <link href="/2022/07/17/di-06-zhang-duo-biao-cha-xun/"/>
      <url>/2022/07/17/di-06-zhang-duo-biao-cha-xun/</url>
      
        <content type="html"><![CDATA[<h1 id="第06章-多表查询"><a href="#第06章-多表查询" class="headerlink" title="第06章_多表查询"></a>第06章_多表查询</h1><p>多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。</p><p>前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进行关联。</p><hr><h2 id="1-一个案例引发的多表连接"><a href="#1-一个案例引发的多表连接" class="headerlink" title="1. 一个案例引发的多表连接"></a>1. 一个案例引发的多表连接</h2><hr><h3 id="1-1-案例说明"><a href="#1-1-案例说明" class="headerlink" title="1. 1 案例说明"></a>1. 1 案例说明</h3><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649562093193.png" alt="1649562093193"></p><p>从多个表中获取数据：</p><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649562120221.png" alt="1649562120221"></p><pre class="line-numbers language-none"><code class="language-none">#案例：查询员工的姓名及其部门名称SELECT last_name, department_nameFROM employees, departments;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649562169991.png" alt="1649562169991"></p><p>查询结果：</p><pre class="line-numbers language-none"><code class="language-none">+-----------+----------------------+| last_name | department_name |+-----------+----------------------+| King | Administration || King | Marketing || King | Purchasing || King | Human Resources || King | Shipping || King | IT || King | Public Relations || King | Sales || King | Executive || King | Finance || King | Accounting || King | Treasury |...| Gietz | IT Support || Gietz | NOC || Gietz | IT Helpdesk || Gietz | Government Sales || Gietz | Retail Sales || Gietz | Recruiting || Gietz | Payroll |+-----------+----------------------+2889 rows in set (0.01 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分析错误情况：</strong></p><pre class="line-numbers language-none"><code class="language-none">SELECT COUNT(employee_id) FROM employees;#输出 107 行SELECT COUNT(department_id)FROM departments;#输出 27 行SELECT 107 * 27 FROM dual;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们把上述多表查询中出现的问题称为：笛卡尔积的错误。</p><h3 id="1-2-笛卡尔积（或交叉连接）的理解"><a href="#1-2-笛卡尔积（或交叉连接）的理解" class="headerlink" title="1. 2 笛卡尔积（或交叉连接）的理解"></a>1. 2 笛卡尔积（或交叉连接）的理解</h3><p>笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素个数的乘积数。</p><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649562340672.png" alt="1649562340672"></p><p>SQL 92 中，笛卡尔积也称为<code>交叉连接</code>，英文是 <code>CROSS JOIN</code>。在 SQL 99 中也是使用 CROSS JOIN表示交叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。在MySQL中如下情况会出现笛卡尔积：</p><pre class="line-numbers language-none"><code class="language-none">#查询员工姓名和所在部门名称SELECT last_name,department_name FROM employees,departments;SELECT last_name,department_name FROM employees CROSS JOIN departments;SELECT last_name,department_name FROM employees INNER JOIN departments;SELECT last_name,department_name FROM employees JOIN departments;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-案例分析与问题解决"><a href="#1-3-案例分析与问题解决" class="headerlink" title="1.3 案例分析与问题解决"></a>1.3 案例分析与问题解决</h3><ul><li><p>笛卡尔积的错误会在下面条件下产生</p><p>：</p><ul><li>省略多个表的连接条件（或关联条件）</li><li>连接条件（或关联条件）无效</li><li>所有表中的所有行互相连接</li></ul></li><li><p>为了避免笛卡尔积， 可以 <strong>在 WHERE 加入有效的连接条件</strong>。</p></li><li><p>加入连接条件后，查询语法：</p></li></ul><pre class="line-numbers language-none"><code class="language-none">SELECT table1.column, table2.columnFROM table1, tableWHERE table1.column 1 &#x3D; table2.column 2 ;  #连接条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>在 WHERE子句中写入连接条件。</strong></li><li>正确写法：</li></ul><pre class="line-numbers language-none"><code class="language-none">#案例：查询员工的姓名及其部门名称SELECT last_name, department_nameFROM employees, departmentsWHERE employees.department_id &#x3D; departments.department_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>在表中有相同列时，在列名之前加上表名前缀。</strong></li></ul><hr><h2 id="2-多表查询分类讲解"><a href="#2-多表查询分类讲解" class="headerlink" title="2. 多表查询分类讲解"></a>2. 多表查询分类讲解</h2><hr><h3 id="2-1-分类-1-：等值连接-vs-非等值连接"><a href="#2-1-分类-1-：等值连接-vs-非等值连接" class="headerlink" title="2.1 分类 1 ：等值连接 vs 非等值连接"></a>2.1 分类 1 ：等值连接 vs 非等值连接</h3><p>等值连接</p><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649566844687.png" alt="1649566844687"></p><pre class="line-numbers language-none"><code class="language-none">SELECT employees.employee_id, employees.last_name,employees.department_id, departments.department_id,departments.location_idFROM employees, departmentsWHERE employees.department_id &#x3D; departments.department_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649566902864.png" alt="1649566902864"></p><p><strong>拓展 1 ：多个连接条件与 AND 操作符</strong></p><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649566932411.png" alt="1649566932411"></p><p><strong>拓展 2 ：区分重复的列名</strong></p><ul><li><strong>多个表中有相同列时，必须在列名之前加上表名前缀。</strong></li><li>在不同表中具有相同列名的列可以用表名加以区分。</li></ul><pre class="line-numbers language-none"><code class="language-none">SELECT employees.last_name, departments.department_name,employees.department_idFROM employees, departmentsWHERE employees.department_id &#x3D; departments.department_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>拓展 3 ：表的别名</strong></p><ul><li>使用别名可以简化查询。</li><li>列名前使用表名前缀可以提高查询效率。</li></ul><pre class="line-numbers language-none"><code class="language-none">SELECT e.employee_id, e.last_name, e.department_id,d.department_id, d.location_idFROM employees e , departments dWHERE e.department_id &#x3D; d.department_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错。</p></blockquote><blockquote><p><code>阿里开发规范</code>：</p><p>【<code>强制</code>】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或表名）进行限定。</p><p><code>说明</code>：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。</p><p><code>正例</code>：select t1.name from table_first as t1 , table_second as t2 where t1.id&#x3D;t2.id;</p><p><code>反例</code>：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在 某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出1052 异常：Column ‘name’ in field list is ambiguous。</p></blockquote><p><strong>拓展 4 ：连接多个表</strong></p><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649567119984.png" alt="1649567119984"></p><p><strong>总结：连接 n个表,至少需要n- 1 个连接条件。</strong>比如，连接三个表，至少需要两个连接条件。</p><p>练习：查询出公司员工的 last_name,department_name, city</p><p><strong>非等值连接</strong></p><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649567177196.png" alt="1649567177196"></p><pre class="line-numbers language-none"><code class="language-none">SELECT e.last_name, e.salary, j.grade_levelFROM employees e, job_grades jWHERE e.salary BETWEEN j.lowest_sal AND j.highest_sal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649567207097.png" alt="1649567207097"></p><h3 id="2-2-分类-2-：自连接-vs-非自连接"><a href="#2-2-分类-2-：自连接-vs-非自连接" class="headerlink" title="2.2 分类 2 ：自连接 vs 非自连接"></a>2.2 分类 2 ：自连接 vs 非自连接</h3><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649567234724.png" alt="1649567234724"></p><ul><li>当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两个表再进行内连接，外连接等查询。</li></ul><p><strong>题目：查询employees表，返回“Xxx works for Xxx”</strong></p><pre class="line-numbers language-none"><code class="language-none">SELECT CONCAT(worker.last_name ,&#39; works for &#39;, manager.last_name)FROM employees worker, employees managerWHERE worker.manager_id &#x3D; manager.employee_id ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649567281192.png" alt="1649567281192"></p><p>练习：查询出last_name为 ‘Chen’ 的员工的 manager 的信息。</p><h3 id="2-3-分类-3-：内连接-vs-外连接"><a href="#2-3-分类-3-：内连接-vs-外连接" class="headerlink" title="2.3 分类 3 ：内连接 vs 外连接"></a>2.3 分类 3 ：内连接 vs 外连接</h3><p>除了查询满足条件的记录以外，外连接还可以查询某一方不满足条件的记录。</p><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649567317244.png" alt="1649567317244"></p><ul><li>内连接: 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行</li><li>外连接: 两个表在连接过程中除了返回满足连接条件的行以外 还返回左（或右）表中不满足条件的行 ，这种连接称为左（或右） 外连接 。没有匹配的行时, 结果表中相应的列为空(NULL)。</li><li>如果是左外连接，则连接条件中左边的表也称为主表，右边的表称为从表。<br>如果是右外连接，则连接条件中右边的表也称为主表，左边的表称为从表。</li></ul><h3 id="2-4-SQL-92-：使用-创建连接"><a href="#2-4-SQL-92-：使用-创建连接" class="headerlink" title="2.4 SQL 92 ：使用(+)创建连接"></a>2.4 SQL 92 ：使用(+)创建连接</h3><ul><li><p>在 SQL92 中采用（+）代表从表所在的位置。即左或右外连接中，(+) 表示哪个是从表。</p></li><li><p>Oracle 对 SQL92 支持较好，而 MySQL 则不支持 SQL92 的外连接。</p><pre class="line-numbers language-none"><code class="language-none">#左外连接SELECT last_name,department_nameFROM employees ,departmentsWHERE employees.department_id &#x3D; departments.department_id(+);#右外连接SELECT last_name,department_nameFROM employees ,departmentsWHERE employees.department_id(+) &#x3D; departments.department_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>而且在 SQL92 中，只有左外连接和右外连接，没有满（或全）外连接。</p></li></ul><hr><h2 id="3-SQL-99-语法实现多表查询"><a href="#3-SQL-99-语法实现多表查询" class="headerlink" title="3. SQL 99 语法实现多表查询"></a>3. SQL 99 语法实现多表查询</h2><hr><h3 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3. 1 基本语法"></a>3. 1 基本语法</h3><ul><li><p>使用JOIN…ON子句创建连接的语法结构：</p><pre class="line-numbers language-none"><code class="language-none">SELECT table1.column, table2.column,table3.columnFROM tableJOIN table2 ON table1 和 table2 的连接条件JOIN table3 ON table2 和 table3 的连接条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>它的嵌套逻辑类似我们使用的 FOR 循环：</p><pre class="line-numbers language-none"><code class="language-none">for t1 in table1:for t2 in table2:if condition1:for t3 in table3:if condition2:output t1 + t2 + t<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SQL 99 采用的这种嵌套结构非常清爽、层次性更强、可读性更强，即使再多的表进行连接也都清晰可见。如果你采用 SQL 92 ，可读性就会大打折扣。</p></li><li><p>语法说明：</p><ul><li><strong>可以使用 ON 子句指定额外的连接条件 。</strong></li><li>这个连接条件是与其它条件分开的。</li><li><strong>ON 子句使语句具有更高的易读性 。</strong></li><li>关键字 JOIN、INNER JOIN、CROSS JOIN 的含义是一样的，都表示内连接</li></ul></li></ul><h3 id="3-2-内连接-INNER-JOIN-的实现"><a href="#3-2-内连接-INNER-JOIN-的实现" class="headerlink" title="3. 2 内连接(INNER JOIN)的实现"></a>3. 2 内连接(INNER JOIN)的实现</h3><ul><li><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">SELECT 字段列表FROM A表 INNER JOIN B表ON 关联条件WHERE 等其他子句;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>题目 1 ：</p><pre class="line-numbers language-none"><code class="language-none">SELECT e.employee_id, e.last_name, e.department_id,d.department_id, d.location_idFROM employees e JOIN departments dON (e.department_id &#x3D; d.department_id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649567757543.png" alt="1649567757543"></p><p>题目 2 ：</p><pre class="line-numbers language-none"><code class="language-none">SELECT employee_id, city, department_nameFROM employees eJOIN departments dON d.department_id &#x3D; e.department_idJOIN locations lON d.location_id &#x3D; l.location_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649567786267.png" alt="1649567786267"></p><h3 id="3-3-外连接-OUTER-JOIN-的实现"><a href="#3-3-外连接-OUTER-JOIN-的实现" class="headerlink" title="3. 3 外连接(OUTER JOIN)的实现"></a>3. 3 外连接(OUTER JOIN)的实现</h3><h4 id="3-3-1-左外连接-LEFT-OUTER-JOIN"><a href="#3-3-1-左外连接-LEFT-OUTER-JOIN" class="headerlink" title="3. 3. 1 左外连接(LEFT OUTER JOIN)"></a>3. 3. 1 左外连接(LEFT OUTER JOIN)</h4><ul><li><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">#实现查询结果是ASELECT 字段列表FROM A表 LEFT JOIN B表ON 关联条件WHERE 等其他子句;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">SELECT e.last_name, e.department_id, d.department_nameFROM employees eLEFT OUTER JOIN departments dON (e.department_id &#x3D; d.department_id) ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649567858182.png" alt="1649567858182"></p></li></ul><h4 id="3-3-2-右外连接-RIGHT-OUTER-JOIN"><a href="#3-3-2-右外连接-RIGHT-OUTER-JOIN" class="headerlink" title="3. 3. 2 右外连接(RIGHT OUTER JOIN)"></a>3. 3. 2 右外连接(RIGHT OUTER JOIN)</h4><ul><li><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">#实现查询结果是BSELECT 字段列表FROM A表 RIGHT JOIN B表ON 关联条件WHERE 等其他子句;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">SELECT e.last_name, e.department_id, d.department_nameFROM employees eRIGHT OUTER JOIN departments dON (e.department_id &#x3D; d.department_id) ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649567951152.png" alt="1649567951152"></p></li></ul><blockquote><p>需要注意的是，LEFT JOIN 和 RIGHT JOIN 只存在于 SQL 99 及以后的标准中，在 SQL 92 中不存在，只能用 (+) 表示。</p></blockquote><h4 id="3-3-3-满外连接-FULL-OUTER-JOIN"><a href="#3-3-3-满外连接-FULL-OUTER-JOIN" class="headerlink" title="3. 3. 3 满外连接(FULL OUTER JOIN)"></a>3. 3. 3 满外连接(FULL OUTER JOIN)</h4><ul><li>满外连接的结果 &#x3D; 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。</li><li>SQL 99 是支持满外连接的。使用FULL JOIN 或 FULL OUTER JOIN来实现。</li><li>需要注意的是，MySQL不支持FULL JOIN，但是可以用 LEFT JOIN UNION RIGHT join代替。</li></ul><hr><h2 id="4-UNION的使用"><a href="#4-UNION的使用" class="headerlink" title="4. UNION的使用"></a>4. UNION的使用</h2><hr><p><strong>合并查询结果</strong>利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNION ALL关键字分隔。</p><p>语法格式：</p><pre class="line-numbers language-none"><code class="language-none">SELECT column,... FROM tableUNION [ALL]SELECT column,... FROM table<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>UNION操作符</strong></p><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649568054268.png" alt="1649568054268"></p><p>UNION 操作符返回两个查询的结果集的并集，去除重复记录。</p><p><strong>UNION ALL操作符</strong></p><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649568075220.png" alt="1649568075220"></p><p>UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。</p><blockquote><p>注意：执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。</p></blockquote><p>举例：查询部门编号&gt; 90 或邮箱包含a的员工信息</p><pre class="line-numbers language-none"><code class="language-none">#方式 1SELECT * FROM employees WHERE email LIKE &#39;%a%&#39; OR department_id&gt; 90 ;#方式 2SELECT * FROM employees  WHERE email LIKE &#39;%a%&#39;UNIONSELECT * FROM employees  WHERE department_id&gt; 90 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：查询中国用户中男性的信息以及美国用户中年男性的用户信息</p><pre class="line-numbers language-none"><code class="language-none">SELECT id,cname FROM t_chinamale WHERE csex&#x3D;&#39;男&#39;UNION ALLSELECT id,tname FROM t_usmale WHERE tGender&#x3D;&#39;male&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="5-七种SQL-JOINS的实现"><a href="#5-七种SQL-JOINS的实现" class="headerlink" title="5. 七种SQL JOINS的实现"></a>5. 七种SQL JOINS的实现</h2><hr><p><img src="/../pic/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1649568229075.png" alt="1649568229075"></p><h3 id="5-1-代码实现"><a href="#5-1-代码实现" class="headerlink" title="5.1 代码实现"></a>5.1 代码实现</h3><pre class="line-numbers language-none"><code class="language-none">#中图：内连接 A∩BSELECT employee_id,last_name,department_nameFROM employees e JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;;#左上图：左外连接SELECT employee_id,last_name,department_nameFROM employees e LEFT JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;;#右上图：右外连接SELECT employee_id,last_name,department_nameFROM employees e RIGHT JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;;SELECT employee_id,last_name,department_nameFROM employees e LEFT JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;WHERE d.&#96;department_id&#96; IS NULL#右中图：B-A∩BSELECT employee_id,last_name,department_nameFROM employees e RIGHT JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;WHERE e.&#96;department_id&#96; IS NULL#左下图：满外连接左中图 + 右上图 A∪BSELECT employee_id,last_name,department_nameFROM employees e LEFT JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;WHERE d.&#96;department_id&#96; IS NULLUNION ALL #没有去重操作，效率高SELECT employee_id,last_name,department_nameFROM employees e RIGHT JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;;#右下图#左中图 + 右中图 A ∪B- A∩B 或者 (A - A∩B) ∪ （B - A∩B）SELECT employee_id,last_name,department_nameFROM employees e LEFT JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;WHERE d.&#96;department_id&#96; IS NULLUNION ALLSELECT employee_id,last_name,department_nameFROM employees e RIGHT JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;WHERE e.&#96;department_id&#96; IS NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-语法格式小结"><a href="#5-2-语法格式小结" class="headerlink" title="5.2 语法格式小结"></a>5.2 语法格式小结</h3><ul><li><p>左中图</p><pre class="line-numbers language-none"><code class="language-none">#实现A - A∩Bselect 字段列表from A表 left join B表on 关联条件where 从表关联字段 is null and 等其他子句;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>右中图</p><pre class="line-numbers language-none"><code class="language-none">#实现B - A∩Bselect 字段列表from A表 right join B表on 关联条件where 从表关联字段 is null and 等其他子句;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>左下图</p><pre class="line-numbers language-none"><code class="language-none">#实现查询结果是A∪B#用左外的A，union 右外的Bselect 字段列表from A表 left join B表on 关联条件where 等其他子句unionselect 字段列表from A表 right join B表on 关联条件where 等其他子句;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>右下图</p><pre class="line-numbers language-none"><code class="language-none">#实现A∪B - A∩B 或 (A - A∩B) ∪ （B - A∩B）#使用左外的 (A - A∩B) union 右外的（B - A∩B）select 字段列表from A表 left join B表on 关联条件where 从表关联字段 is null and 等其他子句unionselect 字段列表from A表 right join B表on 关联条件where 从表关联字段 is null and 等其他子句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="6-SQL-99-语法新特性"><a href="#6-SQL-99-语法新特性" class="headerlink" title="6. SQL 99 语法新特性"></a>6. SQL 99 语法新特性</h2><hr><h3 id="6-1-自然连接"><a href="#6-1-自然连接" class="headerlink" title="6. 1 自然连接"></a>6. 1 自然连接</h3><p>SQL 99 在 SQL 92 的基础上提供了一些特殊语法，比如 <code>NATURAL JOIN</code> 用来表示自然连接。我们可以把自然连接理解为 SQL 92 中的等值连接。它会帮你自动查询两张连接表中<code>所有相同的字段</code>，然后进行<code>等值连接</code>。</p><p>在SQL 92 标准中：</p><pre class="line-numbers language-none"><code class="language-none">SELECT employee_id,last_name,department_nameFROM employees e JOIN departments dON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;AND e.&#96;manager_id&#96; &#x3D; d.&#96;manager_id&#96;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 SQL 99 中你可以写成：</p><pre class="line-numbers language-none"><code class="language-none">SELECT employee_id,last_name,department_nameFROM employees e NATURAL JOIN departments d;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-2-USING连接"><a href="#6-2-USING连接" class="headerlink" title="6. 2 USING连接"></a>6. 2 USING连接</h3><p>当我们进行连接的时候，SQL 99 还支持使用 USING 指定数据表里的同名字段进行等值连接。但是只能配合JOIN一起使用。比如：</p><pre class="line-numbers language-none"><code class="language-none">SELECT employee_id,last_name,department_nameFROM employees e JOIN departments dUSING (department_id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你能看出与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING的括号 () 中填入要指定的同名字段。同时使用 JOIN…USING 可以简化 JOIN ON 的等值连接。它与下面的 SQL 查询结果是相同的：</p><pre class="line-numbers language-none"><code class="language-none">SELECT employee_id,last_name,department_nameFROM employees e ,departments dWHERE e.department_id &#x3D; d.department_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="7-章节小结"><a href="#7-章节小结" class="headerlink" title="7. 章节小结"></a>7. 章节小结</h2><hr><p>表连接的约束条件可以有三种方式：WHERE, ON, USING</p><ul><li>WHERE：适用于所有关联查询</li><li>ON：只能和JOIN一起使用，只能写关联条件。虽然关联条件可以并到WHERE中和其他条件一起写，但分开写可读性更好。</li><li>USING：只能和JOIN一起使用，而且要求 两个 关联字段在关联表中名称一致，而且只能表示关联字段值相等</li></ul><pre class="line-numbers language-none"><code class="language-none">#关联条件#把关联条件写在where后面SELECT last_name,department_nameFROM employees,departmentsWHERE employees.department_id &#x3D; departments.department_id;#把关联条件写在on后面，只能和JOIN一起使用SELECT last_name,department_nameFROM employees INNER JOIN departmentsON employees.department_id &#x3D; departments.department_id;SELECT last_name,department_nameFROM employees CROSS JOIN departmentsON employees.department_id &#x3D; departments.department_id;SELECT last_name,department_nameFROM employees JOIN departmentsON employees.department_id &#x3D; departments.department_id;#把关联字段写在using()中，只能和JOIN一起使用#而且两个表中的关联字段必须名称相同，而且只能表示&#x3D;#查询员工姓名与基本工资SELECT last_name,job_titleFROM employees INNER JOIN jobs USING(job_id);#n张表关联，需要n-1个关联条件#查询员工姓名，基本工资，部门名称SELECT last_name,job_title,department_name FROM employees,departments,jobsWHERE employees.department_id &#x3D; departments.department_idAND employees.job_id &#x3D; jobs.job_id;SELECT last_name,job_title,department_nameFROM employees INNER JOIN departments INNER JOIN jobsON employees.department_id &#x3D; departments.department_idAND employees.job_id &#x3D; jobs.job_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong></p><p>我们要<code>控制连接表的数量</code>。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下降得很严重，因此不要连接不必要的表。在许多 DBMS 中，也都会有最大连接表的限制。</p><blockquote><p>【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保证被关联的字段需要有索引。</p><p>说明：即使双表 join 也要注意表索引、SQL 性能。</p><p>来源：阿里巴巴《Java开发手册》</p></blockquote><hr><h2 id="附录：常用的-SQL-标准有哪些"><a href="#附录：常用的-SQL-标准有哪些" class="headerlink" title="附录：常用的 SQL 标准有哪些"></a>附录：常用的 SQL 标准有哪些</h2><hr><p>在正式开始讲连接表的种类时，我们首先需要知道 SQL 存在不同版本的标准规范，因为不同规范下的表连接操作是有区别的。</p><p>SQL 有两个主要的标准，分别是 <code>SQL92</code> 和 <code>SQL99</code>。 92 和 99 代表了标准提出的时间，SQL92 就是 92 年提出的标准规范。当然除了 SQL92 和 SQL99 以外，还存在 SQL-86、SQL-89、SQL:2003、SQL:2008、SQL:2011 和 SQL:2016 等其他的标准。</p><p>这么多标准，到底该学习哪个呢？ <strong>实际上最重要的 SQL 标准就是 SQL 92 和 SQL 99</strong> 。一般来说 SQL92 的形式更简单，但是写的 SQL 语句会比较长，可读性较差。而 SQL99 相比于 SQL92 来说，语法更加复杂，但可读性更强。我们从这两个标准发布的页数也能看出，SQL92 的标准有 500 页，而 SQL99 标准超过了1000 页。实际上从 SQL99 之后，很少有人能掌握所有内容，因为确实太多了。就好比我们使用Windows、Linux 和 Office 的时候，很少有人能掌握全部内容一样。我们只需要掌握一些核心的功能，满足日常工作的需求即可。</p><p><strong>SQL 92 和 SQL 99 是经典的 SQL 标准，也分别叫做 SQL- 2 和 SQL- 3 标准。</strong> 也正是在这两个标准发布之后，SQL 影响力越来越大，甚至超越了数据库领域。现如今 SQL 已经不仅仅是数据库领域的主流语言，还是信息领域中信息处理的主流语言。在图形检索、图像检索以及语音检索中都能看到 SQL 语言的使用。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单行函数</title>
      <link href="/2022/07/17/di-07-zhang-dan-xing-han-shu/"/>
      <url>/2022/07/17/di-07-zhang-dan-xing-han-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="第07章-单行函数"><a href="#第07章-单行函数" class="headerlink" title="第07章_单行函数"></a>第07章_单行函数</h1><h2 id="1-函数的理解"><a href="#1-函数的理解" class="headerlink" title="1. 函数的理解"></a>1. 函数的理解</h2><hr><h3 id="1-1-什么是函数"><a href="#1-1-什么是函数" class="headerlink" title="1. 1 什么是函数"></a>1. 1 什么是函数</h3><p>函数在计算机语言的使用中贯穿始终，函数的作用是什么呢？它可以把我们经常使用的代码封装起来，需要的时候直接调用即可。这样既<code>提高了代码效率</code>，又<code>提高了可维护性</code>。在 SQL 中我们也可以使用函数对检索出来的数据进行函数操作。使用这些函数，可以极大地<code>提高用户对数据库的管理效率</code>。</p><p><img src="/../pic/%E7%AC%AC07%E7%AB%A0_%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/1649580146867.png" alt="1649580146867"></p><p>从函数定义的角度出发，我们可以将函数分成<code>内置函数</code>和<code>自定义函数</code>。在 SQL 语言中，同样也包括了内置函数和自定义函数。内置函数是系统内置的通用函数，而自定义函数是我们根据自己的需要编写的，本章及下一章讲解的是 SQL 的内置函数。</p><h3 id="1-2-不同DBMS函数的差异"><a href="#1-2-不同DBMS函数的差异" class="headerlink" title="1. 2 不同DBMS函数的差异"></a>1. 2 不同DBMS函数的差异</h3><p>我们在使用 SQL 语言的时候，不是直接和这门语言打交道，而是通过它使用不同的数据库软件，即DBMS。 <strong>DBMS 之间的差异性很大，远大于同一个语言不同版本之间的差异。</strong> 实际上，只有很少的函数是被 DBMS 同时支持的。比如，大多数 DBMS 使用（||）或者（+）来做拼接符，而在 MySQL 中的字符串拼接函数为concat()。大部分 DBMS 会有自己特定的函数，这就意味着 <strong>采用 SQL 函数的代码可移植性是很差的</strong> ，因此在使用函数的时候需要特别注意。</p><h3 id="1-3-MySQL的内置函数及分类"><a href="#1-3-MySQL的内置函数及分类" class="headerlink" title="1. 3 MySQL的内置函数及分类"></a>1. 3 MySQL的内置函数及分类</h3><p>MySQL提供了丰富的内置函数，这些函数使得数据的维护与管理更加方便，能够更好地提供数据的分析与统计功能，在一定程度上提高了开发人员进行数据分析与统计的效率。</p><p>MySQL提供的内置函数从<code>实现的功能角度</code>可以分为数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数、获取MySQL信息函数、聚合函数等。这里，我将这些丰富的内置函数再分为两类：<code>单行函数</code>、<code>聚合函数（或分组函数）</code>。</p><p><strong>两种SQL函数</strong></p><p><img src="/../pic/%E7%AC%AC07%E7%AB%A0_%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/1649580387011.png" alt="1649580387011"></p><p><strong>单行函数</strong></p><ul><li>操作数据对象</li><li>接受参数返回一个结果</li><li><strong>只对一行进行变换</strong></li><li><strong>每行返回一个结果</strong></li><li>可以嵌套</li><li>参数可以是一列或一个值</li></ul><hr><h2 id="2-数值函数"><a href="#2-数值函数" class="headerlink" title="2. 数值函数"></a>2. 数值函数</h2><hr><h3 id="2-1-基本函数"><a href="#2-1-基本函数" class="headerlink" title="2. 1 基本函数"></a>2. 1 基本函数</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>ABS(x)</td><td>返回x的绝对值</td></tr><tr><td>SIGN(X)</td><td>返回X的符号。正数返回 1 ，负数返回-1， 0 返回 0</td></tr><tr><td>PI()</td><td>返回圆周率的值</td></tr><tr><td>CEIL(x)，CEILING(x)</td><td>返回大于或等于某个值的最小整数</td></tr><tr><td>FLOOR(x)</td><td>返回小于或等于某个值的最大整数</td></tr><tr><td>LEAST(e1,e2,e3…)</td><td>返回列表中的最小值</td></tr><tr><td>GREATEST(e1,e2,e3…)</td><td>返回列表中的最大值</td></tr><tr><td>MOD(x,y)</td><td>返回X除以Y后的余数</td></tr><tr><td>RAND()</td><td>返回0~1的随机值</td></tr><tr><td>RAND(x)</td><td>返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机数</td></tr><tr><td>ROUND(x)</td><td>返回一个对x的值进行四舍五入后，最接近于X的整数</td></tr><tr><td>ROUND(x,y)</td><td>返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位</td></tr><tr><td>TRUNCATE(x,y)</td><td>返回数字x截断为y位小数的结果</td></tr><tr><td>SQRT(x)</td><td>返回x的平方根。当X的值为负数时，返回NULL</td></tr></tbody></table><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">SELECTABS(-123),ABS(32),SIGN(-23),SIGN(43),PI(),CEIL(32.32),CEILING(-43.23),FLOOR(32.32),FLOOR(-43.23),MOD( 12 , 5 )FROM DUAL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC07%E7%AB%A0_%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/1649580837301.png" alt="1649580837301"></p><pre class="line-numbers language-none"><code class="language-none">SELECT RAND(),RAND(),RAND( 10 ),RAND( 10 ),RAND(- 1 ),RAND(- 1 )FROM DUAL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC07%E7%AB%A0_%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/1649580972765.png" alt="1649580972765"></p><pre class="line-numbers language-none"><code class="language-none">SELECTROUND(12.33),ROUND(12.343,2),ROUND(12.324,-1),TRUNCATE(12.66,1),TRUNCATE(12.66,-1)FROM DUAL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC07%E7%AB%A0_%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/1649581095543.png" alt="1649581095543"></p><h3 id="2-2-角度与弧度互换函数"><a href="#2-2-角度与弧度互换函数" class="headerlink" title="2. 2 角度与弧度互换函数"></a>2. 2 角度与弧度互换函数</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>RADIANS(x)</td><td>将角度转化为弧度，其中，参数x为角度值</td></tr><tr><td>DEGREES(x)</td><td>将弧度转化为角度，其中，参数x为弧度值</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">SELECT RADIANS(30),RADIANS(60),RADIANS(90),DEGREES(2*PI()),DEGREES(RADIANS(90))FROM DUAL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-3-三角函数"><a href="#2-3-三角函数" class="headerlink" title="2. 3 三角函数"></a>2. 3 三角函数</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>SIN(x)</td><td>返回x的正弦值，其中，参数x为弧度值</td></tr><tr><td>ASIN(x)</td><td>返回x的反正弦值，即获取正弦为x的值。如果x的值不在- 1 到 1 之间，则返回NULL</td></tr><tr><td>COS(x)</td><td>返回x的余弦值，其中，参数x为弧度值</td></tr><tr><td>ACOS(x)</td><td>返回x的反余弦值，即获取余弦为x的值。如果x的值不在- 1 到 1 之间，则返回NULL</td></tr><tr><td>TAN(x)</td><td>返回x的正切值，其中，参数x为弧度值</td></tr><tr><td>ATAN(x)</td><td>返回x的反正切值，即返回正切值为x的值</td></tr><tr><td>ATAN2(m,n)</td><td>返回两个参数的反正切值</td></tr><tr><td>COT(x)</td><td>返回x的余切值，其中，X为弧度值</td></tr></tbody></table><p>举例：</p><p>ATAN 2 (M,N)函数返回两个参数的反正切值。 与ATAN(X)函数相比，ATAN 2 (M,N)需要两个参数，例如有两个点point(x 1 ,y 1 )和point(x 2 ,y 2 )，使用ATAN(X)函数计算反正切值为ATAN((y 2 - y 1 )&#x2F;(x 2 - x 1 ))，使用ATAN 2 (M,N)计算反正切值则为ATAN 2 (y 2 - y 1 ,x 2 - x 1 )。由使用方式可以看出，当x 2 - x 1 等于 0 时，ATAN(X)函数会报错，而ATAN 2 (M,N)函数则仍然可以计算。</p><p>ATAN 2 (M,N)函数的使用示例如下：</p><pre class="line-numbers language-none"><code class="language-none">SELECTSIN(RADIANS(30)),DEGREES(ASIN(1)),TAN(RADIANS(45)),DEGREES(ATAN(1)),DEGREES(ATAN2(1,1))FROM DUAL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC07%E7%AB%A0_%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/1649581614362.png" alt="1649581614362"></p><h3 id="2-4-指数与对数"><a href="#2-4-指数与对数" class="headerlink" title="2.4 指数与对数"></a>2.4 指数与对数</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>POW(x,y)，POWER(X,Y)</td><td>返回x的y次方</td></tr><tr><td>EXP(X)</td><td>返回e的X次方，其中e是一个常数，2.718281828459045</td></tr><tr><td>LN(X)，LOG(X)</td><td>返回以e为底的X的对数，当X &lt;&#x3D; 0 时，返回的结果为NULL</td></tr><tr><td>LOG10(X)</td><td>返回以 10 为底的X的对数，当X &lt;&#x3D; 0 时，返回的结果为NULL</td></tr><tr><td>LOG2(X)</td><td>返回以 2 为底的X的对数，当X &lt;&#x3D; 0 时，返回NULL</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT POW( 2 , 5 ),POWER( 2 , 4 ),EXP( 2 ),LN( 10 ),LOG10( 10 ),LOG2(4)-&gt; FROM DUAL;+----------+------------+------------------+-------------------+-----------+---------+| POW( 2 , 5 ) | POWER( 2 , 4 ) | EXP( 2 ) | LN( 10 ) | LOG10( 10 ) | LOG2(4) |+----------+------------+------------------+-------------------+-----------+---------+| 32 | 16 | 7.38905609893065 | 2.302585092994046 | 1 | 2 |+----------+------------+------------------+-------------------+-----------+---------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-进制间的转换"><a href="#2-5-进制间的转换" class="headerlink" title="2. 5 进制间的转换"></a>2. 5 进制间的转换</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>BIN(x)</td><td>返回x的二进制编码</td></tr><tr><td>HEX(x)</td><td>返回x的十六进制编码</td></tr><tr><td>OCT(x)</td><td>返回x的八进制编码</td></tr><tr><td>CONV(x,f1,f2)</td><td>返回f1进制数变成f2进制数</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT BIN( 10 ),HEX( 10 ),OCT( 10 ),CONV( 10 , 2 , 8 )-&gt; FROM DUAL;+---------+---------+---------+--------------+| BIN( 10 ) | HEX( 10 ) | OCT( 10 ) | CONV( 10 , 2 , 8 ) |+---------+---------+---------+--------------+| 1010 | A | 12 | 2 |+---------+---------+---------+--------------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="3-字符串函数"><a href="#3-字符串函数" class="headerlink" title="3. 字符串函数"></a>3. 字符串函数</h2><hr><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>ASCII(S)</td><td>返回字符串S中的第一个字符的ASCII码值</td></tr><tr><td>CHAR_LENGTH(s)</td><td>返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同</td></tr><tr><td>LENGTH(s)</td><td>返回字符串s的字节数，和字符集有关</td></tr><tr><td>CONCAT(s1,s2,……,sn)</td><td>连接s1,s2,……,sn为一个字符串</td></tr><tr><td>CONCAT_WS(x,s1,s2,……,sn)</td><td>同CONCAT(s1,s2,…)函数，但是每个字符串之间要加上x</td></tr><tr><td>INSERT(str,idx,len,replacestr)</td><td>将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr</td></tr><tr><td>REPLACE(str, a, b)</td><td>用字符串b替换字符串str中所有出现的字符串a</td></tr><tr><td>UPPER(s) 或 UCASE(s)</td><td>将字符串s的所有字母转成大写字母</td></tr><tr><td>LOWER(s) 或LCASE(s)</td><td>将字符串s的所有字母转成小写字母</td></tr><tr><td>LEFT(str,n)</td><td>返回字符串str最左边的n个字符</td></tr><tr><td>RIGHT(str,n)</td><td>返回字符串str最右边的n个字符</td></tr><tr><td>LPAD(str, len, pad)</td><td>用字符串pad对str最左边进行填充，直到str的长度为len个字符</td></tr><tr><td>RPAD(str ,len, pad)</td><td>用字符串pad对str最右边进行填充，直到str的长度为len个字符</td></tr><tr><td>LTRIM(s)</td><td>去掉字符串s左侧的空格</td></tr><tr><td>RTRIM(s)</td><td>去掉字符串s右侧的空格</td></tr><tr><td>TRIM(s)</td><td>去掉字符串s开始与结尾的空格</td></tr><tr><td>TRIM(s1 FROM s)</td><td>去掉字符串s开始与结尾的s</td></tr><tr><td>TRIM(LEADING s FROM s)</td><td>去掉字符串s开始处的s</td></tr><tr><td>TRIM(TRAILING s FROM s)</td><td>去掉字符串s结尾处的s</td></tr><tr><td>REPEAT(str, n)</td><td>返回str重复n次的结果</td></tr><tr><td>SPACE(n)</td><td>返回n个空格</td></tr><tr><td>STRCMP(s1,s2)</td><td>比较字符串s1,s2的ASCII码值的大小</td></tr><tr><td>SUBSTR(s,index,len)</td><td>返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、MID(s,n,len)相同</td></tr><tr><td>LOCATE(substr,str)</td><td>返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN str)、INSTR(str,substr)相同。未找到，返回 0</td></tr><tr><td>ELT(m,s1,s2,…,sn)</td><td>返回指定位置的字符串，如果m&#x3D;1，则返回s1，如果m&#x3D;2，则返回s2，如果m&#x3D;n，则返回sn</td></tr><tr><td>FIELD(s,s1,s2,…,sn)</td><td>返回字符串s在字符串列表中第一次出现的位置</td></tr><tr><td>FIND_IN_SET(s1,s2)</td><td>返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串</td></tr><tr><td>REVERSE(s)</td><td>返回s反转后的字符串</td></tr><tr><td>NULLIF(value1,value2)</td><td>比较两个字符串，如果value1与value2相等，则返回NULL，否则返回value1</td></tr></tbody></table><blockquote><p>注意：MySQL中，字符串的位置是从 1 开始的。</p></blockquote><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT FIELD(&#39;mm&#39;,&#39;hello&#39;,&#39;msm&#39;,&#39;amma&#39;),FIND_IN_SET(&#39;mm&#39;,&#39;hello,mm,amma&#39;)-&gt; FROM DUAL;+----------------------------------+-----------------------------------+| FIELD(&#39;mm&#39;,&#39;hello&#39;,&#39;msm&#39;,&#39;amma&#39;) | FIND_IN_SET(&#39;mm&#39;,&#39;hello,mm,amma&#39;) |+----------------------------------+-----------------------------------+| 0 | 2 |+----------------------------------+-----------------------------------+1 row in set (0.00 sec)mysql&gt; SELECT NULLIF(&#39;mysql&#39;,&#39;mysql&#39;),NULLIF(&#39;mysql&#39;, &#39;&#39;);+-------------------------+---------------------+| NULLIF(&#39;mysql&#39;,&#39;mysql&#39;) | NULLIF(&#39;mysql&#39;, &#39;&#39;) |+-------------------------+---------------------+| NULL | mysql |+-------------------------+---------------------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="4-日期和时间函数"><a href="#4-日期和时间函数" class="headerlink" title="4. 日期和时间函数"></a>4. 日期和时间函数</h2><hr><h3 id="4-1-获取日期、时间"><a href="#4-1-获取日期、时间" class="headerlink" title="4. 1 获取日期、时间"></a>4. 1 获取日期、时间</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>CURDATE() ，CURRENT_DATE()</td><td>返回当前日期，只包含年、月、日</td></tr><tr><td>CURTIME() ， CURRENT_TIME()</td><td>返回当前时间，只包含时、分、秒</td></tr><tr><td>NOW() &#x2F; SYSDATE() &#x2F; CURRENT_TIMESTAMP() &#x2F; LOCALTIME() &#x2F; LOCALTIMESTAMP()</td><td>返回当前系统日期和时间</td></tr><tr><td>UTC_DATE()</td><td>返回UTC（世界标准时间）日期</td></tr><tr><td>UTC_TIME()</td><td>返回UTC（世界标准时间）时间</td></tr></tbody></table><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">SELECTCURDATE(),CURTIME(),NOW(),SYSDATE()+0,UTC_DATE(),UTC_DATE()+0,UTC_TIME(),UTC_TIME()+0FROM DUAL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC07%E7%AB%A0_%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/1649583379441.png" alt="1649583379441"></p><h3 id="4-2-日期与时间戳的转换"><a href="#4-2-日期与时间戳的转换" class="headerlink" title="4. 2 日期与时间戳的转换"></a>4. 2 日期与时间戳的转换</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>UNIX_TIMESTAMP()</td><td>以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP() - &gt;1634348884</td></tr><tr><td>UNIX_TIMESTAMP(date)</td><td>将时间date以UNIX时间戳的形式返回。</td></tr><tr><td>FROM_UNIXTIME(timestamp)</td><td>将UNIX时间戳的时间转换为普通格式的时间</td></tr></tbody></table><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT UNIX_TIMESTAMP(CURTIME());+---------------------------+| UNIX_TIMESTAMP(CURTIME()) |+---------------------------+| 1576380969 |+---------------------------+1 row in set (0.00 sec)mysql&gt; SELECT UNIX_TIMESTAMP(now());+-----------------------+| UNIX_TIMESTAMP(now()) |+-----------------------+| 1576380910 |+-----------------------+1 row in set (0.01 sec)mysql&gt; SELECT UNIX_TIMESTAMP(CURDATE());+---------------------------+| UNIX_TIMESTAMP(CURDATE()) |+---------------------------+| 1576339200 |+---------------------------+1 row in set (0.00 sec)mysql&gt; SELECT UNIX_TIMESTAMP(CURTIME());+---------------------------+| UNIX_TIMESTAMP(CURTIME()) |+---------------------------+| 1576380969 |+---------------------------+1 row in set (0.00 sec)mysql&gt; SELECT UNIX_TIMESTAMP(&#39;2011-11-11 11:11:11&#39;)+---------------------------------------+| UNIX_TIMESTAMP(&#39;2011-11-11 11:11:11&#39;) |+---------------------------------------+| 1320981071 |+---------------------------------------+1 row in set (0.00 sec)mysql&gt; SELECT FROM_UNIXTIME( 1576380910 );+---------------------------+| FROM_UNIXTIME( 1576380910 ) |+---------------------------+| 2019 - 12 - 15 11 :35:10 |+---------------------------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-获取月份、星期、星期数、天数等函数"><a href="#4-3-获取月份、星期、星期数、天数等函数" class="headerlink" title="4. 3 获取月份、星期、星期数、天数等函数"></a>4. 3 获取月份、星期、星期数、天数等函数</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>YEAR(date) &#x2F; MONTH(date) &#x2F; DAY(date)</td><td>返回具体的日期值</td></tr><tr><td>HOUR(time)&#x2F;MINUTE(time)&#x2F;SECOND(time)</td><td>返回具体的时间值</td></tr><tr><td>MONTHNAME(date)</td><td>返回月份：January，…</td></tr><tr><td>DAYNAME(date)</td><td>返回星期几：MONDAY，TUESDAY…..SUNDAY</td></tr><tr><td>WEEKDAY(date)</td><td>返回周几，注意，周1是0，周2是1，…周日是6</td></tr><tr><td>QUARTER(date)</td><td>返回日期对应的季度，范围为 1 ～ 4</td></tr><tr><td>WEEK(date) ， WEEKOFYEAR(date)</td><td>返回一年中的第几周</td></tr><tr><td>DAYOFYEAR(date)</td><td>返回日期是一年中的第几天</td></tr><tr><td>DAYOFMONTH(date)</td><td>返回日期位于所在月份的第几天</td></tr><tr><td>DAYOFWEEK(date)</td><td>返回周几，注意：周日是 1 ，周一是 2 ，…周六是7</td></tr></tbody></table><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">SELECT YEAR(CURDATE()),MONTH(CURDATE()),DAY(CURDATE()),HOUR(CURTIME()),MINUTE(NOW()),SECOND(SYSDATE())FROM DUAL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC07%E7%AB%A0_%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/1649593198654.png" alt="1649593198654"></p><pre class="line-numbers language-none"><code class="language-none">SELECT MONTHNAME(&#39;2021-10-26&#39;),DAYNAME(&#39;2021-10-26&#39;),WEEKDAY(&#39;2021-10-26&#39;),QUARTER(CURDATE()),WEEK(CURDATE()),DAYOFYEAR(NOW()),DAYOFMONTH(NOW()),DAYOFWEEK(NOW())FROM DUAL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC07%E7%AB%A0_%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/1649593240040.png" alt="1649593240040"></p><h3 id="4-4-日期的操作函数"><a href="#4-4-日期的操作函数" class="headerlink" title="4. 4 日期的操作函数"></a>4. 4 日期的操作函数</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>EXTRACT(type FROM date)</td><td>返回指定日期中特定的部分，type指定返回的值</td></tr></tbody></table><p>EXTRACT(type FROM date)函数中type的取值与含义：</p><p><img src="/../pic/%E7%AC%AC07%E7%AB%A0_%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/1649593327456.png" alt="1649593327456"></p><pre class="line-numbers language-none"><code class="language-none">SELECT EXTRACT(MINUTE FROM NOW()),EXTRACT( WEEK FROM NOW()),EXTRACT( QUARTER FROM NOW()),EXTRACT( MINUTE_SECOND FROM NOW())FROM DUAL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-5-时间和秒钟转换的函数"><a href="#4-5-时间和秒钟转换的函数" class="headerlink" title="4. 5 时间和秒钟转换的函数"></a>4. 5 时间和秒钟转换的函数</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>TIME_TO_SEC(time)</td><td>将time转化为秒并返回结果值。转化的公式为：<code>小时 * 3600+分钟 * 60+秒</code></td></tr><tr><td>SEC_TO_TIME(seconds)</td><td>将 seconds 描述转化为包含小时、分钟和秒的时间</td></tr></tbody></table><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT TIME_TO_SEC(NOW());+--------------------+| TIME_TO_SEC(NOW()) |+--------------------+| 78774 |+--------------------+1 row in set (0.00 sec)mysql&gt; SELECT SEC_TO_TIME( 78774 );+--------------------+| SEC_TO_TIME( 78774 ) |+--------------------+| 21 :52:54 |+--------------------+1 row in set (0.12 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-6-计算日期和时间的函数"><a href="#4-6-计算日期和时间的函数" class="headerlink" title="4. 6 计算日期和时间的函数"></a>4. 6 计算日期和时间的函数</h3><p><strong>第 1 组：</strong></p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>DATE_ADD(datetime, INTERVAL expr type)，ADDDATE(date,INTERVAL expr type)</td><td>返回与给定日期时间相差INTERVAL时间段的日期时间</td></tr><tr><td>DATE_SUB(date,INTERVAL expr type)，SUBDATE(date,INTERVAL expr type)</td><td>返回与date相差INTERVAL时间间隔的日期</td></tr></tbody></table><p>上述函数中type的取值：</p><p><img src="/../pic/%E7%AC%AC07%E7%AB%A0_%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/1649593591378.png" alt="1649593591378"></p><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">SELECT DATE_ADD(NOW(), INTERVAL 1 DAY) AS col1,DATE_ADD(&#39;2021-10-21 23:32:12&#39;,INTERVAL 1 SECOND) AS col2,ADDDATE(&#39;2021-10-21 23:32:12&#39;,INTERVAL 1 SECOND) AS col3,DATE_ADD(&#39;2021-10-21 23:32:12&#39;,INTERVAL &#39;1_1&#39; MINUTE_SECOND) AS col4,DATE_ADD(NOW(), INTERVAL - 1 YEAR) AS col5, #可以是负数DATE_ADD(NOW(), INTERVAL &#39;1_1&#39; YEAR_MONTH) AS col6 #需要单引号FROM DUAL;SELECT DATE_SUB(&#39;2021-01-21&#39;,INTERVAL 31 DAY) AS col1,SUBDATE(&#39;2021-01-21&#39;,INTERVAL 31 DAY) AS col2,DATE_SUB(&#39;2021-01-21 02:01:01&#39;,INTERVAL &#39;1 1&#39; DAY_HOUR) AS colFROM DUAL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>第 2 组：</strong></p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>ADDTIME(time1,time2)</td><td>返回time1加上time2的时间。当time2为一个数字时，代表的是<code>秒</code>，可以为负数</td></tr><tr><td>SUBTIME(time1,time2)</td><td>返回time1减去time2后的时间。当time2为一个数字时，代表的是<code>秒</code>，可以为负数</td></tr><tr><td>DATEDIFF(date1,date2)</td><td>返回date1 - date2的日期间隔天数</td></tr><tr><td>TIMEDIFF(time1, time2)</td><td>返回time1 - time2的时间间隔</td></tr><tr><td>FROM_DAYS(N)</td><td>返回从 0000 年 1 月 1 日起，N天以后的日期</td></tr><tr><td>TO_DAYS(date)</td><td>返回日期date距离 0000 年 1 月 1 日的天数</td></tr><tr><td>LAST_DAY(date)</td><td>返回date所在月份的最后一天的日期</td></tr><tr><td>MAKEDATE(year,n)</td><td>针对给定年份与所在年份中的天数返回一个日期</td></tr><tr><td>MAKETIME(hour,minute,second)</td><td>将给定的小时、分钟和秒组合成时间并返回</td></tr><tr><td>PERIOD_ADD(time,n)</td><td>返回time加上n后的时间</td></tr></tbody></table><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">SELECTADDTIME(NOW(),20),SUBTIME(NOW(),30),SUBTIME(NOW(),&#39;1:1:3&#39;),DATEDIFF(NOW(),&#39;2021-10-01&#39;),TIMEDIFF(NOW(),&#39;2021-10-25 22:10:10&#39;),FROM_DAYS( 366 ),TO_DAYS(&#39;0000-12-25&#39;),LAST_DAY(NOW()),MAKEDATE(YEAR(NOW()), 12 ),MAKETIME( 10 , 21 , 23 ),PERIOD_ADD( 20200101010101 ,10 )FROM DUAL;mysql&gt; SELECT ADDTIME(NOW(), 50 );+---------------------+| ADDTIME(NOW(), 50 ) |+---------------------+| 2019 - 12 - 15 22 :17:47 |+---------------------+1 row in set (0.00 sec)mysql&gt; SELECT ADDTIME(NOW(), &#39;1:1:1&#39;);+-------------------------+| ADDTIME(NOW(), &#39;1:1:1&#39;) |+-------------------------+| 2019 - 12 - 15 23 :18:46 |+-------------------------+1 row in set (0.00 sec)mysql&gt; SELECT SUBTIME(NOW(), &#39;1:1:1&#39;);+-------------------------+| SUBTIME(NOW(), &#39;1:1:1&#39;) |+-------------------------+| 2019 - 12 - 15 21 :23:50 |+-------------------------+1 row in set (0.00 sec)mysql&gt; SELECT SUBTIME(NOW(), &#39;-1:-1:-1&#39;);+----------------------------+| SUBTIME(NOW(), &#39;-1:-1:-1&#39;) |+----------------------------+| 2019 - 12 - 15 22 :25:11 |+----------------------------+1 row in set, 1 warning (0.00 sec)mysql&gt; SELECT FROM_DAYS( 366 );+----------------+| FROM_DAYS( 366 ) |+----------------+| 0001 - 01 - 01 |+----------------+1 row in set (0.00 sec)mysql&gt; SELECT MAKEDATE( 2020 , 1 );+------------------+| MAKEDATE( 2020 , 1 ) |+------------------+| 2020 - 01 - 01 |+------------------+1 row in set (0.00 sec)mysql&gt; SELECT MAKEDATE( 2020 , 32 );+-------------------+| MAKEDATE( 2020 , 32 ) |+-------------------+| 2020 - 02 - 01 |+-------------------+1 row in set (0.00 sec)mysql&gt; SELECT MAKETIME( 1 , 1 , 1 );+-----------------+| MAKETIME( 1 , 1 , 1 ) |+-----------------+| 01 :01:01 |+-----------------+1 row in set (0.00 sec)mysql&gt; SELECT PERIOD_ADD( 20200101010101 , 1 );+------------------------------+| PERIOD_ADD( 20200101010101 , 1 ) |+------------------------------+| 20200101010102 |+------------------------------+1 row in set (0.00 sec)mysql&gt; SELECT TO_DAYS(NOW());+----------------+| TO_DAYS(NOW()) |+----------------+| 737773 |+----------------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：查询 7 天内的新增用户数有多少？</p><pre class="line-numbers language-none"><code class="language-none">SELECT COUNT(*) as num FROM new_user WHERE TO_DAYS(NOW())-TO_DAYS(regist_time)&lt;&#x3D;7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-7-日期的格式化与解析"><a href="#4-7-日期的格式化与解析" class="headerlink" title="4. 7 日期的格式化与解析"></a>4. 7 日期的格式化与解析</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>DATE_FORMAT(date,fmt)</td><td>按照字符串fmt格式化日期date值</td></tr><tr><td>TIME_FORMAT(time,fmt)</td><td>按照字符串fmt格式化时间time值</td></tr><tr><td>GET_FORMAT(date_type,format_type)</td><td>返回日期字符串的显示格式</td></tr><tr><td>STR_TO_DATE(str, fmt)</td><td>按照字符串fmt对str进行解析，解析为一个日期</td></tr></tbody></table><p>上述<code>非GET_FORMAT</code>函数中fmt参数常用的格式符：</p><table><thead><tr><th>格式符</th><th>说明</th><th>格式符</th><th>说明</th></tr></thead><tbody><tr><td>%Y</td><td>4 位数字表示年份</td><td>%y</td><td>表示两位数字表示年份</td></tr><tr><td>%M</td><td>月名表示月份（January,….）</td><td>%m</td><td>两位数字表示月份（01,02,03…）</td></tr><tr><td>%b</td><td>缩写的月名（Jan.，Feb.，….）</td><td>%c</td><td>数字表示月份（1,2,3,…）</td></tr><tr><td>%D</td><td>英文后缀表示月中的天数（1st,2nd,3rd,…）</td><td>%d</td><td>两位数字表示月中的天数(01,02…)</td></tr><tr><td>%e</td><td>数字形式表示月中的天数（1,2,3,4,5…..）</td><td></td><td></td></tr><tr><td>%H</td><td>两位数字表示小数， 24 小时制（01,02..）</td><td>%h和%I</td><td>两位数字表示小时， 12 小时制（01,02..）</td></tr><tr><td>%k</td><td>数字形式的小时， 24 小时制(1,2,3)</td><td>%l</td><td>数字形式表示小时， 12 小时制（1,2,3,4….）</td></tr><tr><td>%i</td><td>两位数字表示分钟（00,01,02）</td><td>%S和%s</td><td>两位数字表示秒(00,01,02…)</td></tr><tr><td>%W</td><td>一周中的星期名称（Sunday…）</td><td>%a</td><td>一周中的星期缩写（Sun.，Mon.,Tues.，..）</td></tr><tr><td>%w</td><td>以数字表示周中的天数(0&#x3D;Sunday,1&#x3D;Monday….)</td><td></td><td></td></tr><tr><td>%j</td><td>以 3 位数字表示年中的天数(001,002…)</td><td>%U</td><td>以数字表示年中的第几周，（1,2,3…）其中Sunday为周中第一天</td></tr><tr><td>%u</td><td>以数字表示年中的第几周，（1,2,3…）其中Monday为周中第一天</td><td></td><td></td></tr><tr><td>%T</td><td>24 小时制</td><td>%r</td><td>12 小时制</td></tr><tr><td>%p</td><td>AM或PM</td><td>%%</td><td>表示%</td></tr></tbody></table><p>GET_FORMAT函数中date_type和format_type参数取值如下：</p><p><img src="/../pic/%E7%AC%AC07%E7%AB%A0_%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/1649594840523.png" alt="1649594840523"></p><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT DATE_FORMAT(NOW(), &#39;%H:%i:%s&#39;);+--------------------------------+| DATE_FORMAT(NOW(), &#39;%H:%i:%s&#39;) |+--------------------------------+| 22 :57:34 |+--------------------------------+1 row in set (0.00 sec)SELECT STR_TO_DATE(&#39;09&#x2F;01&#x2F;2009&#39;,&#39;%m&#x2F;%d&#x2F;%Y&#39;)FROM DUAL;SELECT STR_TO_DATE(&#39;20140422154706&#39;,&#39;%Y%m%d%H%i%s&#39;)FROM DUAL;SELECT STR_TO_DATE(&#39;2014-04-22 15:47:06&#39;,&#39;%Y-%m-%d %H:%i:%s&#39;)FROM DUAL;mysql&gt; SELECT GET_FORMAT(DATE, &#39;USA&#39;);+-------------------------+| GET_FORMAT(DATE, &#39;USA&#39;) |+-------------------------+| %m.%d.%Y |+-------------------------+1 row in set (0.00 sec)SELECT DATE_FORMAT(NOW(),GET_FORMAT(DATE,&#39;USA&#39;)),FROM DUAL;mysql&gt; SELECT STR_TO_DATE(&#39;2020-01-01 00:00:00&#39;,&#39;%Y-%m-%d&#39;);+-----------------------------------------------+| STR_TO_DATE(&#39;2020-01-01 00:00:00&#39;,&#39;%Y-%m-%d&#39;) |+-----------------------------------------------+| 2020 - 01 - 01 |+-----------------------------------------------+1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="5-流程控制函数"><a href="#5-流程控制函数" class="headerlink" title="5. 流程控制函数"></a>5. 流程控制函数</h2><hr><p>流程处理函数可以根据不同的条件，执行不同的处理流程，可以在SQL语句中实现不同的条件选择。MySQL中的流程处理函数主要包括IF()、IFNULL()和CASE()函数。</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>IF(value,value1,value2)</td><td>如果value的值为TRUE，返回value1，否则返回value</td></tr><tr><td>IFNULL(value1, value2)</td><td>如果value1不为NULL，返回value1，否则返回value</td></tr><tr><td>CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果 2 …. [ELSE resultn] END</td><td>相当于Java的if…else if…else…</td></tr><tr><td>CASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 …. [ELSE 值n] END</td><td>相当于Java的switch…case…</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">SELECT IF( 1 &gt; 0 ,&#39;正确&#39;,&#39;错误&#39;)-&gt;正确SELECT IFNULL(null,&#39;Hello Word&#39;)-&gt;Hello WordSELECT CASEWHEN 1 &gt; 0THEN &#39;1 &gt; 0&#39;WHEN 2 &gt; 0THEN &#39;2 &gt; 0&#39;ELSE &#39;3 &gt; 0&#39;END-&gt; 1 &gt; 0SELECT CASE 1WHEN 1 THEN &#39;我是1&#39;WHEN 2 THEN &#39;我是2&#39;ELSE &#39;你是谁&#39;SELECT employee_id,salary, CASE WHEN salary&gt;&#x3D; 15000 THEN &#39;高薪&#39;WHEN salary&gt;&#x3D; 10000 THEN &#39;潜力股&#39;WHEN salary&gt;&#x3D; 8000 THEN &#39;屌丝&#39;ELSE &#39;草根&#39; END &quot;描述&quot;FROM employees;SELECT oid,&#96;status&#96;, CASE &#96;status&#96; WHEN 1 THEN &#39;未付款&#39;WHEN 2 THEN &#39;已付款&#39;WHEN 3 THEN &#39;已发货&#39;WHEN 4 THEN &#39;确认收货&#39;ELSE &#39;无效订单&#39; ENDFROM t_order;mysql&gt; SELECT CASE WHEN 1 &gt; 0 THEN &#39;yes&#39; WHEN 1 &lt;&#x3D; 0 THEN &#39;no&#39; ELSE &#39;unknown&#39; END;+---------------------------------------------------------------------+| CASE WHEN 1 &gt; 0 THEN &#39;yes&#39; WHEN 1 &lt;&#x3D; 0 THEN &#39;no&#39; ELSE &#39;unknown&#39; END |+---------------------------------------------------------------------+| yes |+---------------------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; SELECT CASE WHEN 1 &lt; 0 THEN &#39;yes&#39; WHEN 1 &#x3D; 0 THEN &#39;no&#39; ELSE &#39;unknown&#39; END;+--------------------------------------------------------------------+| CASE WHEN 1 &lt; 0 THEN &#39;yes&#39; WHEN 1 &#x3D; 0 THEN &#39;no&#39; ELSE &#39;unknown&#39; END |+--------------------------------------------------------------------+| unknown |+--------------------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; SELECT CASE 1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE - 1 END;+------------------------------------------------+| CASE 1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE - 1 END |+------------------------------------------------+| 1 |+------------------------------------------------+1 row in set (0.00 sec)mysql&gt; SELECT CASE - 1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE - 1 END;+-------------------------------------------------+| CASE - 1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE - 1 END |+-------------------------------------------------+| - 1 |+-------------------------------------------------+1 row in set (0.00 sec)SELECT employee_id, 12 * salary * ( 1 + IFNULL(commission_pct, 0 ))FROM employees;SELECT last_name, job_id, salary,CASE job_id WHEN &#39;IT_PROG&#39; THEN 1.10*salaryWHEN &#39;ST_CLERK&#39; THEN 1.15*salaryWHEN &#39;SA_REP&#39; THEN 1.20*salaryELSE salary END &quot;REVISED_SALARY&quot;FROM employees;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC07%E7%AB%A0_%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/1649595259618.png" alt="1649595259618"></p><p><strong>练习：查询部门号为 10 , 20 , 30 的员工信息, 若部门号为 10 , 则打印其工资的 1. 1 倍, 20 号部门, 则打印其工资的 1. 2 倍, 30 号部门打印其工资的 1. 3 倍数。</strong></p><hr><h2 id="6-加密与解密函数"><a href="#6-加密与解密函数" class="headerlink" title="6. 加密与解密函数"></a>6. 加密与解密函数</h2><hr><p>加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防止数据被他人窃取。这些函数在保证数据库安全时非常有用。</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>PASSWORD(str)</td><td>返回字符串str的加密版本， 41 位长的字符串。加密结果<code>不可逆</code>，常用于用户的密码加密</td></tr><tr><td>MD5(str)</td><td>返回字符串str的md5加密后的值，也是一种加密方式。若参数为NULL，则会返回NULL</td></tr><tr><td>SHA(str)</td><td>从原明文密码str计算并返回加密后的密码字符串，当参数为NULL时，返回NULL。<code>SHA加密算法比MD5更加安全</code>。</td></tr><tr><td>ENCODE(value,password_seed)</td><td>返回使用password_seed作为加密密码加密value</td></tr><tr><td>DECODE(value,password_seed)</td><td>返回使用password_seed作为加密密码解密value</td></tr></tbody></table><p>可以看到，ENCODE(value,password_seed)函数与DECODE(value,password_seed)函数互为反函数。</p><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT PASSWORD(&#39;mysql&#39;), PASSWORD(NULL);+-------------------------------------------+----------------+| PASSWORD(&#39;mysql&#39;) | PASSWORD(NULL) |+-------------------------------------------+----------------+| *E74858DB86EBA20BC33D0AECAE8A8108C56B17FA | |+-------------------------------------------+----------------+1 row in set, 1 warning (0.00 sec)SELECT md5(&#39;123&#39;)-&gt; 202 cb962ac59075b964b07152d234bSELECT SHA(&#39;Tom123&#39;)-&gt;c7c506980abc31cc390a2438c90861d0f1216dmysql&gt; SELECT ENCODE(&#39;mysql&#39;, &#39;mysql&#39;);+--------------------------+| ENCODE(&#39;mysql&#39;, &#39;mysql&#39;) |+--------------------------+| íg ¼ ìÉ |+--------------------------+1 row in set, 1 warning (0.01 sec)mysql&gt; SELECT DECODE(ENCODE(&#39;mysql&#39;,&#39;mysql&#39;),&#39;mysql&#39;);+-----------------------------------------+| DECODE(ENCODE(&#39;mysql&#39;,&#39;mysql&#39;),&#39;mysql&#39;) |+-----------------------------------------+| mysql |+-----------------------------------------+1 row in set, 2 warnings (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="7-MySQL信息函数"><a href="#7-MySQL信息函数" class="headerlink" title="7. MySQL信息函数"></a>7. MySQL信息函数</h2><hr><p>MySQL中内置了一些可以查询MySQL信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地对数据库进行维护工作。</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>VERSION()</td><td>返回当前MySQL的版本号</td></tr><tr><td>CONNECTION_ID()</td><td>返回当前MySQL服务器的连接数</td></tr><tr><td>DATABASE()，SCHEMA()</td><td>返回MySQL命令行当前所在的数据库</td></tr><tr><td>USER()，CURRENT_USER()、SYSTEM_USER()，SESSION_USER()</td><td>返回当前连接MySQL的用户名，返回结果格式为“主机名@用户名”</td></tr><tr><td>CHARSET(value)</td><td>返回字符串value自变量的字符集</td></tr><tr><td>COLLATION(value)</td><td>返回字符串value的比较规则</td></tr></tbody></table><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT DATABASE();+------------+| DATABASE() |+------------+| test |+------------+1 row in set (0.00 sec)mysql&gt; SELECT DATABASE();+------------+| DATABASE() |+------------+| test |+------------+1 row in set (0.00 sec)mysql&gt; SELECT USER(), CURRENT_USER(), SYSTEM_USER(),SESSION_USER();+----------------+----------------+----------------+----------------+| USER() | CURRENT_USER() | SYSTEM_USER() | SESSION_USER() |+----------------+----------------+----------------+----------------+| root@localhost | root@localhost | root@localhost | root@localhost |+----------------+----------------+----------------+----------------+mysql&gt; SELECT CHARSET(&#39;ABC&#39;);+----------------+| CHARSET(&#39;ABC&#39;) |+----------------+| utf8mb4 |+----------------+1 row in set (0.00 sec)mysql&gt; SELECT COLLATION(&#39;ABC&#39;);+--------------------+| COLLATION(&#39;ABC&#39;) |+--------------------+| utf8mb4_general_ci |+--------------------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="8-其他函数"><a href="#8-其他函数" class="headerlink" title="8. 其他函数"></a>8. 其他函数</h2><hr><p>MySQL中有些函数无法对其进行具体的分类，但是这些函数在MySQL的开发和运维过程中也是不容忽视的。</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>FORMAT(value,n)</td><td>返回对数字value进行格式化后的结果数据。n表示四舍五入后保留到小数点后n位</td></tr><tr><td>CONV(value,from,to)</td><td>将value的值进行不同进制之间的转换</td></tr><tr><td>INET_ATON(ipvalue)</td><td>将以点分隔的IP地址转化为一个数字</td></tr><tr><td>INET_NTOA(value)</td><td>将数字形式的IP地址转化为以点分隔的IP地址</td></tr><tr><td>BENCHMARK(n,expr)</td><td>将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费的时间</td></tr><tr><td>CONVERT(value USING char_code)</td><td>将value所使用的字符编码修改为char_code</td></tr></tbody></table><p>举例：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 如果n的值小于或者等于 0 ，则只保留整数部分</span>mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token function">FORMAT</span><span class="token punctuation">(</span><span class="token number">123.123</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">FORMAT</span><span class="token punctuation">(</span><span class="token number">123.523</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">FORMAT</span><span class="token punctuation">(</span><span class="token number">123.123</span><span class="token punctuation">,</span> <span class="token operator">-</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------------+--------------------+---------------------+</span><span class="token operator">|</span> <span class="token function">FORMAT</span><span class="token punctuation">(</span><span class="token number">123.123</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token function">FORMAT</span><span class="token punctuation">(</span><span class="token number">123.523</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token function">FORMAT</span><span class="token punctuation">(</span><span class="token number">123.123</span><span class="token punctuation">,</span> <span class="token operator">-</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------------+--------------------+---------------------+</span><span class="token operator">|</span> <span class="token number">123.12</span> <span class="token operator">|</span> <span class="token number">124</span> <span class="token operator">|</span> <span class="token number">123</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------------+--------------------+---------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> CONV<span class="token punctuation">(</span> <span class="token number">16</span> <span class="token punctuation">,</span> <span class="token number">10</span> <span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> CONV<span class="token punctuation">(</span> <span class="token number">8888</span> <span class="token punctuation">,</span> <span class="token number">10</span> <span class="token punctuation">,</span> <span class="token number">16</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> CONV<span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token number">10</span> <span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-----------------+------------------+-------------------+</span><span class="token operator">|</span> CONV<span class="token punctuation">(</span> <span class="token number">16</span> <span class="token punctuation">,</span> <span class="token number">10</span> <span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token operator">|</span> CONV<span class="token punctuation">(</span> <span class="token number">8888</span> <span class="token punctuation">,</span> <span class="token number">10</span> <span class="token punctuation">,</span> <span class="token number">16</span> <span class="token punctuation">)</span> <span class="token operator">|</span> CONV<span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token number">10</span> <span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------------+------------------+-------------------+</span><span class="token operator">|</span> <span class="token number">10000</span> <span class="token operator">|</span> <span class="token number">22</span> B8 <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------------+------------------+-------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> INET_ATON<span class="token punctuation">(</span><span class="token string">'192.168.1.100'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----------------------------+</span><span class="token operator">|</span> INET_ATON<span class="token punctuation">(</span><span class="token string">'192.168.1.100'</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------------------+</span><span class="token operator">|</span> <span class="token number">3232235876</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span class="token comment"># 以“192.168.1.100”为例，计算方式为 192 乘以 256 的 3 次方，加上 168 乘以 256 的 2 次方，加上 1 乘以 256 ，再加上100 。</span>mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> INET_NTOA<span class="token punctuation">(</span> <span class="token number">3232235876</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-----------------------+</span><span class="token operator">|</span> INET_NTOA<span class="token punctuation">(</span> <span class="token number">3232235876</span> <span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------------------+</span><span class="token operator">|</span> <span class="token number">192.168</span><span class="token number">.1</span><span class="token number">.100</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> BENCHMARK<span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">,</span> MD5<span class="token punctuation">(</span><span class="token string">'mysql'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----------------------------+</span><span class="token operator">|</span> BENCHMARK<span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">,</span> MD5<span class="token punctuation">(</span><span class="token string">'mysql'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------------------+</span><span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> BENCHMARK<span class="token punctuation">(</span> <span class="token number">1000000</span> <span class="token punctuation">,</span> MD5<span class="token punctuation">(</span><span class="token string">'mysql'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----------------------------------+</span><span class="token operator">|</span> BENCHMARK<span class="token punctuation">(</span> <span class="token number">1000000</span> <span class="token punctuation">,</span> MD5<span class="token punctuation">(</span><span class="token string">'mysql'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------------------------+</span><span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.20</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token keyword">CHARSET</span><span class="token punctuation">(</span><span class="token string">'mysql'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">CHARSET</span><span class="token punctuation">(</span><span class="token keyword">CONVERT</span><span class="token punctuation">(</span><span class="token string">'mysql'</span> <span class="token keyword">USING</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">------------------+----------------------------------------+</span><span class="token operator">|</span> <span class="token keyword">CHARSET</span><span class="token punctuation">(</span><span class="token string">'mysql'</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token keyword">CHARSET</span><span class="token punctuation">(</span><span class="token keyword">CONVERT</span><span class="token punctuation">(</span><span class="token string">'mysql'</span> <span class="token keyword">USING</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------+----------------------------------------+</span><span class="token operator">|</span> utf8mb4 <span class="token operator">|</span> utf8 <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------+----------------------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单行函数</title>
      <link href="/2022/07/17/di-08-zhang-ju-he-han-shu/"/>
      <url>/2022/07/17/di-08-zhang-ju-he-han-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="第08章-聚合函数"><a href="#第08章-聚合函数" class="headerlink" title="第08章_聚合函数"></a>第08章_聚合函数</h1><p>我们上一章讲到了 SQL 单行函数。实际上 SQL 函数还有一类，叫做聚合（或聚集、分组）函数，它是对一组数据进行汇总的函数，输入的是一组数据的集合，输出的是单个值。</p><hr><h2 id="1-聚合函数介绍"><a href="#1-聚合函数介绍" class="headerlink" title="1. 聚合函数介绍"></a>1. 聚合函数介绍</h2><hr><ul><li><strong>什么是聚合函数</strong><br>聚合函数作用于一组数据，并对一组数据返回一个值。<br><img src="/../pic/%E7%AC%AC08%E7%AB%A0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/1649596281596.png" alt="1649596281596"></li><li><strong>聚合函数类型</strong><ul><li><strong>AVG()</strong></li><li><strong>SUM()</strong></li><li><strong>MAX()</strong></li><li><strong>MIN()</strong></li><li><strong>COUNT()</strong></li></ul></li><li>聚合函数语法<br><img src="/../pic/%E7%AC%AC08%E7%AB%A0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/1649596348333.png" alt="1649596348333"></li><li>聚合函数不能嵌套调用。比如不能出现类似“AVG(SUM(字段名称))”形式的调用。</li></ul><h3 id="1-1-AVG和SUM函数"><a href="#1-1-AVG和SUM函数" class="headerlink" title="1. 1 AVG和SUM函数"></a>1. 1 AVG和SUM函数</h3><p>可以对<strong>数值型数据</strong>使用AVG 和 SUM 函数。</p><pre class="line-numbers language-none"><code class="language-none">SELECT AVG(salary), MAX(salary),MIN(salary), SUM(salary)FROM employeesWHERE job_id LIKE &#39;%REP%&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC08%E7%AB%A0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/1649596406311.png" alt="1649596406311"></p><h3 id="1-2-MIN和MAX函数"><a href="#1-2-MIN和MAX函数" class="headerlink" title="1. 2 MIN和MAX函数"></a>1. 2 MIN和MAX函数</h3><p>可以对<strong>任意数据类型</strong>的数据使用 MIN 和 MAX 函数。</p><pre class="line-numbers language-none"><code class="language-none">SELECT MIN(hire_date), MAX(hire_date)FROM employees;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC08%E7%AB%A0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/1649596443889.png" alt="1649596443889"></p><h3 id="1-3-COUNT函数"><a href="#1-3-COUNT函数" class="headerlink" title="1. 3 COUNT函数"></a>1. 3 COUNT函数</h3><ul><li><p>COUNT(*)返回表中记录总数，适用于 <strong>任意数据类型</strong> 。</p><pre class="line-numbers language-none"><code class="language-none">SELECT COUNT(*)FROM employeesWHERE department_id &#x3D; 50 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC08%E7%AB%A0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/1649596501327.png" alt="1649596501327"></p></li><li><p>COUNT(expr) 返回 <strong>expr不为空</strong> 的记录总数。</p><pre class="line-numbers language-none"><code class="language-none">SELECT COUNT(commission_pct)FROM employeesWHERE department_id &#x3D; 50 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC08%E7%AB%A0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/1649596547371.png" alt="1649596547371"></p></li><li><p><strong>问题：用count(*)，count(1)，count(列名)谁好呢?</strong></p><p>其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。</p><p>Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。</p></li><li><p><strong>问题：能不能使用count(列名)替换count(*)?</strong></p><p>不要使用 count(列名)来替代 <code>count(*)</code>，<code>count(*)</code>是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。</p><p>说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p></li></ul><hr><h2 id="2-GROUP-BY"><a href="#2-GROUP-BY" class="headerlink" title="2. GROUP BY"></a>2. GROUP BY</h2><hr><h3 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2. 1 基本使用"></a>2. 1 基本使用</h3><p><img src="/../pic/%E7%AC%AC08%E7%AB%A0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/1649596673702.png" alt="1649596673702"></p><p><strong>可以使用GROUP BY子句将表中的数据分成若干组</strong></p><pre class="line-numbers language-none"><code class="language-none">SELECT column, group_function(column)FROM table[WHERE condition][GROUP BY group_by_expression][ORDER BY column];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>明确：WHERE一定放在FROM后面</p></blockquote><p><strong>在SELECT列表中所有未包含在组函数中的列都应该包含在 GROUP BY子句中</strong></p><pre class="line-numbers language-none"><code class="language-none">SELECT department_id, AVG(salary)FROM employeesGROUP BY department_id ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC08%E7%AB%A0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/1649596741150.png" alt="1649596741150"></p><p>包含在 GROUP BY 子句中的列不必包含在SELECT 列表中</p><pre class="line-numbers language-none"><code class="language-none">SELECT AVG(salary)FROM employeesGROUP BY department_id ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC08%E7%AB%A0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/1649596767167.png" alt="1649596767167"></p><h3 id="2-2-使用多个列分组"><a href="#2-2-使用多个列分组" class="headerlink" title="2. 2 使用多个列分组"></a>2. 2 使用多个列分组</h3><p><img src="/../pic/%E7%AC%AC08%E7%AB%A0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/1649596786634.png" alt="1649596786634"></p><pre class="line-numbers language-none"><code class="language-none">SELECT department_id dept_id, job_id, SUM(salary)FROM employeesGROUP BY department_id, job_id ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC08%E7%AB%A0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/1649596807990.png" alt="1649596807990"></p><h3 id="2-3-GROUP-BY中使用WITH-ROLLUP"><a href="#2-3-GROUP-BY中使用WITH-ROLLUP" class="headerlink" title="2. 3 GROUP BY中使用WITH ROLLUP"></a>2. 3 GROUP BY中使用WITH ROLLUP</h3><p>使用<code>WITH ROLLUP</code>关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。</p><pre class="line-numbers language-none"><code class="language-none">SELECT department_id,AVG(salary)FROM employeesWHERE department_id &gt; 80GROUP BY department_id WITH ROLLUP;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><p>当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互相排斥的。</p></blockquote><hr><h2 id="3-HAVING"><a href="#3-HAVING" class="headerlink" title="3. HAVING"></a>3. HAVING</h2><hr><h3 id="3-1-基本使用"><a href="#3-1-基本使用" class="headerlink" title="3. 1 基本使用"></a>3. 1 基本使用</h3><p><img src="/../pic/%E7%AC%AC08%E7%AB%A0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/1649596861486.png" alt="1649596861486"></p><p><strong>过滤分组：HAVING子句</strong></p><ol><li>行已经被分组。</li><li>使用了聚合函数。</li><li>满足HAVING 子句中条件的分组将被显示。</li><li>HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。</li></ol><p><img src="/../pic/%E7%AC%AC08%E7%AB%A0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/1649596894201.png" alt="1649596894201"></p><pre class="line-numbers language-none"><code class="language-none">SELECT department_id, MAX(salary)FROM employeesGROUP BY department_idHAVING MAX(salary)&gt; 10000 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC08%E7%AB%A0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/1649596921091.png" alt="1649596921091"></p><ul><li><p><strong>非法使用聚合函数 ： 不能在 WHERE 子句中使用聚合函数。</strong> 如下：</p><pre class="line-numbers language-none"><code class="language-none">SELECT department_id, AVG(salary)FROM employeesWHERE AVG(salary) &gt; 8000GROUP BY department_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC08%E7%AB%A0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/1649596976574.png" alt="1649596976574"></p></li></ul><h3 id="3-2-WHERE和HAVING的对比"><a href="#3-2-WHERE和HAVING的对比" class="headerlink" title="3. 2 WHERE和HAVING的对比"></a>3. 2 WHERE和HAVING的对比</h3><p><strong>区别 1 ：WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。</strong></p><p>这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为，在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成的。另外，WHERE排除的记录不再包括在分组中。</p><p><strong>区别 2 ：如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接后筛选。</strong> 这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。</p><p>小结如下：</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>WHERE</td><td>先筛选数据再关联，执行效率高</td><td>不能使用分组中的计算函数进行筛选</td></tr><tr><td>HAVING</td><td>可以使用分组中的计算函数</td><td>在最后的结果集中进行筛选，执行效率较低</td></tr></tbody></table><p><strong>开发中的选择：</strong></p><p>WHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组统计函数的条件用 HAVING，普通条件用 WHERE。这样，我们就既利用了 WHERE 条件的高效快速，又发挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别。</p><hr><h2 id="4-SELECT的执行过程"><a href="#4-SELECT的执行过程" class="headerlink" title="4. SELECT的执行过程"></a>4. SELECT的执行过程</h2><hr><h3 id="4-1-查询的结构"><a href="#4-1-查询的结构" class="headerlink" title="4. 1 查询的结构"></a>4. 1 查询的结构</h3><pre class="line-numbers language-none"><code class="language-none">#方式 1 ：SELECT ...,....,...FROM ...,...,....WHERE 多表的连接条件AND 不包含组函数的过滤条件GROUP BY ...,...HAVING 包含组函数的过滤条件ORDER BY ... ASC&#x2F;DESCLIMIT ...,...#方式 2 ：SELECT ...,....,...FROM ... JOIN ...ON 多表的连接条件JOIN ...ON ...WHERE 不包含组函数的过滤条件AND&#x2F;OR 不包含组函数的过滤条件GROUP BY ...,...HAVING 包含组函数的过滤条件ORDER BY ... ASC&#x2F;DESCLIMIT ...,...#其中：#（ 1 ）from：从哪些表中筛选#（ 2 ）on：关联多表查询时，去除笛卡尔积#（ 3 ）where：从表中筛选的条件#（ 4 ）group by：分组依据#（ 5 ）having：在统计结果中再次筛选#（ 6 ）order by：排序#（ 7 ）limit：分页<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-SELECT执行顺序"><a href="#4-2-SELECT执行顺序" class="headerlink" title="4. 2 SELECT执行顺序"></a>4. 2 SELECT执行顺序</h3><p>你需要记住 SELECT 查询时的两个顺序：</p><ol><li><p><strong>关键字的顺序是不能颠倒的：</strong></p><pre class="line-numbers language-none"><code class="language-none">SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>SELECT 语句的执行顺序</strong> （在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：</p><pre class="line-numbers language-none"><code class="language-none">FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT 的字段 -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC08%E7%AB%A0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/1649597182021.png" alt="1649597182021"></p><p>比如你写了一个 SQL 语句，那么它的关键字顺序和执行顺序是下面这样的：</p><pre class="line-numbers language-none"><code class="language-none">SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5FROM player JOIN team ON player.team_id &#x3D; team.team_id # 顺序 1WHERE height &gt; 1.80 # 顺序 2GROUP BY player.team_id # 顺序 3HAVING num &gt; 2 # 顺序 4ORDER BY num DESC # 顺序 6LIMIT 2 # 顺序 7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个<code>虚拟表</code>，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。</p></li></ol><h3 id="4-3-SQL-的执行原理"><a href="#4-3-SQL-的执行原理" class="headerlink" title="4. 3 SQL 的执行原理"></a>4. 3 SQL 的执行原理</h3><p>SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p><ol><li>首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；</li><li>通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；</li><li>添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟<br>表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。</li></ol><p>当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。</p><p>当我们拿到了查询数据表的原始数据，也就是最终的虚拟表 <code>vt1</code>，就可以在此基础上再进行 <code>WHERE 阶段</code>。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表 <code>vt2</code>。</p><p>然后进入第三步和第四步，也就是 <code>GROUP 和 HAVING 阶段</code>。在这个阶段中，实际上是在虚拟表 vt2 的基础上进行分组和分组过滤，得到中间的虚拟表 <code>vt3</code> 和 <code>vt4</code>。</p><p>当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 <code>SELECT 和 DISTINCT</code><br><code>阶段</code>。</p><p>首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表<code>vt5- 1</code> 和 <code>vt5- 2</code> 。</p><p>当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 <code>ORDER BY 阶段</code>，得到虚拟表 <code>vt6</code>。</p><p>最后在 vt6 的基础上，取出指定行的记录，也就是 <code>LIMIT 阶段</code>，得到最终的结果，对应的是虚拟表<code>vt7</code>。</p><p>当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。</p><p>同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的关键字顺序， <strong>所谓底层运行的原理，就是我们刚才讲到的执行顺序。</strong></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子查询</title>
      <link href="/2022/07/17/di-09-zhang-zi-cha-xun/"/>
      <url>/2022/07/17/di-09-zhang-zi-cha-xun/</url>
      
        <content type="html"><![CDATA[<h1 id="第09章-子查询"><a href="#第09章-子查询" class="headerlink" title="第09章_子查询"></a>第09章_子查询</h1><p> 2022-04-13   2022-04-21   <a href="https://new-wangz.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">技术博客</a>   293   <a href="https://new-wangz.github.io/2022/04/13/%E7%AC%AC09%E7%AB%A0-%E5%AD%90%E6%9F%A5%E8%AF%A2/#valine-comments">0</a></p><p>子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MySQL 4. 1 开始引入。</p><p>SQL 中子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。</p><hr><h2 id="1-需求分析与问题解决"><a href="#1-需求分析与问题解决" class="headerlink" title="1. 需求分析与问题解决"></a>1. 需求分析与问题解决</h2><hr><h3 id="1-1-实际问题"><a href="#1-1-实际问题" class="headerlink" title="1. 1 实际问题"></a>1. 1 实际问题</h3><p><img src="/../pic/%E7%AC%AC09%E7%AB%A0_%E5%AD%90%E6%9F%A5%E8%AF%A2/1649735856507.png" alt="1649735856507"></p><p>现有解决方式：</p><pre class="line-numbers language-none"><code class="language-none">#方式一：SELECT salaryFROM employeesWHERE last_name &#x3D; &#39;Abel&#39;;SELECT last_name,salaryFROM employeesWHERE salary &gt; 11000 ;#方式二：自连接SELECT e2.last_name,e2.salaryFROM employees e1,employees eWHERE e1.last_name &#x3D; &#39;Abel&#39;AND e1.&#96;salary&#96; &lt; e2.&#96;salary&#96;#方式三：子查询SELECT last_name,salaryFROM employeesWHERE salary &gt; (SELECT salaryFROM employeesWHERE last_name &#x3D; &#39;Abel&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC09%E7%AB%A0_%E5%AD%90%E6%9F%A5%E8%AF%A2/1649735942771.png" alt="1649735942771"></p><h3 id="1-2-子查询的基本使用"><a href="#1-2-子查询的基本使用" class="headerlink" title="1. 2 子查询的基本使用"></a>1. 2 子查询的基本使用</h3><ul><li>子查询的基本语法结构：<br><img src="/../pic/%E7%AC%AC09%E7%AB%A0_%E5%AD%90%E6%9F%A5%E8%AF%A2/1649735994111.png" alt="1649735994111"></li><li>子查询（内查询）在主查询之前一次执行完成。</li><li>子查询的结果被主查询（外查询）使用 。</li><li><strong>注意事项</strong><ul><li>子查询要包含在括号内</li><li>将子查询放在比较条件的右侧</li><li>单行操作符对应单行子查询，多行操作符对应多行子查询</li></ul></li></ul><h3 id="1-3-子查询的分类"><a href="#1-3-子查询的分类" class="headerlink" title="1. 3 子查询的分类"></a>1. 3 子查询的分类</h3><p><strong>分类方式 1 ：</strong></p><p>我们按内查询的结果返回一条还是多条记录，将子查询分为单行子查询、多行子查询。</p><ul><li>单行子查询<br><img src="/../pic/%E7%AC%AC09%E7%AB%A0_%E5%AD%90%E6%9F%A5%E8%AF%A2/1649736047195.png" alt="1649736047195"></li><li>多行子查询<br><img src="/../pic/%E7%AC%AC09%E7%AB%A0_%E5%AD%90%E6%9F%A5%E8%AF%A2/1649736060060.png" alt="1649736060060"></li></ul><p><strong>分类方式 2 ：</strong></p><p>我们按内查询是否被执行多次，将子查询划分为相关(或关联)子查询和不相关(或非关联)子查询。</p><p>子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询。</p><p>同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询。</p><hr><h2 id="2-单行子查询"><a href="#2-单行子查询" class="headerlink" title="2. 单行子查询"></a>2. 单行子查询</h2><hr><h3 id="2-1-单行比较操作符"><a href="#2-1-单行比较操作符" class="headerlink" title="2. 1 单行比较操作符"></a>2. 1 单行比较操作符</h3><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>&#x3D;</td><td>equal to</td></tr><tr><td>&gt;</td><td>greater than</td></tr><tr><td>&gt;&#x3D;</td><td>greater than or equal to</td></tr><tr><td>&lt;</td><td>less than</td></tr><tr><td>&lt;&#x3D;</td><td>less than or equal to</td></tr><tr><td>&lt;&gt;</td><td>not equal to</td></tr></tbody></table><h3 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2. 2 代码示例"></a>2. 2 代码示例</h3><p><strong>题目：查询工资大于 149 号员工工资的员工的信息</strong></p><p><img src="/../pic/%E7%AC%AC09%E7%AB%A0_%E5%AD%90%E6%9F%A5%E8%AF%A2/1649736296795.png" alt="1649736296795"></p><p><strong>题目：返回job_id与 141 号员工相同，salary比 143 号员工多的员工姓名，job_id和工资</strong></p><pre class="line-numbers language-none"><code class="language-none">SELECT last_name, job_id, salaryFROM employeesWHERE job_id &#x3D;(SELECT job_idFROM employeesWHERE employee_id &#x3D; 141 )AND salary &gt;(SELECT salaryFROM employeesWHERE employee_id &#x3D; 143 );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC09%E7%AB%A0_%E5%AD%90%E6%9F%A5%E8%AF%A2/1649736368868.png" alt="1649736368868"></p><p><strong>题目：返回公司工资最少的员工的last_name,job_id和salary</strong></p><pre class="line-numbers language-none"><code class="language-none">SELECT last_name, job_id, salaryFROM employeesWHERE salary &#x3D;(SELECT MIN(salary)FROM employees);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC09%E7%AB%A0_%E5%AD%90%E6%9F%A5%E8%AF%A2/1649736429130.png" alt="1649736429130"></p><p><strong>题目：查询与 141 号或 174 号员工的manager_id和department_id相同的其他员工的employee_id，manager_id，department_id</strong></p><p>实现方式 1 ：不成对比较</p><pre class="line-numbers language-none"><code class="language-none">SELECT employee_id, manager_id, department_idFROM employeesWHERE manager_id IN(SELECT manager_idFROM employeesWHERE employee_id IN (174,141))AND department_id IN(SELECT department_idFROM employeesWHERE employee_id IN (174,141))AND employee_id NOT IN(174,141);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现方式 2 ：成对比较</p><pre class="line-numbers language-none"><code class="language-none">SELECT employee_id, manager_id, department_idFROM employeesWHERE (manager_id, department_id) IN(SELECT manager_id, department_idFROM employeesWHERE employee_id IN (141,174))AND employee_id NOT IN (141,174);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-HAVING-中的子查询"><a href="#2-3-HAVING-中的子查询" class="headerlink" title="2. 3 HAVING 中的子查询"></a>2. 3 HAVING 中的子查询</h3><ul><li>首先执行子查询。</li><li>向主查询中的HAVING 子句返回结果。</li></ul><p><strong>题目：查询最低工资大于 50 号部门最低工资的部门id和其最低工资</strong></p><pre class="line-numbers language-none"><code class="language-none">SELECT department_id, MIN(salary)FROM employeesGROUP BY department_idHAVING MIN(salary) &gt;(SELECT MIN(salary)FROM employeesWHERE department_id &#x3D; 50 );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-CASE中的子查询"><a href="#2-4-CASE中的子查询" class="headerlink" title="2. 4 CASE中的子查询"></a>2. 4 CASE中的子查询</h3><p>在CASE表达式中使用单列子查询：</p><p><strong>题目：显式员工的employee_id,last_name和location。其中，若员工department_id与location_id为 1800的department_id相同，则location为’Canada’，其余则为’USA’。</strong></p><pre class="line-numbers language-none"><code class="language-none">SELECT employee_id, last_name,(CASE department_idWHEN(SELECT department_id FROM departments WHERE location_id &#x3D; 1800)THEN &#39;Canada&#39; ELSE &#39;USA&#39; END) locationFROM employees;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-子查询中的空值问题"><a href="#2-5-子查询中的空值问题" class="headerlink" title="2. 5 子查询中的空值问题"></a>2. 5 子查询中的空值问题</h3><pre class="line-numbers language-none"><code class="language-none">SELECT last_name, job_idFROM employeesWHERE job_id &#x3D;(SELECT job_idFROM employeesWHERE last_name &#x3D; &#39;Haas&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC09%E7%AB%A0_%E5%AD%90%E6%9F%A5%E8%AF%A2/1649736722995.png" alt="1649736722995"></p><blockquote><p><strong>子查询不返回任何行</strong></p></blockquote><h3 id="2-5-非法使用子查询"><a href="#2-5-非法使用子查询" class="headerlink" title="2. 5 非法使用子查询"></a>2. 5 非法使用子查询</h3><pre class="line-numbers language-none"><code class="language-none">SELECT employee_id, last_nameFROM employeesWHERE salary &#x3D;(SELECT MIN(salary)FROM employeesGROUP BY department_id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC09%E7%AB%A0_%E5%AD%90%E6%9F%A5%E8%AF%A2/1649736764017.png" alt="1649736764017"></p><blockquote><p><strong>多行子查询使用单行比较符</strong></p></blockquote><hr><h2 id="3-多行子查询"><a href="#3-多行子查询" class="headerlink" title="3. 多行子查询"></a>3. 多行子查询</h2><hr><ul><li>也称为集合比较子查询</li><li>内查询返回多行</li><li>使用多行比较操作符</li></ul><h3 id="3-1-多行比较操作符"><a href="#3-1-多行比较操作符" class="headerlink" title="3. 1 多行比较操作符"></a>3. 1 多行比较操作符</h3><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>IN</td><td>等于列表中的<strong>任意一个</strong></td></tr><tr><td>ANY</td><td>需要和单行比较操作符一起使用，和子查询返回的 <strong>某一个</strong> 值比较</td></tr><tr><td>ALL</td><td>需要和单行比较操作符一起使用，和子查询返回的 <strong>所有</strong> 值比较</td></tr><tr><td>SOME</td><td>实际上是ANY的别名，作用相同，一般常使用ANY</td></tr></tbody></table><blockquote><p>体会 ANY 和 ALL 的区别</p></blockquote><h3 id="3-2-代码示例"><a href="#3-2-代码示例" class="headerlink" title="3. 2 代码示例"></a>3. 2 代码示例</h3><p><strong>题目：返回其它job_id中比job_id为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及salary</strong></p><p><img src="/../pic/%E7%AC%AC09%E7%AB%A0_%E5%AD%90%E6%9F%A5%E8%AF%A2/1649736935733.png" alt="1649736935733"></p><p><strong>题目：返回其它job_id中比job_id为‘IT_PROG’部门所有工资都低的员工的员工号、姓名、job_id以及salary</strong></p><p><img src="/../pic/%E7%AC%AC09%E7%AB%A0_%E5%AD%90%E6%9F%A5%E8%AF%A2/1649736957180.png" alt="1649736957180"></p><p><strong>题目：查询平均工资最低的部门id</strong></p><pre class="line-numbers language-none"><code class="language-none">#方式 1 ：SELECT department_idFROM employeesGROUP BY department_idHAVING AVG(salary) &#x3D; (SELECT MIN(avg_sal)FROM (SELECT AVG(salary) avg_salFROM employeesGROUP BY department_id) dept_avg_sal)#方式 2 ：SELECT department_idFROM employeesGROUP BY department_idHAVING AVG(salary) &lt;&#x3D; ALL (SELECT AVG(salary) avg_salFROM employeesGROUP BY department_id)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-空值问题"><a href="#3-3-空值问题" class="headerlink" title="3. 3 空值问题"></a>3. 3 空值问题</h3><pre class="line-numbers language-none"><code class="language-none">SELECT last_nameFROM employeesWHERE employee_id NOT IN (SELECT manager_idFROM employees);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC09%E7%AB%A0_%E5%AD%90%E6%9F%A5%E8%AF%A2/1649737066253.png" alt="1649737066253"></p><hr><h2 id="4-相关子查询"><a href="#4-相关子查询" class="headerlink" title="4. 相关子查询"></a>4. 相关子查询</h2><hr><h3 id="4-1-相关子查询执行流程"><a href="#4-1-相关子查询执行流程" class="headerlink" title="4. 1 相关子查询执行流程"></a>4. 1 相关子查询执行流程</h3><p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为<code>关联子查询</code>。</p><p>相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。</p><p><img src="/../pic/%E7%AC%AC09%E7%AB%A0_%E5%AD%90%E6%9F%A5%E8%AF%A2/1649737164128.png" alt="1649737164128"></p><p>说明： <strong>子查询中使用主查询中的列</strong></p><h3 id="4-2-代码示例"><a href="#4-2-代码示例" class="headerlink" title="4. 2 代码示例"></a>4. 2 代码示例</h3><p><strong>题目：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id</strong></p><p><strong>方式一：相关子查询</strong></p><p><img src="/../pic/%E7%AC%AC09%E7%AB%A0_%E5%AD%90%E6%9F%A5%E8%AF%A2/1649737188999.png" alt="1649737188999"></p><p><strong>方式二：在 FROM 中使用子查询</strong></p><pre class="line-numbers language-none"><code class="language-none">SELECT last_name,salary,e1.department_idFROM employees e1,(SELECT department_id,AVG(salary) dept_avg_sal FROM employees GROUPBY department_id) eWHERE e1.&#96;department_id&#96; &#x3D; e2.department_idAND e2.dept_avg_sal &lt; e1.&#96;salary&#96;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>from型的子查询：子查询是作为from的一部分，子查询要用()引起来，并且要给这个子查询取别名， 把它当成一张“临时的虚拟的表”来使用。</p></blockquote><p>在ORDER BY 中使用子查询：</p><p><strong>题目：查询员工的id,salary,按照department_name 排序</strong></p><pre class="line-numbers language-none"><code class="language-none">SELECT employee_id,salaryFROM employees eORDER BY (SELECT department_nameFROM departments dWHERE e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>题目：若employees表中employee_id与job_history表中employee_id相同的数目不小于 2 ，输出这些相同id的员工的employee_id,last_name和其job_id</strong></p><pre class="line-numbers language-none"><code class="language-none">SELECT e.employee_id, last_name,e.job_idFROM employees eWHERE 2 &lt;&#x3D; (SELECT COUNT(*)FROM job_historyWHERE employee_id &#x3D; e.employee_id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-EXISTS-与-NOT-EXISTS关键字"><a href="#4-3-EXISTS-与-NOT-EXISTS关键字" class="headerlink" title="4. 3 EXISTS 与 NOT EXISTS关键字"></a>4. 3 EXISTS 与 NOT EXISTS关键字</h3><ul><li>关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。</li><li><strong>如果在子查询中不存在满足条件的行：</strong><ul><li>条件返回 FALSE</li><li>继续在子查询中查找</li></ul></li><li><strong>如果在子查询中存在满足条件的行：</strong><ul><li>不在子查询中继续查找</li><li>条件返回 TRUE</li></ul></li><li>NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。</li></ul><p><strong>题目：查询公司管理者的employee_id，last_name，job_id，department_id信息</strong></p><p>方式一：</p><pre class="line-numbers language-none"><code class="language-none">SELECT employee_id, last_name, job_id, department_idFROM employees eWHERE EXISTS ( SELECT *FROM employees eWHERE e2.manager_id &#x3D;e1.employee_id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方式二：自连接</p><pre class="line-numbers language-none"><code class="language-none">SELECT DISTINCT e1.employee_id, e1.last_name, e1.job_id, e1.department_idFROM employees e1 JOIN employees eWHERE e1.employee_id &#x3D; e2.manager_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>方式三：</p><pre class="line-numbers language-none"><code class="language-none">SELECT employee_id,last_name,job_id,department_idFROM employeesWHERE employee_id IN (SELECT DISTINCT manager_idFROM employees);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>题目：查询departments表中，不存在于employees表中的部门的department_id和department_name</strong></p><pre class="line-numbers language-none"><code class="language-none">SELECT department_id, department_nameFROM departments dWHERE NOT EXISTS (SELECT &#39;X&#39;FROM employeesWHERE department_id &#x3D; d.department_id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC09%E7%AB%A0_%E5%AD%90%E6%9F%A5%E8%AF%A2/1649737493094.png" alt="1649737493094"></p><h3 id="4-4-相关更新"><a href="#4-4-相关更新" class="headerlink" title="4. 4 相关更新"></a>4. 4 相关更新</h3><pre class="line-numbers language-none"><code class="language-none">UPDATE table1 aliasSET column &#x3D; (SELECT expressionFROM table2 aliasWHERE alias1.column &#x3D; alias2.column);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用相关子查询依据一个表中的数据更新另一个表的数据。</p><p><strong>题目：在employees中增加一个department_name字段，数据为员工对应的部门名称</strong></p><pre class="line-numbers language-none"><code class="language-none"># 1）ALTER TABLE employeesADD(department_name VARCHAR2( 14 ));# 2）UPDATE employees eSET department_name &#x3D; (SELECT department_nameFROM departments dWHERE e.department_id &#x3D; d.department_id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-相关删除"><a href="#4-4-相关删除" class="headerlink" title="4. 4 相关删除"></a>4. 4 相关删除</h3><pre class="line-numbers language-none"><code class="language-none">DELETE FROM table1 aliasWHERE column operator (SELECT expressionFROM table2 aliasWHERE alias1.column &#x3D; alias2.column);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用相关子查询依据一个表中的数据删除另一个表的数据。</p><p><strong>题目：删除表employees中，其与emp_history表皆有的数据</strong></p><pre class="line-numbers language-none"><code class="language-none">DELETE FROM employees eWHERE employee_id in(SELECT employee_idFROM emp_historyWHERE employee_id &#x3D; e.employee_id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="5-抛一个思考题"><a href="#5-抛一个思考题" class="headerlink" title="5. 抛一个思考题"></a>5. 抛一个思考题</h2><hr><p><strong>问题：</strong> 谁的工资比Abel的高？</p><p><strong>解答：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#方式 1 ：自连接</span><span class="token keyword">SELECT</span> e2<span class="token punctuation">.</span>last_name<span class="token punctuation">,</span>e2<span class="token punctuation">.</span>salary<span class="token keyword">FROM</span> employees e1<span class="token punctuation">,</span>employees e<span class="token keyword">WHERE</span> e1<span class="token punctuation">.</span>last_name <span class="token operator">=</span> <span class="token string">'Abel'</span><span class="token operator">AND</span> e1<span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>salary<span class="token punctuation">`</span></span> <span class="token operator">&lt;</span> e2<span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>salary<span class="token punctuation">`</span></span><span class="token comment">#方式 2 ：子查询</span><span class="token keyword">SELECT</span> last_name<span class="token punctuation">,</span>salary<span class="token keyword">FROM</span> employees<span class="token keyword">WHERE</span> salary <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> salary<span class="token keyword">FROM</span> employees<span class="token keyword">WHERE</span> last_name <span class="token operator">=</span> <span class="token string">'Abel'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>问题：</strong> 以上两种方式有好坏之分吗？</p><p><strong>解答：</strong> 自连接方式好！</p><p>题目中可以使用子查询，也可以使用自连接。一般情况建议你使用自连接，因为在许多 DBMS 的处理过程中，对于自连接的处理速度要比子查询快得多。</p><p>可以这样理解：子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表进行条件判断，因此在大部分 DBMS 中都对自连接处理进行了优化。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建和管理表</title>
      <link href="/2022/07/17/di-10-zhang-chuang-jian-he-guan-li-biao/"/>
      <url>/2022/07/17/di-10-zhang-chuang-jian-he-guan-li-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="第10章-创建和管理表"><a href="#第10章-创建和管理表" class="headerlink" title="第10章_创建和管理表"></a>第10章_创建和管理表</h1><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><hr><h3 id="1-1-一条数据存储的过程"><a href="#1-1-一条数据存储的过程" class="headerlink" title="1. 1 一条数据存储的过程"></a>1. 1 一条数据存储的过程</h3><p><code>存储数据是处理数据的第一步</code>。只有正确地把数据存储起来，我们才能进行有效的处理和分析。否则，只能是一团乱麻，无从下手。</p><p>那么，怎样才能把用户各种经营相关的、纷繁复杂的数据，有序、高效地存储起来呢？ 在 MySQL 中，一个完整的数据存储过程总共有 4 步，分别是创建数据库、确认字段、创建数据表、插入数据。</p><p><img src="/../pic/%E7%AC%AC10%E7%AB%A0_%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/1649847838505.png" alt="1649847838505"></p><p>我们要先创建一个数据库，而不是直接创建数据表呢？</p><p>因为从系统架构的层次上看，MySQL 数据库系统从大到小依次是<code>数据库服务器</code>、<code>数据库</code>、<code>数据表</code>、<code>数据表的行与列</code>。</p><p>MySQL 数据库服务器之前已经安装。所以，我们就从创建数据库开始。</p><h3 id="1-2-标识符命名规则"><a href="#1-2-标识符命名规则" class="headerlink" title="1. 2 标识符命名规则"></a>1. 2 标识符命名规则</h3><ul><li>数据库名、表名不得超过 30 个字符，变量名限制为 29 个</li><li>必须只能包含 A–Z, a–z, 0 – 9 , _共 63 个字符</li><li>数据库名、表名、字段名等对象名中间不要包含空格</li><li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li><li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用&#96;（着重号）引起来</li><li>保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li></ul><h3 id="1-3-MySQL中的数据类型"><a href="#1-3-MySQL中的数据类型" class="headerlink" title="1. 3 MySQL中的数据类型"></a>1. 3 MySQL中的数据类型</h3><table><thead><tr><th>类型</th><th>类型举例</th></tr></thead><tbody><tr><td>整数类型</td><td>TINYINT、SMALLINT、MEDIUMINT、 <strong>INT(或INTEGER)</strong> 、BIGINT</td></tr><tr><td>浮点类型</td><td>FLOAT、DOUBLE</td></tr><tr><td>定点数类型</td><td><strong>DECIMAL</strong></td></tr><tr><td>位类型</td><td>BIT</td></tr><tr><td>日期时间类型</td><td>YEAR、TIME、 <strong>DATE</strong> 、DATETIME、TIMESTAMP</td></tr><tr><td>文本字符串类型</td><td>CHAR、 <strong>VARCHAR</strong> 、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td></tr><tr><td>枚举类型</td><td>ENUM</td></tr><tr><td>集合类型</td><td>SET</td></tr><tr><td>二进制字符串类型</td><td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td></tr><tr><td>JSON类型</td><td>JSON对象、JSON数组</td></tr><tr><td>空间数据类型</td><td>单值：GEOMETRY、POINT、LINESTRING、POLYGON； 集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</td></tr></tbody></table><p>其中，常用的几类类型介绍如下：</p><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>INT</td><td>从-2^31到2^31-1的整型数据。存储大小为 4 个字节</td></tr><tr><td>CHAR(size)</td><td>定长字符数据。若未指定，默认为 1 个字符，最大长度 255</td></tr><tr><td>VARCHAR(size)</td><td>可变长字符数据，根据字符串实际长度保存， 必须指定长度</td></tr><tr><td>FLOAT(M,D)</td><td>单精度，占用 4 个字节，M&#x3D;整数位+小数位，D&#x3D;小数位。 D&lt;&#x3D;M&lt;&#x3D;255,0&lt;&#x3D;D&lt;&#x3D;30，默认M+D&lt;&#x3D;6</td></tr><tr><td>DOUBLE(M,D)</td><td>双精度，占用 8 个字节，D&lt;&#x3D;M&lt;&#x3D;255,0&lt;&#x3D;D&lt;&#x3D;30，默认M+D&lt;&#x3D;15</td></tr><tr><td>DECIMAL(M,D)</td><td>高精度小数，占用M+2个字节，D&lt;&#x3D;M&lt;&#x3D;65，0&lt;&#x3D;D&lt;&#x3D;30，最大取值范围与DOUBLE相同。</td></tr><tr><td>DATE</td><td>日期型数据，格式’YYYY-MM-DD’</td></tr><tr><td>BLOB</td><td>二进制形式的长文本数据，最大可达4G</td></tr><tr><td>TEXT</td><td>长文本数据，最大可达4G</td></tr></tbody></table><hr><h2 id="2-创建和管理数据库"><a href="#2-创建和管理数据库" class="headerlink" title="2. 创建和管理数据库"></a>2. 创建和管理数据库</h2><hr><h3 id="2-1-创建数据库"><a href="#2-1-创建数据库" class="headerlink" title="2. 1 创建数据库"></a>2. 1 创建数据库</h3><ul><li><p>方式 1 ：创建数据库</p><pre class="line-numbers language-none"><code class="language-none">CREATE DATABASE 数据库名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>方式 2 ：创建数据库并指定字符集</p><pre class="line-numbers language-none"><code class="language-none">CREATE DATABASE 数据库名 CHARACTER SET 字符集;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>方式 3 ：判断数据库是否已经存在，不存在则创建数据库（推荐）</p><pre class="line-numbers language-none"><code class="language-none">CREATE DATABASE IF NOT EXISTS 数据库名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>如果MySQL中已经存在相关的数据库，则忽略创建语句，不再创建数据库。</p><blockquote><p>注意：DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的。</p></blockquote><h3 id="2-2-使用数据库"><a href="#2-2-使用数据库" class="headerlink" title="2. 2 使用数据库"></a>2. 2 使用数据库</h3><ul><li><p>查看当前所有的数据库</p><pre class="line-numbers language-none"><code class="language-none">SHOW DATABASES; #有一个S，代表多个数据库<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看当前正在使用的数据库</p><pre class="line-numbers language-none"><code class="language-none">SELECT DATABASE();  #使用的一个 mysql 中的全局函数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看指定库下所有的表</p><pre class="line-numbers language-none"><code class="language-none">SHOW TABLES FROM 数据库名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看数据库的创建信息</p><pre class="line-numbers language-none"><code class="language-none">SHOW CREATE DATABASE 数据库名;或者：SHOW CREATE DATABASE 数据库名\G<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>使用&#x2F;切换数据库</p><pre class="line-numbers language-none"><code class="language-none">USE 数据库名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><blockquote><p>注意：要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数据库名.”。</p></blockquote><h3 id="2-3-修改数据库"><a href="#2-3-修改数据库" class="headerlink" title="2. 3 修改数据库"></a>2. 3 修改数据库</h3><ul><li><p>更改数据库字符集</p><pre class="line-numbers language-none"><code class="language-none">ALTER DATABASE 数据库名 CHARACTER SET 字符集;  #比如：gbk、utf8等<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="2-4-删除数据库"><a href="#2-4-删除数据库" class="headerlink" title="2. 4 删除数据库"></a>2. 4 删除数据库</h3><ul><li><p>方式 1 ：删除指定的数据库</p><pre class="line-numbers language-none"><code class="language-none">DROP DATABASE 数据库名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>方式 2 ：删除指定的数据库（<code>推荐</code>）</p><pre class="line-numbers language-none"><code class="language-none">DROP DATABASE IF EXISTS 数据库名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><h2 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3. 创建表"></a>3. 创建表</h2><hr><h3 id="3-1-创建方式-1"><a href="#3-1-创建方式-1" class="headerlink" title="3. 1 创建方式 1"></a>3. 1 创建方式 1</h3><ul><li><p><strong>必须具备：</strong></p><ul><li>CREATE TABLE权限</li><li>存储空间</li></ul></li><li><p><strong>语法格式：</strong></p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE [IF NOT EXISTS] 表名(字段1, 数据类型 [约束条件] [默认值],字段2, 数据类型 [约束条件] [默认值],字段3, 数据类型 [约束条件] [默认值],......[表约束条件]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。</p></blockquote><ul><li><p><strong>必须指定：</strong></p><ul><li>表名</li><li>列名(或字段名)，数据类型， 长度</li></ul></li><li><p><strong>可选指定：</strong></p><ul><li>约束条件</li><li>默认值</li></ul></li><li><p>创建表举例 1 ：</p><pre class="line-numbers language-none"><code class="language-none">-- 创建表CREATE TABLE emp (-- int类型emp_id INT,-- 最多保存 20 个中英文字符emp_name VARCHAR( 20 ),-- 总位数不超过 15 位salary DOUBLE,-- 日期类型birthday DATE);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">DESC emp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC10%E7%AB%A0_%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/1649848963202.png" alt="1649848963202"></p><p>MySQL在执行建表语句时，将id字段的类型设置为int(11)，这里的 11 实际上是int类型指定的显示宽度，默认的显示宽度为 11 。也可以在创建数据表的时候指定数据的显示宽度。</p></li><li><p>创建表举例 2 ：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE dept(-- int类型，自增deptno INT( 2 ) AUTO_INCREMENT,dname VARCHAR( 14 ),loc VARCHAR( 13 ),-- 主键PRIMARY KEY (deptno));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">DESCRIBE dept;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC10%E7%AB%A0_%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/1649849045513.png" alt="1649849045513"></p></li></ul><blockquote><p>在MySQL 8.x版本中，不再推荐为INT类型指定显示长度，并在未来的版本中可能去掉这样的语法。</p></blockquote><h3 id="3-2-创建方式-2"><a href="#3-2-创建方式-2" class="headerlink" title="3. 2 创建方式 2"></a>3. 2 创建方式 2</h3><ul><li><p>使用 AS subquery 选项， <strong>将创建表和插入数据结合起来</strong><br><img src="/../pic/%E7%AC%AC10%E7%AB%A0_%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/1649849100222.png" alt="1649849100222"></p></li><li><p>指定的列和子查询中的列要一一对应</p></li><li><p>通过列名和默认值定义列</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE emp1 AS SELECT * FROM employees;CREATE TABLE emp2 AS SELECT * FROM employees WHERE 1 &#x3D; 2 ; -- 创建的emp2是空表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE deptASSELECT employee_id, last_name, salary* 12 ANNSAL, hire_dateFROM employeesWHERE department_id &#x3D; 80 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">DESCRIBE dept80;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC10%E7%AB%A0_%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/1649849177597.png" alt="1649849177597"></p></li></ul><h3 id="3-3-查看数据表结构"><a href="#3-3-查看数据表结构" class="headerlink" title="3. 3 查看数据表结构"></a>3. 3 查看数据表结构</h3><p>在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用<code>DESCRIBE/DESC</code>语句查看数据表结构，也支持使用<code>SHOW CREATE TABLE</code>语句查看数据表结构。</p><p>语法格式如下：</p><pre class="line-numbers language-none"><code class="language-none">SHOW CREATE TABLE 表名\G<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用SHOW CREATE TABLE语句不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码。</p><hr><h2 id="4-修改表"><a href="#4-修改表" class="headerlink" title="4. 修改表"></a>4. 修改表</h2><hr><p>修改表指的是修改数据库中已经存在的数据表的结构。</p><p><strong>使用 ALTER TABLE 语句可以实现：</strong></p><ul><li>向已有的表中添加列</li><li>修改现有表中的列</li><li>删除现有表中的列</li><li>重命名现有表中的列</li></ul><h3 id="4-1-追加一个列"><a href="#4-1-追加一个列" class="headerlink" title="4. 1 追加一个列"></a>4. 1 追加一个列</h3><p>语法格式如下：</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE 表名 ADD 【COLUMN】 字段名 字段类型 【FIRST|AFTER 字段名】;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE deptADD job_id varchar( 15 );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC10%E7%AB%A0_%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/1649849274899.png" alt="1649849274899"></p><h3 id="4-2-修改一个列"><a href="#4-2-修改一个列" class="headerlink" title="4. 2 修改一个列"></a>4. 2 修改一个列</h3><ul><li><p>可以修改列的数据类型，长度、默认值和位置</p></li><li><p>修改字段数据类型、长度、默认值、位置的语法格式如下：</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE 表名 MODIFY 【COLUMN】 字段名 1 字段类型 【DEFAULT 默认值】【FIRST|AFTER 字段名2】;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE deptMODIFY last_name VARCHAR( 30 );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE deptMODIFY salary double( 9 , 2 ) default 1000 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>对默认值的修改只影响今后对表的修改</p></li><li><p>此外，还可以通过此种方式修改列的约束。这里暂先不讲。</p></li></ul><h3 id="4-3-重命名一个列"><a href="#4-3-重命名一个列" class="headerlink" title="4. 3 重命名一个列"></a>4. 3 重命名一个列</h3><p>使用 CHANGE old_column new_column dataType子句重命名列。语法格式如下：</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE 表名 CHANGE 【column】 列名 新列名 新数据类型;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE deptCHANGE department_name dept_name varchar( 15 );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-4-删除一个列"><a href="#4-4-删除一个列" class="headerlink" title="4. 4 删除一个列"></a>4. 4 删除一个列</h3><p>删除表中某个字段的语法格式如下：</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE 表名 DROP 【COLUMN】字段名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE deptDROP COLUMN job_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="5-重命名表"><a href="#5-重命名表" class="headerlink" title="5. 重命名表"></a>5. 重命名表</h2><hr><ul><li><p>方式一：使用RENAME</p><pre class="line-numbers language-none"><code class="language-none">RENAME TABLE empTO myemp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>方式二：</p><pre class="line-numbers language-none"><code class="language-none">ALTER table deptRENAME [TO] detail_dept;  -- [TO]可以省略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>必须是对象的拥有者</p></li></ul><hr><h2 id="6-删除表"><a href="#6-删除表" class="headerlink" title="6. 删除表"></a>6. 删除表</h2><hr><ul><li><p>在MySQL中，当一张数据表<code>没有与其他任何数据表形成关联关系</code>时，可以将当前数据表直接删除。</p></li><li><p>数据和结构都被删除</p></li><li><p>所有正在运行的相关事务被提交</p></li><li><p>所有相关索引被删除</p></li><li><p>语法格式：</p><pre class="line-numbers language-none"><code class="language-none">DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, ..., 数据表n];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>IF EXISTS</code>的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。</p></li><li><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">DROP TABLE dept80;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>DROP TABLE 语句不能回滚</p></li></ul><hr><h2 id="7-清空表"><a href="#7-清空表" class="headerlink" title="7. 清空表"></a>7. 清空表</h2><hr><ul><li><p>TRUNCATE TABLE语句：</p><ul><li>删除表中所有的数据</li><li>释放表的存储空间</li></ul></li><li><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">TRUNCATE TABLE detail_dept;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>TRUNCATE语句 <strong>不能回滚</strong> ，而使用 DELETE 语句删除数据，可以回滚</p></li><li><p>对比：</p><pre class="line-numbers language-none"><code class="language-none">SET autocommit &#x3D; FALSE;DELETE FROM emp2;#TRUNCATE TABLE emp2;SELECT * FROM emp2;ROLLBACK;SELECT * FROM emp2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>阿里开发规范：</p><p>【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。</p><p>说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p></blockquote><hr><h2 id="8-内容拓展"><a href="#8-内容拓展" class="headerlink" title="8. 内容拓展"></a>8. 内容拓展</h2><hr><h3 id="拓展-1-：阿里巴巴《Java开发手册》之MySQL字段命名"><a href="#拓展-1-：阿里巴巴《Java开发手册》之MySQL字段命名" class="headerlink" title="拓展 1 ：阿里巴巴《Java开发手册》之MySQL字段命名"></a>拓展 1 ：阿里巴巴《Java开发手册》之MySQL字段命名</h3><ul><li><p>【<code>强制</code>】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p><ul><li>正例：aliyun_admin，rdc_config，level3_name</li><li>反例：AliyunAdmin，rdcConfig，level_3_name</li></ul></li><li><p>【<code>强制</code>】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p></li><li><p>【<code>强制</code>】表必备三字段：id, gmt_create, gmt_modified。</p><ul><li>说明：其中id必为主键，类型为BIGINT UNSIGNED、单表时自增、步长为1。gmt_create,gmt_modified 的类型均为 DATETIME 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新</li></ul></li><li><p>【<code>推荐</code>】表的命名最好是遵循 “业务名称_表的作用”。</p><ul><li>正例：alipay_task 、 force_project、 trade_config</li></ul></li><li><p>【<code>推荐</code>】库名与应用名称尽量一致。</p></li><li><p>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</p><ul><li><p>正例：无符号值可以避免误存负数，且扩大了表示范围。</p><table><thead><tr><th>对象</th><th>年龄区间</th><th>类型</th><th>字节</th><th>表示范围</th></tr></thead><tbody><tr><td>人</td><td>150岁之内</td><td>tinyint unsigned</td><td>1</td><td>无符号值：0 到 255</td></tr><tr><td>龟</td><td>数百岁</td><td>smallint unnsigned</td><td>2</td><td>无符号值：0 到 65535</td></tr><tr><td>恐龙化石</td><td>数千万年</td><td>int unsigned</td><td>4</td><td>无符号值：0 到 约43亿</td></tr><tr><td>太阳</td><td>约50亿年</td><td>bigint unsigned</td><td>8</td><td>无符号值：0 到 约10的19次方</td></tr></tbody></table></li></ul></li></ul><h3 id="拓展-2-：如何理解清空表、删除表等操作需谨慎？！"><a href="#拓展-2-：如何理解清空表、删除表等操作需谨慎？！" class="headerlink" title="拓展 2 ：如何理解清空表、删除表等操作需谨慎？！"></a>拓展 2 ：如何理解清空表、删除表等操作需谨慎？！</h3><p><code>表删除</code>操作将把表的定义和表中的数据一起删除，并且MySQL在执行删除操作时，不会有任何的确认信息提示，因此执行删除操时应当慎重。在删除表前，最好对表中的数据进行<code>备份</code>，这样当操作失误时可以对数据进行恢复，以免造成无法挽回的后果。</p><p>同样的，在使用 <code>ALTER TABLE</code> 进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进行完整的<code>备份</code>，因为数据库的改变是<code>无法撤销</code>的，如果添加了一个不需要的字段，可以将其删除；相同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。</p><h3 id="拓展-3-：MySQL-8-新特性—DDL的原子化"><a href="#拓展-3-：MySQL-8-新特性—DDL的原子化" class="headerlink" title="拓展 3 ：MySQL 8 新特性—DDL的原子化"></a>拓展 3 ：MySQL 8 新特性—DDL的原子化</h3><p>在MySQL 8.0版本中，InnoDB表的DDL支持事务完整性，即<code>DDL操作要么成功要么回滚</code>。DDL操作回滚日志写入到data dictionary数据字典表mysql.innodb_ddl_log（该表是隐藏的表，通过show tables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。</p><p>分别在MySQL 5.7版本和MySQL 8.0版本中创建数据库和数据表，结果如下：</p><pre class="line-numbers language-none"><code class="language-none">CREATE DATABASE mytest;USE mytest;CREATE TABLE book1(book_id INT ,book_name VARCHAR( 255 ));SHOW TABLES;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(1) 在MySQL 5.7版本中，测试步骤如下： 删除数据表book1和数据表book2，结果如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; DROP TABLE book1,book2;ERROR 1051 ( 42 S02): Unknown table &#39;mytest.book2&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再次查询数据库中的数据表名称，结果如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SHOW TABLES;Empty set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果可以看出，虽然删除操作时报错了，但是仍然删除了数据表book1。</p><p>(2) 在MySQL 8.0版本中，测试步骤如下： 删除数据表book1和数据表book2，结果如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; DROP TABLE book1,book2;ERROR 1051 ( 42 S02): Unknown table &#39;mytest.book2&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再次查询数据库中的数据表名称，结果如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; show tables;+------------------+| Tables_in_mytest |+------------------+| book1 |+------------------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果可以看出，数据表book1并没有被删除。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据处理之增删改</title>
      <link href="/2022/07/17/di-11-zhang-shu-ju-chu-li-zhi-zeng-shan-gai/"/>
      <url>/2022/07/17/di-11-zhang-shu-ju-chu-li-zhi-zeng-shan-gai/</url>
      
        <content type="html"><![CDATA[<h1 id="第11章-数据处理之增删改"><a href="#第11章-数据处理之增删改" class="headerlink" title="第11章_数据处理之增删改"></a>第11章_数据处理之增删改</h1><p> 2022-04-15   2022-04-18   <a href="https://new-wangz.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">技术博客</a>   303   <a href="https://new-wangz.github.io/2022/04/15/%E7%AC%AC11%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/#valine-comments">0</a></p><h2 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a>1. 插入数据</h2><hr><h3 id="1-1-实际问题"><a href="#1-1-实际问题" class="headerlink" title="1. 1 实际问题"></a>1. 1 实际问题</h3><p><img src="/../pic/%E7%AC%AC11%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/1650096710363.png" alt="1650096710363"></p><p>解决方式：使用 INSERT 语句向表中插入数据。</p><h3 id="1-2-方式-1-：VALUES的方式添加"><a href="#1-2-方式-1-：VALUES的方式添加" class="headerlink" title="1. 2 方式 1 ：VALUES的方式添加"></a>1. 2 方式 1 ：VALUES的方式添加</h3><p>使用这种语法一次只能向表中插入 <strong>一条</strong> 数据。</p><p><strong>情况 1 ：为表的所有字段按默认顺序插入数据</strong></p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO 表名VALUES (value1,value2,....);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。</p><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO departmentsVALUES ( 70 , &#39;Pub&#39;, 100 , 1700 );INSERT INTO departmentsVALUES ( 100 , &#39;Finance&#39;, NULL, NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>情况 2 ：为表的指定字段插入数据</strong></p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO 表名(column1 [, column2, ..., columnn])VALUES (value1 [,value2, ..., valuen]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值。</p><p>在 INSERT 子句中随意列出列名，但是一旦列出，VALUES中要插入的value1,….valuen需要与column1,…columnn列一一对应。如果类型不同，将无法插入，并且MySQL会产生错误。</p><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO departments(department_id, department_name)VALUES ( 80 , &#39;IT&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>情况 3 ：同时插入多条记录</strong></p><p>INSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔开，基本语法格式如下：</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO table_nameVALUES(value1 [,value2, ..., valuen]),(value1 [,value2, ..., valuen]),......(value1 [,value2, ..., valuen]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO table_name(column1 [, column2, ..., columnn])VALUES(value1 [,value2, ..., valuen]),(value1 [,value2, ..., valuen]),......(value1 [,value2, ..., valuen]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; INSERT INTO emp(emp_id,emp_name)-&gt; VALUES ( 1001 ,&#39;shkstart&#39;),-&gt; ( 1002 ,&#39;atguigu&#39;),-&gt; ( 1003 ,&#39;Tom&#39;);Query OK, 3 rows affected (0.00 sec)Records: 3 Duplicates: 0 Warnings: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用INSERT同时插入多条记录时，MySQL会返回一些在执行单行插入时没有的额外信息，这些信息的含义如下：</p><ul><li>Records：表明插入的记录条数。</li><li>Duplicates：表明插入时被忽略的记录，原因可能是这些记录包含了重复的主键值。</li><li>Warnings：表明有问题的数据值，例如发生数据类型转换。</li></ul><blockquote><p>一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句，但是多行的INSERT语句在处理过程中<code>效率更高</code>。因为MySQL执行单条INSERT语句插入多行数据比使用多条INSERT语句快，所以在插入多条记录时最好选择使用单条INSERT语句的方式插入。</p></blockquote><p><strong>小结：</strong></p><ul><li><code>VALUES</code>也可以写成<code>VALUE</code>，但是VALUES是标准写法。</li><li>字符和日期型数据应包含在单引号中。</li></ul><h3 id="1-3-方式-2-：将查询结果插入到表中"><a href="#1-3-方式-2-：将查询结果插入到表中" class="headerlink" title="1. 3 方式 2 ：将查询结果插入到表中"></a>1. 3 方式 2 ：将查询结果插入到表中</h3><p>INSERT还可以将SELECT语句查询的结果插入到表中，此时不需要把每一条记录的值一个一个输入，只需要使用一条INSERT语句和一条SELECT语句组成的组合语句即可快速地从一个或多个表中向一个表中插入多行。</p><p>基本语法格式如下：</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO 目标表名(tar_column1 [, tar_column2, ..., tar_columnn])SELECT(src_column1 [, src_column2, ..., src_columnn])FROM 源表名[WHERE condition]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在 INSERT 语句中加入子查询。</li><li><strong>不必书写 VALUES 子句。</strong></li><li>子查询中的值列表应与 INSERT 子句中的列名对应。</li></ul><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO empSELECT *FROM employeesWHERE department_id &#x3D; 90 ;INSERT INTO sales_reps(id, name, salary, commission_pct)SELECT employee_id, last_name, salary, commission_pctFROM employeesWHERE job_id LIKE &#39;%REP%&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="2-更新数据"><a href="#2-更新数据" class="headerlink" title="2. 更新数据"></a>2. 更新数据</h2><hr><p><img src="/../pic/%E7%AC%AC11%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/1650097046903.png" alt="1650097046903"></p><ul><li><p>使用 UPDATE 语句更新数据。语法如下：</p><pre class="line-numbers language-none"><code class="language-none">UPDATE table_nameSET column1&#x3D;value1, column2&#x3D;value2, ... , column&#x3D;valuen[WHERE condition]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>可以一次更新 <strong>多条</strong> 数据。</p></li><li><p>如果需要回滚数据，需要保证在DML前，进行设置： <strong>SET AUTOCOMMIT &#x3D; FALSE;</strong></p></li><li><p>使用 <strong>WHERE</strong> 子句指定需要更新的数据。</p><pre class="line-numbers language-none"><code class="language-none">UPDATE employeesSET department_id &#x3D; 70WHERE employee_id &#x3D; 113 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>如果省略 WHERE 子句，则表中的所有数据都将被更新。</p><pre class="line-numbers language-none"><code class="language-none">UPDATE copy_empSET department_id &#x3D; 110 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>更新中的数据完整性错误</p><pre class="line-numbers language-none"><code class="language-none">UPDATE employeesSET department_id &#x3D; 55WHERE department_id &#x3D; 110 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>说明：不存在 55 号部门</p></blockquote><hr><h2 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3. 删除数据"></a>3. 删除数据</h2><hr><p><img src="/../pic/%E7%AC%AC11%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/1650097169922.png" alt="1650097169922"></p><ul><li><p>使用 DELETE 语句从表中删除数据</p><p><img src="/../pic/%E7%AC%AC11%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/1650097225574.png" alt="1650097225574"></p><pre class="line-numbers language-none"><code class="language-none">DELETE FROM table_name [WHERE &lt;condition&gt;];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>table_name指定要执行删除操作的表；“[WHERE ]”为可选参数，指定删除条件，如果没有WHERE子句，DELETE语句将删除表中的所有记录。</p></li><li><p>使用 WHERE 子句删除指定的记录。</p><pre class="line-numbers language-none"><code class="language-none">DELETE FROM departmentsWHERE department_name &#x3D; &#39;Finance&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>如果省略 WHERE 子句，则表中的全部数据将被删除</p><pre class="line-numbers language-none"><code class="language-none">DELETE FROM copy_emp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>删除中的数据完整性错误</strong></p><pre class="line-numbers language-none"><code class="language-none">DELETE FROM departmentsWHERE department_id &#x3D; 60 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><blockquote><p>说明：You cannot delete a row that contains a primary key that is used as a foreign key in another table.</p></blockquote><hr><h2 id="4-MySQL-8-新特性：计算列"><a href="#4-MySQL-8-新特性：计算列" class="headerlink" title="4. MySQL 8 新特性：计算列"></a>4. MySQL 8 新特性：计算列</h2><hr><p>什么叫计算列呢？简单来说就是某一列的值是通过别的列计算得来的。例如，a列值为 1 、b列值为 2 ，c列不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的。</p><p>在MySQL 8.0中，CREATE TABLE 和 ALTER TABLE 中都支持增加计算列。下面以CREATE TABLE为例进行讲解。</p><p>举例：定义数据表tb1，然后定义字段id、字段a、字段b和字段c，其中字段c为计算列，用于计算a+b的值。 首先创建测试表tb1，语句如下：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE tb1(id INT,a INT,b INT,c INT GENERATED ALWAYS AS (a + b) VIRTUAL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>插入演示数据，语句如下：</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO tb1(a,b) VALUES ( 100 , 200 );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询数据表tb1中的数据，结果如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM tb1;+------+------+------+------+| id | a | b | c |+------+------+------+------+| NULL | 100 | 200 | 300 |+------+------+------+------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更新数据中的数据，语句如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; UPDATE tb1 SET a &#x3D; 500 ;Query OK, 0 rows affected (0.00 sec)Rows matched: 1 Changed: 0 Warnings: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="5-综合案例"><a href="#5-综合案例" class="headerlink" title="5. 综合案例"></a>5. 综合案例</h2><hr><pre class="line-numbers language-none"><code class="language-none"># 1、创建数据库test01_library# 2、创建表 books，表结构如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>字段名</th><th>字段说明</th><th>数据类型</th></tr></thead><tbody><tr><td>id</td><td>书编号</td><td>INT</td></tr><tr><td>name</td><td>书名</td><td>VARCHAR(50)</td></tr><tr><td>authors</td><td>作者</td><td>VARCHAR(100)</td></tr><tr><td>price</td><td>价格</td><td>FLOAT</td></tr><tr><td>pubdate</td><td>出版日期</td><td>YEAR</td></tr><tr><td>note</td><td>说明</td><td>VARCHAR(100)</td></tr><tr><td>num</td><td>库存</td><td>INT</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none"># 3、向books表中插入记录# 1）不指定字段名称，插入第一条记录# 2）指定所有字段名称，插入第二记录# 3）同时插入多条记录（剩下的所有记录）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>id</th><th>name</th><th>authors</th><th>price</th><th>pubdate</th><th>note</th><th>num</th></tr></thead><tbody><tr><td>1</td><td>Tal of AAA</td><td>Dickes</td><td>23</td><td>1995</td><td>novel</td><td>11</td></tr><tr><td>2</td><td>EmmaT</td><td>Jane lura</td><td>35</td><td>1993</td><td>joke</td><td>22</td></tr><tr><td>3</td><td>Story of Jane</td><td>Jane Tim</td><td>40</td><td>2001</td><td>novel</td><td>0</td></tr><tr><td>4</td><td>Lovey Day</td><td>George Byron</td><td>20</td><td>2005</td><td>novel</td><td>30</td></tr><tr><td>5</td><td>Old land</td><td>Honore Blade</td><td>30</td><td>2010</td><td>law</td><td>0</td></tr><tr><td>6</td><td>The Battle</td><td>Upton Sara</td><td>30</td><td>1999</td><td>medicine</td><td>40</td></tr><tr><td>7</td><td>Rose Hood</td><td>Richard haggard</td><td>28</td><td>2008</td><td>cartoon</td><td>28</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none"># 4、将小说类型(novel)的书的价格都增加 5 。# 5、将名称为EmmaT的书的价格改为 40 ，并将说明改为drama。# 6、删除库存为 0 的记录。# 7、统计书名中包含a字母的书# 8、统计书名中包含a字母的书的数量和库存总量# 9、找出“novel”类型的书，按照价格降序排列# 10、查询图书信息，按照库存量降序排列，如果库存量相同的按照note升序排列# 11、按照note分类统计书的数量# 13、查询所有图书，每页显示 5 本，显示第二页# 14、按照note分类统计书的库存量，显示库存量最多的# 15、查询书名达到 10 个字符的书，不包括里面的空格# 16、查询书名和类型，其中note值为novel显示小说，law显示法律，medicine显示医药,cartoon显示卡通，joke显示笑话# 17、查询书名、库存，其中num值超过 30 本的，显示滞销，大于 0 并低于 10 的，显示畅销，为 0 的显示需要无货# 18、统计每一种note的库存量，并合计总量# 19、统计每一种note的数量，并合计总量# 20、统计库存量前三名的图书# 21、找出最早出版的一本书# 22、找出novel中价格最高的一本书# 23、找出书名中字数最多的一本书，不含空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>答案：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#1、创建数据库test01_library</span><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> test01_library <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token string">'utf8'</span><span class="token punctuation">;</span><span class="token comment">#指定使用哪个数据库</span><span class="token keyword">USE</span> test01_library<span class="token punctuation">;</span><span class="token comment">#2、创建表 books</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> books<span class="token punctuation">(</span>id <span class="token keyword">INT</span><span class="token punctuation">,</span>name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span> <span class="token number">50</span> <span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>authors<span class="token punctuation">`</span></span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span> <span class="token number">100</span> <span class="token punctuation">)</span> <span class="token punctuation">,</span>price <span class="token keyword">FLOAT</span><span class="token punctuation">,</span>pubdate <span class="token keyword">YEAR</span> <span class="token punctuation">,</span>note <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>num <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#3、向books表中插入记录</span><span class="token number">1</span>）不指定字段名称，插入第一条记录<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> books<span class="token keyword">VALUES</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">,</span><span class="token string">'Tal of AAA'</span><span class="token punctuation">,</span><span class="token string">'Dickes'</span><span class="token punctuation">,</span> <span class="token number">23</span> <span class="token punctuation">,</span> <span class="token number">1995</span> <span class="token punctuation">,</span><span class="token string">'novel'</span><span class="token punctuation">,</span> <span class="token number">11</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">2</span>）指定所有字段名称，插入第二记录<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> books <span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>authors<span class="token punctuation">`</span></span><span class="token punctuation">,</span>price<span class="token punctuation">,</span>pubdate<span class="token punctuation">,</span>note<span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token keyword">VALUES</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">,</span><span class="token string">'EmmaT'</span><span class="token punctuation">,</span><span class="token string">'Jane lura'</span><span class="token punctuation">,</span> <span class="token number">35</span> <span class="token punctuation">,</span> <span class="token number">1993</span> <span class="token punctuation">,</span><span class="token string">'Joke'</span><span class="token punctuation">,</span> <span class="token number">22</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">3</span>）同时插入多条记录（剩下的所有记录）<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> books <span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>authors<span class="token punctuation">`</span></span><span class="token punctuation">,</span>price<span class="token punctuation">,</span>pubdate<span class="token punctuation">,</span>note<span class="token punctuation">,</span>num<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token punctuation">,</span><span class="token string">'Story of Jane'</span><span class="token punctuation">,</span><span class="token string">'Jane Tim'</span><span class="token punctuation">,</span> <span class="token number">40</span> <span class="token punctuation">,</span> <span class="token number">2001</span> <span class="token punctuation">,</span><span class="token string">'novel'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token punctuation">,</span><span class="token string">'Lovey Day'</span><span class="token punctuation">,</span><span class="token string">'George Byron'</span><span class="token punctuation">,</span> <span class="token number">20</span> <span class="token punctuation">,</span> <span class="token number">2005</span> <span class="token punctuation">,</span><span class="token string">'novel'</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token punctuation">,</span><span class="token string">'Old land'</span><span class="token punctuation">,</span><span class="token string">'Honore Blade'</span><span class="token punctuation">,</span> <span class="token number">30</span> <span class="token punctuation">,</span> <span class="token number">2010</span> <span class="token punctuation">,</span><span class="token string">'Law'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span> <span class="token punctuation">,</span><span class="token string">'The Battle'</span><span class="token punctuation">,</span><span class="token string">'Upton Sara'</span><span class="token punctuation">,</span> <span class="token number">30</span> <span class="token punctuation">,</span> <span class="token number">1999</span> <span class="token punctuation">,</span><span class="token string">'medicine'</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">7</span> <span class="token punctuation">,</span><span class="token string">'Rose Hood'</span><span class="token punctuation">,</span><span class="token string">'Richard haggard'</span><span class="token punctuation">,</span> <span class="token number">28</span> <span class="token punctuation">,</span> <span class="token number">2008</span> <span class="token punctuation">,</span><span class="token string">'cartoon'</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 4、将小说类型(novel)的书的价格都增加 5 。</span><span class="token keyword">UPDATE</span> books <span class="token keyword">SET</span> price<span class="token operator">=</span>price<span class="token operator">+</span> <span class="token number">5</span> <span class="token keyword">WHERE</span> note <span class="token operator">=</span> <span class="token string">'novel'</span><span class="token punctuation">;</span><span class="token comment"># 5、将名称为EmmaT的书的价格改为 40 ，并将说明改为drama。</span><span class="token keyword">UPDATE</span> books <span class="token keyword">SET</span> price<span class="token operator">=</span> <span class="token number">40</span> <span class="token punctuation">,</span>note<span class="token operator">=</span><span class="token string">'drama'</span> <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token string">'EmmaT'</span><span class="token punctuation">;</span><span class="token comment"># 6、删除库存为 0 的记录。</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> books <span class="token keyword">WHERE</span> num<span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span><span class="token comment"># 7、统计书名中包含a字母的书</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> books <span class="token keyword">WHERE</span> name <span class="token operator">LIKE</span> <span class="token string">'%a%'</span><span class="token punctuation">;</span><span class="token comment"># 8、统计书名中包含a字母的书的数量和库存总量</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token keyword">FROM</span> books <span class="token keyword">WHERE</span> name <span class="token operator">LIKE</span> <span class="token string">'%a%'</span><span class="token punctuation">;</span><span class="token comment"># 9、找出“novel”类型的书，按照价格降序排列</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> books <span class="token keyword">WHERE</span> note <span class="token operator">=</span> <span class="token string">'novel'</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> price <span class="token keyword">DESC</span><span class="token punctuation">;</span><span class="token comment"># 10、查询图书信息，按照库存量降序排列，如果库存量相同的按照note升序排列</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> books <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> num <span class="token keyword">DESC</span><span class="token punctuation">,</span>note <span class="token keyword">ASC</span><span class="token punctuation">;</span><span class="token comment"># 11、按照note分类统计书的数量</span><span class="token keyword">SELECT</span> note<span class="token punctuation">,</span><span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> books <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> note<span class="token punctuation">;</span><span class="token comment"># 12、按照note分类统计书的库存量，显示库存量超过 30 本的</span><span class="token keyword">SELECT</span> note<span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token keyword">FROM</span> books <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> note <span class="token keyword">HAVING</span> <span class="token function">SUM</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token operator">></span> <span class="token number">30</span> <span class="token punctuation">;</span><span class="token comment"># 13、查询所有图书，每页显示 5 本，显示第二页</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> books <span class="token keyword">LIMIT</span> <span class="token number">5</span> <span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">;</span><span class="token comment"># 14、按照note分类统计书的库存量，显示库存量最多的</span><span class="token keyword">SELECT</span> note<span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> sum_num <span class="token keyword">FROM</span> books <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> note <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> sum_num <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">0</span> <span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">;</span><span class="token comment"># 15、查询书名达到 10 个字符的书，不包括里面的空格</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> books <span class="token keyword">WHERE</span> CHAR_LENGTH<span class="token punctuation">(</span><span class="token keyword">REPLACE</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token string">' '</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">10</span> <span class="token punctuation">;</span><span class="token comment">/*16 、查询书名和类型，其中note值为 novel显示小说，law显示法律，medicine显示医药，cartoon显示卡通，joke显示笑话*/</span><span class="token keyword">SELECT</span> name <span class="token keyword">AS</span> <span class="token string">"书名"</span> <span class="token punctuation">,</span>note<span class="token punctuation">,</span> <span class="token keyword">CASE</span> note<span class="token keyword">WHEN</span> <span class="token string">'novel'</span> <span class="token keyword">THEN</span> <span class="token string">'小说'</span><span class="token keyword">WHEN</span> <span class="token string">'law'</span> <span class="token keyword">THEN</span> <span class="token string">'法律'</span><span class="token keyword">WHEN</span> <span class="token string">'medicine'</span> <span class="token keyword">THEN</span> <span class="token string">'医药'</span><span class="token keyword">WHEN</span> <span class="token string">'cartoon'</span> <span class="token keyword">THEN</span> <span class="token string">'卡通'</span><span class="token keyword">WHEN</span> <span class="token string">'joke'</span> <span class="token keyword">THEN</span> <span class="token string">'笑话'</span><span class="token keyword">END</span> <span class="token keyword">AS</span> <span class="token string">"类型"</span><span class="token keyword">FROM</span> books<span class="token punctuation">;</span><span class="token comment"># 17、查询书名、库存，其中num值超过 30 本的，显示滞销，大于 0 并低于 10 的，显示畅销，为 0 的显示需要无货</span><span class="token keyword">SELECT</span> name<span class="token punctuation">,</span>num<span class="token punctuation">,</span><span class="token keyword">CASE</span><span class="token keyword">WHEN</span> num<span class="token operator">></span> <span class="token number">30</span> <span class="token keyword">THEN</span> <span class="token string">'滞销'</span><span class="token keyword">WHEN</span> num<span class="token operator">></span> <span class="token number">0</span> <span class="token operator">AND</span> num<span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token keyword">THEN</span> <span class="token string">'畅销'</span><span class="token keyword">WHEN</span> num<span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">THEN</span> <span class="token string">'无货'</span><span class="token keyword">ELSE</span> <span class="token string">'正常'</span><span class="token keyword">END</span> <span class="token keyword">AS</span> <span class="token string">"库存状态"</span><span class="token keyword">FROM</span> books<span class="token punctuation">;</span><span class="token comment"># 18、统计每一种note的库存量，并合计总量</span><span class="token keyword">SELECT</span> IFNULL<span class="token punctuation">(</span>note<span class="token punctuation">,</span><span class="token string">'合计总库存量'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> note<span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token keyword">FROM</span> books <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> note <span class="token keyword">WITH ROLLUP</span><span class="token punctuation">;</span><span class="token comment"># 19、统计每一种note的数量，并合计总量</span><span class="token keyword">SELECT</span> IFNULL<span class="token punctuation">(</span>note<span class="token punctuation">,</span><span class="token string">'合计总数'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> note<span class="token punctuation">,</span><span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> books <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> note <span class="token keyword">WITH ROLLUP</span><span class="token punctuation">;</span><span class="token comment"># 20、统计库存量前三名的图书</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> books <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> num <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">0</span> <span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">;</span><span class="token comment"># 21、找出最早出版的一本书</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> books <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> pubdate <span class="token keyword">ASC</span> <span class="token keyword">LIMIT</span> <span class="token number">0</span> <span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">;</span><span class="token comment"># 22、找出novel中价格最高的一本书</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> books <span class="token keyword">WHERE</span> note <span class="token operator">=</span> <span class="token string">'novel'</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> price <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">0</span> <span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">;</span><span class="token comment"># 23、找出书名中字数最多的一本书，不含空格</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> books <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> CHAR_LENGTH<span class="token punctuation">(</span><span class="token keyword">REPLACE</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token string">' '</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">0</span> <span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约束</title>
      <link href="/2022/07/17/di-13-zhang-yue-shu/"/>
      <url>/2022/07/17/di-13-zhang-yue-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="第13章-约束"><a href="#第13章-约束" class="headerlink" title="第13章_约束"></a>第13章_约束</h1><h2 id="1-约束-constraint-概述"><a href="#1-约束-constraint-概述" class="headerlink" title="1. 约束(constraint)概述"></a>1. 约束(constraint)概述</h2><hr><h3 id="1-1-为什么需要约束"><a href="#1-1-为什么需要约束" class="headerlink" title="1. 1 为什么需要约束"></a>1. 1 为什么需要约束</h3><p>数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。</p><p>为了保证数据的完整性，SQL规范以约束的方式对<strong>表数据进行额外的条件限制</strong>。从以下四个方面考虑：</p><ul><li><code>实体完整性（Entity Integrity）</code>：例如，同一个表中，不能存在两条完全相同无法区分的记录</li><li><code>域完整性（Domain Integrity）</code>：例如：年龄范围0-120，性别范围“男&#x2F;女”</li><li><code>引用完整性（Referential Integrity）</code>：例如：员工所在部门，在部门表中要能找到这个部门</li><li><code>用户自定义完整性（User-defined Integrity）</code>：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的 5 倍。</li></ul><h2 id="1-2-什么是约束"><a href="#1-2-什么是约束" class="headerlink" title="1. 2 什么是约束"></a>1. 2 什么是约束</h2><p>约束是表级的强制规定。</p><p>可以在 <strong>创建表时规定约束（通过 CREATE TABLE 语句）</strong> ，或者在 <strong>表创建之后通过 ALTER TABLE 语句规定约束</strong> 。</p><h3 id="1-3-约束的分类"><a href="#1-3-约束的分类" class="headerlink" title="1. 3 约束的分类"></a>1. 3 约束的分类</h3><ul><li><p>根据约束数据列的限制， 约束可分为：</p><ul><li>单列约束 ：每个约束只约束一列</li><li>多列约束 ：每个约束可约束多列数据</li></ul></li><li><p>根据约束的作用范围 ，约束可分为：</p><ul><li>列级约束 ：只能作用在一个列上，跟在列的定义后面</li><li>表级约束 ：可以作用在多个列上，不与列一起，而是单独定义</li></ul><pre class="line-numbers language-none"><code class="language-none">位置支持的约束类型是否可以起约束名列级约束：列的后面语法都支持，但外键没有效果不可以表级约束：所有列的下面默认和非空不支持，其他支持可以（主键没有效果）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>根据约束起的作用 ，约束可分为：</p><ul><li>NOT NULL 非空约束，规定某个字段不能为空</li><li>UNIQUE 唯一约束 ， 规定某个字段在整个表中是唯一的</li><li>PRIMARY KEY 主键(非空且唯一)约束</li><li>FOREIGN KEY 外键约束</li><li>CHECK 检查约束</li><li>DEFAULT 默认值约束</li></ul></li></ul><blockquote><p>注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果</p></blockquote><ul><li><p>查看某个表已有的约束</p><pre class="line-numbers language-none"><code class="language-none">#information_schema数据库名（系统库）#table_constraints表名称（专门存储各个表的约束）SELECT * FROM information_schema.table_constraintsWHERE table_name &#x3D; &#39;表名称&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="2-非空约束"><a href="#2-非空约束" class="headerlink" title="2. 非空约束"></a>2. 非空约束</h2><hr><h3 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2. 1 作用"></a>2. 1 作用</h3><p>限定某个字段&#x2F;某列的值不允许为空</p><p><img src="/../pic/%E7%AC%AC13%E7%AB%A0_%E7%BA%A6%E6%9D%9F/1650270930136.png" alt="1650270930136"></p><h3 id="2-2-关键字"><a href="#2-2-关键字" class="headerlink" title="2. 2 关键字"></a>2. 2 关键字</h3><p>NOT NULL</p><h3 id="2-3-特点"><a href="#2-3-特点" class="headerlink" title="2. 3 特点"></a>2. 3 特点</h3><ul><li>默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型</li><li>非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空</li><li>一个表可以有很多列都分别限定了非空</li><li>空字符串’’不等于NULL， 0 也不等于NULL</li></ul><h3 id="2-4-添加非空约束"><a href="#2-4-添加非空约束" class="headerlink" title="2. 4 添加非空约束"></a>2. 4 添加非空约束</h3><p>(1) 建表时</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE 表名称(字段名 数据类型,字段名 数据类型 NOT NULL,字段名 数据类型 NOT NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE emp(id INT( 10 ) NOT NULL,NAME VARCHAR( 20 ) NOT NULL,sex CHAR NULL);CREATE TABLE student(sid int,sname varchar( 20 ) not null,tel char( 11 ) ,cardid char( 18 ) not null);insert into student values( 1 ,&#39;张三&#39;,&#39;13710011002&#39;,&#39;110222198912032545&#39;); #成功insert into student values( 2 ,&#39;李四&#39;,&#39;13710011002&#39;,null);#身份证号为空ERROR 1048 ( 23000 ): Column &#39;cardid&#39; cannot be nullinsert into student values(2,&#39;李四&#39;,null,&#39;110222198912032546&#39;);#成功，tel允许为空insert into student values( 3 ,null,null,&#39;110222198912032547&#39;);#失败ERROR 1048 ( 23000 ): Column &#39;sname&#39; cannot be null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2) 建表后</p><pre class="line-numbers language-none"><code class="language-none">alter table 表名称 modify 字段名 数据类型 not null;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE empMODIFY sex VARCHAR( 30 ) NOT NULL;alter table student modify sname varchar( 20 ) not null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-5-删除非空约束"><a href="#2-5-删除非空约束" class="headerlink" title="2. 5 删除非空约束"></a>2. 5 删除非空约束</h3><pre class="line-numbers language-none"><code class="language-none">alter table 表名称 modify 字段名 数据类型 NULL;#去掉not null，相当于修改某个非注解字段，该字段允许为空或alter table 表名称 modify 字段名 数据类型;#去掉not null，相当于修改某个非注解字段，该字段允许为空<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE empMODIFY sex VARCHAR( 30 ) NULL;ALTER TABLE empMODIFY NAME VARCHAR( 15 ) DEFAULT &#39;abc&#39; NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="3-唯一性约束"><a href="#3-唯一性约束" class="headerlink" title="3. 唯一性约束"></a>3. 唯一性约束</h2><hr><h3 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3. 1 作用"></a>3. 1 作用</h3><p>用来限制某个字段&#x2F;某列的值不能重复。</p><p><img src="/../pic/%E7%AC%AC13%E7%AB%A0_%E7%BA%A6%E6%9D%9F/1650271354207.png" alt="1650271354207"></p><h3 id="3-2-关键字"><a href="#3-2-关键字" class="headerlink" title="3. 2 关键字"></a>3. 2 关键字</h3><p>UNIQUE</p><h3 id="3-3-特点"><a href="#3-3-特点" class="headerlink" title="3. 3 特点"></a>3. 3 特点</h3><ul><li>同一个表可以有多个唯一约束。</li><li>唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。</li><li>唯一性约束允许列值为空。</li><li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</li><li><strong>MySQL会给唯一约束的列上默认创建一个唯一索引。</strong></li></ul><h3 id="3-4-添加唯一约束"><a href="#3-4-添加唯一约束" class="headerlink" title="3. 4 添加唯一约束"></a>3. 4 添加唯一约束</h3><p>(1) 建表时</p><pre class="line-numbers language-none"><code class="language-none">create table 表名称(字段名 数据类型,字段名 数据类型 unique,字段名 数据类型 unique key,字段名 数据类型);create table 表名称(字段名 数据类型,字段名 数据类型,字段名 数据类型,[constraint 约束名] unique key(字段名));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">create table student(sid int,sname varchar( 20 ),tel char( 11 ) unique,cardid char( 18 ) unique key);CREATE TABLE t_course(cid INT UNIQUE,cname VARCHAR( 100 ) UNIQUE,description VARCHAR( 200 ));CREATE TABLE USER(id INT NOT NULL,NAME VARCHAR( 25 ),PASSWORD VARCHAR( 16 ),-- 使用表级约束语法CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>表示用户名和密码组合不能重复</p></blockquote><pre class="line-numbers language-none"><code class="language-none">insert into student values( 1 ,&#39;张三&#39;,&#39;13710011002&#39;,&#39;101223199012015623&#39;);insert into student values( 2 ,&#39;李四&#39;,&#39;13710011003&#39;,&#39;101223199012015624&#39;);mysql&gt; select * from student;+-----+-------+-------------+--------------------+| sid | sname | tel | cardid |+-----+-------+-------------+--------------------+| 1 | 张三 | 13710011002 | 101223199012015623 || 2 | 李四 | 13710011003 | 101223199012015624 |+-----+-------+-------------+--------------------+2 rows in set (0.00 sec)insert into student values( 3 ,&#39;王五&#39;,&#39;13710011004&#39;,&#39;101223199012015624&#39;); #身份证号重复ERROR 1062 ( 23000 ): Duplicate entry &#39;101223199012015624&#39; for key &#39;cardid&#39;insert into student values( 3 ,&#39;王五&#39;,&#39;13710011003&#39;,&#39;101223199012015625&#39;);ERROR 1062 ( 23000 ): Duplicate entry &#39;13710011003&#39; for key &#39;tel&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2) 建表后指定唯一键约束</p><pre class="line-numbers language-none"><code class="language-none">#字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的#方式 1 ：alter table 表名称 add unique key(字段列表);#方式 2 ：alter table 表名称 modify 字段名 字段类型 unique;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE USERADD UNIQUE(NAME,PASSWORD);ALTER TABLE USERADD CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD);ALTER TABLE USERMODIFY NAME VARCHAR( 20 ) UNIQUE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">create table student(sid int primary key,sname varchar( 20 ),tel char( 11 ) ,cardid char( 18 ));alter table student add unique key(tel);alter table student add unique key(cardid);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-关于复合唯一约束"><a href="#3-5-关于复合唯一约束" class="headerlink" title="3. 5 关于复合唯一约束"></a>3. 5 关于复合唯一约束</h3><pre class="line-numbers language-none"><code class="language-none">create table 表名称(字段名 数据类型,字段名 数据类型,字段名 数据类型,unique key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多个字段的组合是唯一的);#学生表create table student(sid int, #学号sname varchar( 20 ), #姓名tel char( 11 ) unique key,  #电话cardid char( 18 ) unique key #身份证号);#课程表create table course(cid int,  #课程编号cname varchar( 20 ) #课程名称);#选课表create table student_course(id int,sid int,cid int,score int,unique key(sid,cid)  #复合唯一);insert into student values( 1 ,&#39;张三&#39;,&#39;13710011002&#39;,&#39;101223199012015623&#39;);#成功insert into student values( 2 ,&#39;李四&#39;,&#39;13710011003&#39;,&#39;101223199012015624&#39;);#成功insert into course values( 1001 ,&#39;Java&#39;),( 1002 ,&#39;MySQL&#39;);#成功mysql&gt; select * from student;+-----+-------+-------------+--------------------+| sid | sname | tel | cardid |+-----+-------+-------------+--------------------+| 1 | 张三 | 13710011002 | 101223199012015623 || 2 | 李四 | 13710011003 | 101223199012015624 |+-----+-------+-------------+--------------------+2 rows in set (0.00 sec)mysql&gt; select * from course;+------+-------+| cid | cname |+------+-------+| 1001 | Java || 1002 | MySQL |+------+-------+2 rows in set (0.00 sec)insert into student_course values( 1 , 1 , 1001 , 89 ),( 2 , 1 , 1002 , 90 ),( 3 , 2 , 1001 , 88 ),( 4 , 2 , 1002 , 56 );#成功mysql&gt; select * from student_course;+----+------+------+-------+| id | sid | cid | score |+----+------+------+-------+| 1 | 1 | 1001 | 89 || 2 | 1 | 1002 | 90 || 3 | 2 | 1001 | 88 || 4 | 2 | 1002 | 56 |+----+------+------+-------+4 rows in set (0.00 sec)insert into student_course values ( 5 , 1 , 1001 , 88 );#失败#ERROR 1062 (23000): Duplicate entry &#39;1-1001&#39; for key &#39;sid&#39; 违反sid-cid的复合唯一<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-删除唯一约束"><a href="#3-6-删除唯一约束" class="headerlink" title="3. 6 删除唯一约束"></a>3. 6 删除唯一约束</h3><ul><li>添加唯一性约束的列上也会自动创建唯一索引。</li><li>删除唯一约束只能通过删除唯一索引的方式删除。</li><li>删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。</li><li>如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。</li></ul><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM information_schema.table_constraints WHERE table_name &#x3D; &#39;表名&#39;; #查看都有哪些约束ALTER TABLE USERDROP INDEX uk_name_pwd;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：可以通过 <code>show index from 表名称;</code>查看表的索引</p></blockquote><hr><h2 id="4-PRIMARY-KEY-约束"><a href="#4-PRIMARY-KEY-约束" class="headerlink" title="4. PRIMARY KEY 约束"></a>4. PRIMARY KEY 约束</h2><hr><h3 id="4-1-作用"><a href="#4-1-作用" class="headerlink" title="4. 1 作用"></a>4. 1 作用</h3><p>用来唯一标识表中的一行记录。</p><h3 id="4-2-关键字"><a href="#4-2-关键字" class="headerlink" title="4. 2 关键字"></a>4. 2 关键字</h3><p>primary key</p><h3 id="4-3-特点"><a href="#4-3-特点" class="headerlink" title="4. 3 特点"></a>4. 3 特点</h3><ul><li>主键约束相当于 唯一约束+非空约束的组合 ，主键约束列不允许重复，也不允许出现空值。<br><img src="/../pic/%E7%AC%AC13%E7%AB%A0_%E7%BA%A6%E6%9D%9F/1650271961132.png" alt="1650271961132"></li><li>一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。</li><li>主键约束对应着表中的一列或者多列（复合主键）</li><li>如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。</li><li><strong>MySQL的主键名总是PRIMARY</strong> ，就算自己命名了主键约束名也没用。</li><li>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的 <strong>主键索引</strong> （能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。</li><li>需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。</li></ul><h3 id="4-4-添加主键约束"><a href="#4-4-添加主键约束" class="headerlink" title="4. 4 添加主键约束"></a>4. 4 添加主键约束</h3><p>(1) 建表时指定主键约束</p><pre class="line-numbers language-none"><code class="language-none">create table 表名称(字段名 数据类型 primary key, #列级模式字段名 数据类型,字段名 数据类型);create table 表名称(字段名 数据类型,字段名 数据类型,字段名 数据类型,[constraint 约束名] primary key(字段名) #表级模式);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">create table temp(id int primary key,name varchar( 20 ));mysql&gt; desc temp;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int( 11 ) | NO | PRI | NULL | || name | varchar( 20 ) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec)insert into temp values( 1 ,&#39;张三&#39;);#成功insert into temp values( 2 ,&#39;李四&#39;);#成功mysql&gt; select * from temp;+----+------+| id | name |+----+------+| 1 | 张三 || 2 | 李四 |+----+------+2 rows in set (0.00 sec)insert into temp values( 1 ,&#39;张三&#39;);#失败ERROR 1062 ( 23000 ): Duplicate（重复） entry（键入，输入） &#39;1&#39; for key &#39;PRIMARY&#39;insert into temp values( 1 ,&#39;王五&#39;);#失败ERROR 1062 ( 23000 ): Duplicate entry &#39;1&#39; for key &#39;PRIMARY&#39;insert into temp values( 3 ,&#39;张三&#39;);#成功mysql&gt; select * from temp;+----+------+| id | name |+----+------+| 1 | 张三 || 2 | 李四 || 3 | 张三 |+----+------+3 rows in set (0.00 sec)insert into temp values( 4 ,null);#成功insert into temp values(null,&#39;李琦&#39;);#失败ERROR 1048 ( 23000 ): Column &#39;id&#39; cannot be nullmysql&gt; select * from temp;+----+------+| id | name |+----+------+| 1 | 张三 || 2 | 李四 || 3 | 张三 || 4 | NULL |+----+------+4 rows in set (0.00 sec)#演示一个表建立两个主键约束create table temp(id int primary key,name varchar( 20 ) primary key);ERROR 1068 ( 42000 ): Multiple（多重的） primary key defined（定义）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再举例：</p><ul><li><p>列级约束</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE emp4(id INT PRIMARY KEY AUTO_INCREMENT ,NAME VARCHAR( 20 ));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>表级约束</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE emp5(id INT NOT NULL AUTO_INCREMENT,NAME VARCHAR( 20 ),pwd VARCHAR( 15 ),CONSTRAINT emp5_id_pk PRIMARY KEY(id));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>(2) 建表后增加主键约束</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键ALTER TABLE student ADD PRIMARY KEY (sid);ALTER TABLE emp5 ADD PRIMARY KEY(NAME,pwd);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-5-关于复合主键"><a href="#4-5-关于复合主键" class="headerlink" title="4. 5 关于复合主键"></a>4. 5 关于复合主键</h3><pre class="line-numbers language-none"><code class="language-none">create table 表名称(字段名 数据类型,字段名 数据类型,字段名 数据类型,primary key(字段名1,字段名2)  #表示字段 1 和字段 2 的组合是唯一的，也可以有更多个字段);#学生表create table student(sid int primary key,  #学号sname varchar( 20 ) #学生姓名);#课程表create table course(cid int primary key,  #课程编号cname varchar( 20 ) #课程名称);#选课表create table student_course(sid int,cid int,score int,primary key(sid,cid)  #复合主键);insert into student values( 1 ,&#39;张三&#39;),( 2 ,&#39;李四&#39;);insert into course values( 1001 ,&#39;Java&#39;),( 1002 ,&#39;MySQL&#39;);mysql&gt; select * from student;+-----+-------+| sid | sname |+-----+-------+| 1 | 张三 || 2 | 李四 |+-----+-------+2 rows in set (0.00 sec)mysql&gt; select * from course;+------+-------+| cid | cname |+------+-------+| 1001 | Java || 1002 | MySQL |+------+-------+2 rows in set (0.00 sec)insert into student_course values(1,1001,89),(1,1002,90),(2,1001,88),(2,1002,56);mysql&gt; select * from student_course;+-----+------+-------+| sid | cid | score |+-----+------+-------+| 1 | 1001 | 89 || 1 | 1002 | 90 || 2 | 1001 | 88 || 2 | 1002 | 56 |+-----+------+-------+4 rows in set (0.00 sec)insert into student_course values( 1 , 1001 , 100 );ERROR 1062 ( 23000 ): Duplicate entry &#39;1-1001&#39; for key &#39;PRIMARY&#39;mysql&gt; desc student_course;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| sid | int( 11 ) | NO | PRI | NULL | || cid | int( 11 ) | NO | PRI | NULL | || score | int( 11 ) | YES | | NULL | |+-------+---------+------+-----+---------+-------+3 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>再举例</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE emp6(id INT NOT NULL,NAME VARCHAR( 20 ),pwd VARCHAR( 15 ),CONSTRAINT emp7_pk PRIMARY KEY(NAME,pwd));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="4-6-删除主键约束"><a href="#4-6-删除主键约束" class="headerlink" title="4. 6 删除主键约束"></a>4. 6 删除主键约束</h3><pre class="line-numbers language-none"><code class="language-none">alter table 表名称 drop primary key;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE student DROP PRIMARY KEY;ALTER TABLE emp5 DROP PRIMARY KEY;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。</p></blockquote><hr><h2 id="5-自增列：AUTO-INCREMENT"><a href="#5-自增列：AUTO-INCREMENT" class="headerlink" title="5. 自增列：AUTO_INCREMENT"></a>5. 自增列：AUTO_INCREMENT</h2><hr><h3 id="5-1-作用"><a href="#5-1-作用" class="headerlink" title="5. 1 作用"></a>5. 1 作用</h3><p>某个字段的值自增</p><h3 id="5-2-关键字"><a href="#5-2-关键字" class="headerlink" title="5. 2 关键字"></a>5. 2 关键字</h3><p>auto_increment</p><h3 id="5-3-特点和要求"><a href="#5-3-特点和要求" class="headerlink" title="5. 3 特点和要求"></a>5. 3 特点和要求</h3><ol><li>一个表最多只能有一个自增长列</li><li>当需要产生唯一标识符或顺序值时，可设置自增长</li><li>自增长列约束的列必须是键列（主键列，唯一键列）</li><li>自增约束的列的数据类型必须是整数类型</li><li>如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。</li></ol><p>错误演示：</p><pre class="line-numbers language-none"><code class="language-none">create table employee(eid int auto_increment,ename varchar( 20 ));# ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a keycreate table employee(eid int primary key,ename varchar( 20 ) unique key auto_increment);# ERROR 1063 (42000): Incorrect column specifier for column &#39;ename&#39; 因为ename不是整数类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-4-如何指定自增约束"><a href="#5-4-如何指定自增约束" class="headerlink" title="5. 4 如何指定自增约束"></a>5. 4 如何指定自增约束</h3><p><strong>(1) 建表时</strong></p><pre class="line-numbers language-none"><code class="language-none">create table 表名称(    字段名 数据类型 primary key auto_increment,    字段名 数据类型 unique key not null,    字段名 数据类型 unique key,    字段名 数据类型 not null default 默认值,);create table 表名称(    字段名 数据类型 default 默认值 ,    字段名 数据类型 unique key auto_increment,    字段名 数据类型 not null default 默认值,,    primary key(字段名));create table employee(    eid int primary key auto_increment,    ename varchar( 20 ));mysql&gt; desc employee;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| eid | int( 11 ) | NO | PRI | NULL | auto_increment || ename | varchar( 20 ) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+2 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(2) 建表后</strong></p><pre class="line-numbers language-none"><code class="language-none">alter table 表名称 modify 字段名 数据类型 auto_increment;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">create table employee(    eid int primary key ,    ename varchar( 20 ));alter table employee modify eid int auto_increment;mysql&gt; desc employee;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| eid | int( 11 ) | NO | PRI | NULL | auto_increment || ename | varchar( 20 ) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+2 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-5-如何删除自增约束"><a href="#5-5-如何删除自增约束" class="headerlink" title="5. 5 如何删除自增约束"></a>5. 5 如何删除自增约束</h3><pre class="line-numbers language-none"><code class="language-none">#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除alter table employee modify eid int;mysql&gt; desc employee;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| eid | int( 11 ) | NO | PRI | NULL | || ename | varchar( 20 ) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-6-MySQL-8-0-新特性—自增变量的持久化"><a href="#5-6-MySQL-8-0-新特性—自增变量的持久化" class="headerlink" title="5. 6 MySQL 8. 0 新特性—自增变量的持久化"></a>5. 6 MySQL 8. 0 新特性—自增变量的持久化</h3><p>在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT&#x3D;max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。 下面通过案例来对比不同的版本中自增变量是否持久化。 在MySQL 5.7版本中，测试步骤如下： 创建的数据表中包含自增主键的id字段，语句如下：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test1(id INT PRIMARY KEY AUTO_INCREMENT);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>插入 4 个空值，执行如下：</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO testVALUES( 0 ),( 0 ),( 0 ),( 0 );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查询数据表test1中的数据，结果如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 4 |+----+4 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除id为 4 的记录，语句如下：</p><pre class="line-numbers language-none"><code class="language-none">DELETE FROM test1 WHERE id &#x3D; 4 ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再次插入一个空值，语句如下：</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO test1 VALUES( 0 );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询此时数据表test1中的数据，结果如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 5 |+----+4 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果可以看出，虽然删除了id为 4 的记录，但是再次插入空值时，并没有重用被删除的 4 ，而是分配了5 。 删除id为 5 的记录，结果如下：</p><pre class="line-numbers language-none"><code class="language-none">DELETE FROM test1 where id&#x3D; 5 ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>重启数据库</strong> ，重新插入一个空值。</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO test1 values( 0 );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再次查询数据表test1中的数据，结果如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 4 |+----+4 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果可以看出，新插入的 0 值分配的是 4 ，按照重启前的操作逻辑，此处应该分配 6 。出现上述结果的主要原因是自增主键没有持久化。 在MySQL 5. 7 系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个<code>计数器</code>来决定的，而该计数器只在<code>内存中维护</code>，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。</p><p>在MySQL 8. 0 版本中，上述测试步骤最后一步的结果如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 6 |+----+4 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果可以看出，自增变量已经持久化了。</p><p>MySQL 8. 0 将自增主键的计数器持久化到<code>重做日志</code>中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。</p><hr><h2 id="6-FOREIGN-KEY-约束"><a href="#6-FOREIGN-KEY-约束" class="headerlink" title="6. FOREIGN KEY 约束"></a>6. FOREIGN KEY 约束</h2><hr><h3 id="6-1-作用"><a href="#6-1-作用" class="headerlink" title="6. 1 作用"></a>6. 1 作用</h3><p>限定某个表的某个字段的引用完整性。</p><p>比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分。</p><p><img src="/../pic/%E7%AC%AC13%E7%AB%A0_%E7%BA%A6%E6%9D%9F/1650272932586.png" alt="1650272932586"></p><h3 id="6-2-关键字"><a href="#6-2-关键字" class="headerlink" title="6. 2 关键字"></a>6. 2 关键字</h3><p>FOREIGN KEY</p><h3 id="6-3-主表和从表-x2F-父表和子表"><a href="#6-3-主表和从表-x2F-父表和子表" class="headerlink" title="6. 3 主表和从表&#x2F;父表和子表"></a>6. 3 主表和从表&#x2F;父表和子表</h3><p>主表（父表）：被引用的表，被参考的表</p><p>从表（子表）：引用别人的表，参考别人的表</p><p>例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。</p><p>例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是主表，选课表是从表。</p><h3 id="6-4-特点"><a href="#6-4-特点" class="headerlink" title="6. 4 特点"></a>6. 4 特点</h3><ol><li><p>从表的外键列，必须引用&#x2F;参考主表的主键或唯一约束的列</p><p>为什么？因为被依赖&#x2F;被参考的值必须是唯一的</p></li><li><p>在创建外键约束时，如果不给外键约束命名， 默认名不是列名，而是自动产生一个外键名 （例如student_ibfk_1;），也可以指定外键约束名。</p></li><li><p>创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表</p></li><li><p>删表时，先删从表（或先删除外键约束），再删除主表</p></li><li><p>当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据</p></li><li><p>在“从表”中指定外键约束，并且一个表可以建立多个外键约束</p></li><li><p>从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can’t create table’database.tablename’(errno: 150)”。</p><p>例如：都是表示部门编号，都是int类型。</p></li><li><p>当创建外键约束时，系统默认会在所在的列上建立对应的普通索引 。但是索引名是外键的约束名。（根据外键查询效率很高）</p></li><li><p>删除外键约束后，必须手动删除对应的索引</p></li></ol><h3 id="6-5-添加外键约束"><a href="#6-5-添加外键约束" class="headerlink" title="6. 5 添加外键约束"></a>6. 5 添加外键约束</h3><p>(1) 建表时</p><pre class="line-numbers language-none"><code class="language-none">create table 主表名称(    字段 1 数据类型 primary key,    字段 2 数据类型);create table 从表名称(    字段 1 数据类型 primary key,    字段 2 数据类型,    [CONSTRAINT &lt;外键约束名称&gt;] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段));#(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样#(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样-- FOREIGN KEY: 在表级指定子表中的列-- REFERENCES: 标示在父表中的列create table dept( #主表    did int primary key, #部门编号    dname varchar( 50 ) #部门名称);create table emp(#从表    eid int primary key,  #员工编号    ename varchar( 5 ), #员工姓名    deptid int, #员工所在的部门    foreign key (deptid) references dept(did) #在从表中指定外键约束    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号);说明：（ 1 ）主表dept必须先创建成功，然后才能创建emp表，指定外键成功。（ 2 ）删除表时，先删除从表emp，再删除主表dept<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2) 建表后</p><p>一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那么，就要用修改表的方式来补充定义。</p><p>格式：</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用字段) [on update xx][on delete xx];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE empADD [CONSTRAINT emp_dept_id_fk] FOREIGN KEY(dept_id) REFERENCES dept(dept_id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">create table dept(    did int primary key, #部门编号    dname varchar( 50 ) #部门名称);create table emp(    eid int primary key,  #员工编号    ename varchar( 5 ), #员工姓名    deptid int #员工所在的部门);#这两个表创建时，没有指定外键的话，那么创建顺序是随意alter table emp add foreign key (deptid) references dept(did);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-6-演示问题"><a href="#6-6-演示问题" class="headerlink" title="6. 6 演示问题"></a>6. 6 演示问题</h3><ol><li><p>失败：不是键列</p><pre class="line-numbers language-none"><code class="language-none">create table dept(    did int , #部门编号    dname varchar( 50 ) #部门名称);create table emp(    eid int primary key,  #员工编号    ename varchar( 5 ), #员工姓名    deptid int, #员工所在的部门    foreign key (deptid) references dept(did));#ERROR 1215 (HY000): Cannot add foreign key constraint 原因是dept的did不是键列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>失败：数据类型不一致</p><pre class="line-numbers language-none"><code class="language-none">create table dept(    did int primary key, #部门编号    dname varchar( 50 ) #部门名称);create table emp(    eid int primary key,  #员工编号    ename varchar( 5 ), #员工姓名    deptid char, #员工所在的部门    foreign key (deptid) references dept(did));#ERROR 1215 (HY000): Cannot add foreign key constraint 原因是从表的deptid字段和主表的did字段的数据类型不一致，并且要它俩的逻辑意义一致<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>成功，两个表字段名一样</p><pre class="line-numbers language-none"><code class="language-none">create table dept(    did int primary key, #部门编号    dname varchar( 50 ) #部门名称);create table emp(    eid int primary key,  #员工编号    ename varchar( 5 ), #员工姓名    did int, #员工所在的部门    foreign key (did) references dept(did)    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号    #是否重名没问题，因为两个did在不同的表中);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加、删除、修改问题</p><pre class="line-numbers language-none"><code class="language-none">create table dept(    did int primary key, #部门编号    dname varchar( 50 ) #部门名称);create table emp(    eid int primary key,  #员工编号    ename varchar( 5 ), #员工姓名    deptid int, #员工所在的部门    foreign key (deptid) references dept(did)    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">insert into dept values( 1001 ,&#39;教学部&#39;);insert into dept values( 1003 , &#39;财务部&#39;);insert into emp values( 1 ,&#39;张三&#39;, 1001 ); #添加从表记录成功，在添加这条记录时，要求部门表有 1001 部门insert into emp values( 2 ,&#39;李四&#39;, 1005 );#添加从表记录失败ERROR 1452 ( 23000 ): Cannot add（添加） or update（修改） a child row: a foreign keyconstraint fails (&#96;atguigudb&#96;.&#96;emp&#96;, CONSTRAINT &#96;emp_ibfk_1&#96; FOREIGN KEY (&#96;deptid&#96;)REFERENCES &#96;dept&#96; (&#96;did&#96;)) 从表emp添加记录失败，因为主表dept没有 1005 部门<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">mysql&gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1003 | 财务部 |+------+--------+2 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 |+-----+-------+--------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">update emp set deptid &#x3D; 1002 where eid &#x3D; 1 ;#修改从表失败ERROR 1452 ( 23000 ): Cannot add（添加） or update（修改） a child row（子表的记录）: a foreign key constraint fails（外键约束失败） (&#96;atguigudb&#96;.&#96;emp&#96;, CONSTRAINT &#96;emp_ibfk_1&#96; FOREIGN KEY (&#96;deptid&#96;) REFERENCES &#96;dept&#96; (&#96;did&#96;))  #部门表did字段现在没有 1002 的值，所以员工表中不能修改员工所在部门deptid为 1002update dept set did &#x3D; 1002 where did &#x3D; 1001 ;#修改主表失败ERROR 1451 ( 23000 ): Cannot delete（删除） or update（修改） a parent row（父表的记录）: a foreign key constraint fails (&#96;atguigudb&#96;.&#96;emp&#96;, CONSTRAINT &#96;emp_ibfk_1&#96; FOREIGN KEY (&#96;deptid&#96;) REFERENCES &#96;dept&#96; (&#96;did&#96;)) #部门表did的 1001 字段已经被emp引用了，所以部门表的 1001 字段就不能修改了。update dept set did &#x3D; 1002 where did &#x3D; 1003 ;#修改主表成功 因为部门表的 1003 部门没有被emp表引用，所以可以修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">delete from dept where did&#x3D; 1001 ; #删除主表失败ERROR 1451 ( 23000 ): Cannot delete（删除） or update（修改） a parent row（父表记录）: a foreign key constraint fails (&#96;atguigudb&#96;.&#96;emp&#96;, CONSTRAINT &#96;emp_ibfk_1&#96; FOREIGN KEY (&#96;deptid&#96;) REFERENCES &#96;dept&#96; (&#96;did&#96;))  #因为部门表did的 1001 字段已经被emp引用了，所以部门表的 1001 字段对应的记录就不能被删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><p>总结：约束关系是针对双方的</p><ul><li>添加了外键约束后，主表的修改和删除数据受约束</li><li>添加了外键约束后，从表的添加和修改数据受约束</li><li>在从表上建立外键，要求主表必须存在</li><li>删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除</li></ul><h3 id="6-7-约束等级"><a href="#6-7-约束等级" class="headerlink" title="6. 7 约束等级"></a>6. 7 约束等级</h3><ul><li><code>Cascade方式</code>：在父表上update&#x2F;delete记录时，同步update&#x2F;delete掉子表的匹配记录</li><li><code>Set null方式</code>：在父表上update&#x2F;delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null</li><li><code>No action方式</code>：如果子表中有匹配的记录，则不允许对父表对应候选键进行update&#x2F;delete操作</li><li><code>Restrict方式</code>：同no action， 都是立即检查外键约束</li><li><code>Set default方式</code>（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别</li></ul><p>如果没有指定等级，就相当于Restrict方式。</p><p>对于外键约束，最好是采用: <code>ON UPDATE CASCADE ON DELETE RESTRICT</code> 的方式。</p><p>（ 1 ）演示 1 ：on update cascade on delete set null</p><pre class="line-numbers language-none"><code class="language-none">create table dept(    did int primary key, #部门编号    dname varchar( 50 ) #部门名称);create table emp(    eid int primary key,  #员工编号    ename varchar( 5 ), #员工姓名    deptid int, #员工所在的部门    foreign key (deptid) references dept(did)  on update cascade on delete set null    #把修改操作设置为级联修改等级，把删除操作设置为set null等级);insert into dept values( 1001 ,&#39;教学部&#39;);insert into dept values( 1002 , &#39;财务部&#39;);insert into dept values( 1003 , &#39;咨询部&#39;);insert into emp values( 1 ,&#39;张三&#39;, 1001 ); #在添加这条记录时，要求部门表有1001部门insert into emp values( 2 ,&#39;李四&#39;, 1001 );insert into emp values( 3 ,&#39;王五&#39;, 1002 );mysql&gt; select * from dept;mysql&gt; select * from emp;#修改主表成功，从表也跟着修改，修改了主表被引用的字段1002为1004，从表的引用字段就跟着修改为1004了mysql&gt; update dept set did &#x3D; 1004 where did &#x3D; 1002 ;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1003 | 咨询部 || 1004 | 财务部 | #原来是 1002 ，修改为 1004+------+--------+3 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | 1004 | #原来是 1002 ，跟着修改为 1004+-----+-------+--------+3 rows in set (0.00 sec)#删除主表的记录成功，从表对应的字段的值被修改为nullmysql&gt; delete from dept where did &#x3D; 1001 ;Query OK, 1 row affected (0.01 sec)mysql&gt; select * from dept;+------+--------+| did | dname | #记录 1001 部门被删除了+------+--------+| 1003 | 咨询部 || 1004 | 财务部 |+------+--------+2 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | NULL | #原来引用 1001 部门的员工，deptid字段变为null| 2 | 李四 | NULL || 3 | 王五 | 1004 |+-----+-------+--------+3 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（ 2 ）演示 2 ：on update set null on delete cascade</p><pre class="line-numbers language-none"><code class="language-none">create table dept(    did int primary key, #部门编号    dname varchar( 50 ) #部门名称);create table emp(    eid int primary key,  #员工编号    ename varchar( 5 ), #员工姓名    deptid int, #员工所在的部门    foreign key (deptid) references dept(did)  on update set null on delete cascade    #把修改操作设置为set null等级，把删除操作设置为级联删除等级);insert into dept values( 1001 ,&#39;教学部&#39;);insert into dept values( 1002 , &#39;财务部&#39;);insert into dept values( 1003 , &#39;咨询部&#39;);insert into emp values( 1 ,&#39;张三&#39;, 1001 ); #在添加这条记录时，要求部门表有 1001 部门insert into emp values( 2 ,&#39;李四&#39;, 1001 );insert into emp values( 3 ,&#39;王五&#39;, 1002 );mysql&gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1002 | 财务部 || 1003 | 咨询部 |+------+--------+3 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | 1002 |+-----+-------+--------+3 rows in set (0.00 sec)mysql&gt; select * from dept;+------+--------+| did | dname |#修改主表，从表对应的字段设置为nullmysql&gt; update dept set did &#x3D; 1004 where did &#x3D; 1002 ;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1003 | 咨询部 || 1004 | 财务部 | #原来did是 1002+------+--------+3 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | NULL | #原来deptid是 1002 ，因为部门表 1002 被修改了， 1002 没有对应的了，就设置为null+-----+-------+--------+3 rows in set (0.00 sec)#删除主表的记录成功，主表的 1001 行被删除了，从表相应的记录也被删除了mysql&gt; delete from dept where did&#x3D; 1001 ;Query OK, 1 row affected (0.00 sec)mysql&gt; select * from dept;+------+--------+| did | dname | #部门表中 1001 部门被删除+------+--------+| 1003 | 咨询部 || 1004 | 财务部 |+------+--------+2 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |#原来 1001 部门的员工也被删除了+-----+-------+--------+| 3 | 王五 | NULL |+-----+-------+--------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（ 3 ）演示：on update cascade on delete cascade</p><pre class="line-numbers language-none"><code class="language-none">create table dept(    did int primary key, #部门编号    dname varchar( 50 ) #部门名称);create table emp(    eid int primary key,  #员工编号    ename varchar( 5 ), #员工姓名    deptid int, #员工所在的部门    foreign key (deptid) references dept(did)  on update cascade on delete cascade    #把修改操作设置为级联修改等级，把删除操作也设置为级联删除等级);insert into dept values( 1001 ,&#39;教学部&#39;);insert into dept values( 1002 , &#39;财务部&#39;);insert into dept values( 1003 , &#39;咨询部&#39;);insert into emp values( 1 ,&#39;张三&#39;, 1001 ); #在添加这条记录时，要求部门表有1001部门insert into emp values( 2 ,&#39;李四&#39;, 1001 );insert into emp values( 3 ,&#39;王五&#39;, 1002 );mysql&gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1002 | 财务部 || 1003 | 咨询部 |+------+--------+3 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | 1002 |+-----+-------+--------+3 rows in set (0.00 sec)#修改主表，从表对应的字段自动修改mysql&gt; update dept set did &#x3D; 1004 where did &#x3D; 1002 ;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1003 | 咨询部 || 1004 | 财务部 | #部门 1002 修改为 1004+------+--------+3 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | 1004 | #级联修改+-----+-------+--------+3 rows in set (0.00 sec)#删除主表的记录成功，主表的 1001 行被删除了，从表相应的记录也被删除了mysql&gt; delete from dept where did&#x3D; 1001 ;Query OK, 1 row affected (0.00 sec)mysql&gt; select * from dept;+------+--------+| did | dname | #1001部门被删除了+------+--------+| 1003 | 咨询部 || 1004 | 财务部 |+------+--------+2 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |  #1001部门的员工也被删除了+-----+-------+--------+| 3 | 王五 | 1004 |+-----+-------+--------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-8-删除外键约束"><a href="#6-8-删除外键约束" class="headerlink" title="6. 8 删除外键约束"></a>6. 8 删除外键约束</h3><p>流程如下：</p><pre class="line-numbers language-none"><code class="language-none">( 1 )第一步先查看约束名和删除外键约束SELECT * FROM information_schema.table_constraints WHERE table_name &#x3D; &#39;表名称&#39;;#查看某个表的约束名ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;（ 2 ）第二步查看索引名和删除索引。（注意，只能手动删除）SHOW INDEX FROM 表名称; #查看某个表的索引名ALTER TABLE 从表名 DROP INDEX 索引名;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM information_schema.table_constraints WHERE table_name &#x3D; &#39;emp&#39;;mysql&gt; alter table emp drop foreign key emp_ibfk_1;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; show index from emp;mysql&gt; alter table emp drop index deptid;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt;  show index from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-9-开发场景"><a href="#6-9-开发场景" class="headerlink" title="6. 9 开发场景"></a>6. 9 开发场景</h3><p><strong>问题 1 ：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否一定要建外键约束？</strong></p><p>答：不是的</p><p><strong>问题 2 ：建和不建外键约束有什么区别？</strong></p><p>答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限制。例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。</p><p>不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的<code>引用完整性</code>，只能<code>依靠程序员的自觉</code>，或者是<code>在Java程序中进行限定</code>。例如：在员工表中，可以添加一个员工的信息，它的部门指定为一个完全不存在的部门。</p><p><strong>问题 3 ：那么建和不建外键约束和查询有没有关系？</strong></p><p>答：没有</p><blockquote><p>在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会<code>因为外键约束的系统开销而变得非常慢</code>。所以， MySQL 允许你不使用系统自带的外键约束，在<code>应用层面</code>完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</p></blockquote><h3 id="6-10-阿里开发规范"><a href="#6-10-阿里开发规范" class="headerlink" title="6. 10 阿里开发规范"></a>6. 10 阿里开发规范</h3><p>【<code>强制</code>】不得使用外键与级联，一切外键概念必须在应用层解决。</p><p>说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于<code>单机低并发</code>，不适合<code>分布式</code>、<code>高并发集群</code>；级联更新是强阻塞，存在数据库<code>更新风暴</code>的风险；外键影响数据库的<code>插入速度</code>。</p><hr><h2 id="7-CHECK-约束"><a href="#7-CHECK-约束" class="headerlink" title="7. CHECK 约束"></a>7. CHECK 约束</h2><hr><h3 id="7-1-作用"><a href="#7-1-作用" class="headerlink" title="7. 1 作用"></a>7. 1 作用</h3><p>检查某个字段的值是否符号xx要求，一般指的是值的范围</p><h3 id="7-2-、关键字"><a href="#7-2-、关键字" class="headerlink" title="7. 2 、关键字"></a>7. 2 、关键字</h3><p>CHECK</p><h3 id="7-3-、说明：MySQL-5-7-不支持"><a href="#7-3-、说明：MySQL-5-7-不支持" class="headerlink" title="7. 3 、说明：MySQL 5. 7 不支持"></a>7. 3 、说明：MySQL 5. 7 不支持</h3><p>MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警告</p><p>但是 <strong>MySQL 8.0中可以使用check约束了</strong> 。</p><pre class="line-numbers language-none"><code class="language-none">create table employee(    eid int primary key,    ename varchar( 5 ),    gender char check (&#39;男&#39; or &#39;女&#39;));insert into employee values( 1 ,&#39;张三&#39;,&#39;妖&#39;);mysql&gt; select * from employee;+-----+-------+--------+| eid | ename | gender |+-----+-------+--------+| 1 | 张三 | 妖 |+-----+-------+--------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>再举例</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE temp(    id INT AUTO_INCREMENT,    NAME VARCHAR( 20 ),    age INT CHECK(age &gt; 20 ),    PRIMARY KEY(id));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>再举例</p><pre class="line-numbers language-none"><code class="language-none">age tinyint check(age &gt; 20 ) 或 sex char( 2 ) check(sex in(‘男’,’女’))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>再举例</p><pre class="line-numbers language-none"><code class="language-none">CHECK(height&gt;&#x3D; 0 AND height&lt; 3 )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><h2 id="8-DEFAULT约束"><a href="#8-DEFAULT约束" class="headerlink" title="8. DEFAULT约束"></a>8. DEFAULT约束</h2><hr><h3 id="8-1-作用"><a href="#8-1-作用" class="headerlink" title="8. 1 作用"></a>8. 1 作用</h3><p>给某个字段&#x2F;某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。</p><h3 id="8-2-关键字"><a href="#8-2-关键字" class="headerlink" title="8. 2 关键字"></a>8. 2 关键字</h3><p>DEFAULT</p><h3 id="8-3-如何给字段加默认值"><a href="#8-3-如何给字段加默认值" class="headerlink" title="8. 3 如何给字段加默认值"></a>8. 3 如何给字段加默认值</h3><p>(1) 建表时</p><pre class="line-numbers language-none"><code class="language-none">create table 表名称(    字段名 数据类型 primary key,    字段名 数据类型 unique key not null,    字段名 数据类型 unique key,    字段名 数据类型 not null default 默认值,);create table 表名称(    字段名 数据类型 default 默认值 ,    字段名 数据类型 not null default 默认值,    字段名 数据类型 not null default 默认值,    primary key(字段名),    unique key(字段名));说明：默认值约束一般不在唯一键和主键列上加create table employee(    eid int primary key,    ename varchar( 20 ) not null,    gender char default &#39;男&#39;,    tel char( 11 ) not null default &#39;&#39; #默认是空字符串);mysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int( 11 ) | NO | PRI | NULL | || ename | varchar( 20 ) | NO | | NULL | || gender | char( 1 ) | YES | | 男 | || tel | char( 11 ) | NO | | | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)insert into employee values( 1 ,&#39;汪飞&#39;,&#39;男&#39;,&#39;13700102535&#39;); #成功mysql&gt; select * from employee;+-----+-------+--------+-------------+| eid | ename | gender | tel |+-----+-------+--------+-------------+| 1 | 汪飞 | 男 | 13700102535 |+-----+-------+--------+-------------+1 row in set (0.00 sec)insert into employee(eid,ename) values( 2 ,&#39;天琪&#39;); #成功mysql&gt; select * from employee;+-----+-------+--------+-------------+| eid | ename | gender | tel |+-----+-------+--------+-------------+| 1 | 汪飞 | 男 | 13700102535 || 2 | 天琪 | 男 | |+-----+-------+--------+-------------+2 rows in set (0.00 sec)insert into employee(eid,ename) values( 3 ,&#39;二虎&#39;);#ERROR 1062 (23000): Duplicate entry &#39;&#39; for key &#39;tel&#39;#如果tel有唯一性约束的话会报错，如果tel没有唯一性约束，可以添加成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再举例：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE myemp(    id INT AUTO_INCREMENT PRIMARY KEY,    NAME VARCHAR( 15 ),    salary DOUBLE( 10 , 2 ) DEFAULT 2000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2) 建表后</p><pre class="line-numbers language-none"><code class="language-none">alter table 表名称 modify 字段名 数据类型 default 默认值;#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了#同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了alter table 表名称 modify 字段名 数据类型 default 默认值 not null;create table employee(eid int primary key,ename varchar( 20 ),gender char,tel char( 11 ) not null);mysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int( 11 ) | NO | PRI | NULL | || ename | varchar( 20 ) | YES | | NULL | || gender | char( 1 ) | YES | | NULL | || tel | char( 11 ) | NO | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)alter table employee modify gender char default &#39;男&#39;;  #给gender字段增加默认值约束alter table employee modify tel char( 11 ) default &#39;&#39;; #给tel字段增加默认值约束mysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int( 11 ) | NO | PRI | NULL | || ename | varchar( 20 ) | YES | | NULL | || gender | char( 1 ) | YES | | 男 | || tel | char( 11 ) | YES | | | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)alter table employee modify tel char( 11 ) default &#39;&#39; not null;#给tel字段增加默认值约束，并保留非空约束mysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int( 11 ) | NO | PRI | NULL | || ename | varchar( 20 ) | YES | | NULL | || gender | char( 1 ) | YES | | 男 | || tel | char( 11 ) | NO | | | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-4-如何删除默认值约束"><a href="#8-4-如何删除默认值约束" class="headerlink" title="8. 4 如何删除默认值约束"></a>8. 4 如何删除默认值约束</h3><pre class="line-numbers language-none"><code class="language-none">alter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束alter table 表名称 modify 字段名 数据类型 not null; #删除默认值约束，保留非空约束alter table employee modify gender char; #删除gender字段默认值约束，如果有非空约束，也一并删除alter table employee modify tel char( 11 )  not null;#删除tel字段默认值约束，保留非空约束mysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int( 11 ) | NO | PRI | NULL | || ename | varchar( 20 ) | YES | | NULL | || gender | char( 1 ) | YES | | NULL | || tel | char( 11 ) | NO | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="9-面试"><a href="#9-面试" class="headerlink" title="9. 面试"></a>9. 面试</h2><hr><p><strong>面试 1 、为什么建表时，加 not null default ‘’ 或 default 0</strong></p><p>答：不想让表中出现null值。</p><p><strong>面试 2 、为什么不想要 null 的值</strong></p><p>答:（ 1 ）不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通常返回null。</p><p>（ 2 ）效率不高。影响提高索引效果。因此，我们往往在建表时 not null default ‘’ 或 default 0</p><p><strong>面试 3 、带AUTO_INCREMENT约束的字段值是从 1 开始的吗？</strong></p><p>答：在MySQL中，默认AUTO_INCREMENT的初始值是 1 ，每新增一条记录，字段值自动加 1 。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定id值为 5 ，则以后插入的记录的id值就会从 6 开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。</p><p><strong>面试 4 、并不是每个表都可以任意选择存储引擎？</strong></p><p>答：外键约束（FOREIGN KEY）不能跨引擎使用。<br>MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据类型</title>
      <link href="/2022/07/17/di-12-zhang-mysql-shu-ju-lei-xing-jing-jiang/"/>
      <url>/2022/07/17/di-12-zhang-mysql-shu-ju-lei-xing-jing-jiang/</url>
      
        <content type="html"><![CDATA[<h1 id="第12章-MySQL数据类型精讲"><a href="#第12章-MySQL数据类型精讲" class="headerlink" title="第12章_MySQL数据类型精讲"></a>第12章_MySQL数据类型精讲</h1><h2 id="1-MySQL中的数据类型"><a href="#1-MySQL中的数据类型" class="headerlink" title="1. MySQL中的数据类型"></a>1. MySQL中的数据类型</h2><hr><table><thead><tr><th>类型</th><th>类型举例</th></tr></thead><tbody><tr><td>整数类型</td><td>TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT</td></tr><tr><td>浮点类型</td><td>FLOAT、DOUBLE</td></tr><tr><td>定点数类型</td><td>DECIMAL</td></tr><tr><td>位类型</td><td>BIT</td></tr><tr><td>日期时间类型</td><td>YEAR、TIME、DATE、DATETIME、TIMESTAMP</td></tr><tr><td>文本字符串类型</td><td>CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td></tr><tr><td>枚举类型</td><td>ENUM</td></tr><tr><td>集合类型</td><td>SET</td></tr><tr><td>二进制字符串类型</td><td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td></tr><tr><td>JSON类型</td><td>JSON对象、JSON数组</td></tr><tr><td>空间数据类型</td><td>单值类型：GEOMETRY、POINT、LINESTRING、POLYGON； 集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</td></tr></tbody></table><p>常见数据类型的属性，如下：</p><table><thead><tr><th>MySQL关键字</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>数据列可包含NULL值</td></tr><tr><td>NOT NULL</td><td>数据列不允许包含NULL值</td></tr><tr><td>DEFAULT</td><td>默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键</td></tr><tr><td>AUTO_INCREMENT</td><td>自动递增，适用于整数类型</td></tr><tr><td>UNSIGNED</td><td>无符号</td></tr><tr><td>CHARACTER SET name</td><td>指定一个字符集</td></tr></tbody></table><hr><h2 id="2-整数类型"><a href="#2-整数类型" class="headerlink" title="2. 整数类型"></a>2. 整数类型</h2><hr><h3 id="2-1-类型介绍"><a href="#2-1-类型介绍" class="headerlink" title="2. 1 类型介绍"></a>2. 1 类型介绍</h3><p>整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。</p><p>它们的区别如下表所示：</p><table><thead><tr><th>整数类型</th><th>字节</th><th>有符号数取值范围</th><th>无符号数取值范围</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>- 128 ~ 127</td><td>0 ~ 255</td></tr><tr><td>SMALLINT</td><td>2</td><td>- 32768 ~ 32767</td><td>0 ~ 65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>- 8388608 ~ 8388607</td><td>0 ~ 16777215</td></tr><tr><td>INT、INTEGER</td><td>4</td><td>- 2147483648 ~ 2147483647</td><td>0 ~ 4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-9223372036854775808~9223372036854775807</td><td>0~18446744073709551615</td></tr></tbody></table><h3 id="2-2-可选属性"><a href="#2-2-可选属性" class="headerlink" title="2. 2 可选属性"></a>2. 2 可选属性</h3><p><strong>整数类型的可选属性有三个：</strong></p><h4 id="2-2-1-M"><a href="#2-2-1-M" class="headerlink" title="2. 2. 1 M"></a>2. 2. 1 M</h4><p><code>M</code>: 表示显示宽度，M的取值范围是( 0 , 255 )。例如，int( 5 )：当数据宽度小于 5 位的时候在数字前面需要用字符填满宽度。该项功能需要配合“<code>ZEROFILL</code>”使用，表示用“ 0 ”填满宽度，否则指定显示宽度无效。</p><p>如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会截断或插入失败？</p><p>答案：不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，即<code>显示宽度与类型可以存储的值范围无关</code>。 <strong>从MySQL 8. 0. 17 开始，整数数据类型不推荐使用显示宽度属性。</strong></p><p>整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。</p><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_int1 ( x TINYINT, y SMALLINT, z MEDIUMINT, m INT, n BIGINT );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看表结构 （MySQL 5. 7 中显式如下，MySQL 8 中不再显式范围）</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; desc test_int1;+-------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+--------------+------+-----+---------+-------+| x | tinyint( 4 ) | YES | | NULL | || y | smallint( 6 ) | YES | | NULL | || z | mediumint( 9 ) | YES | | NULL | || m | int( 11 ) | YES | | NULL | || n | bigint( 20 ) | YES | | NULL | |+-------+--------------+------+-----+---------+-------+5 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TINYINT有符号数和无符号数的取值范围分别为- 128 ~ 127 和 0 ~ 255 ，由于负号占了一个数字位，因此TINYINT默认的显示宽度为 4 。同理，其他整数类型的默认显示宽度与其有符号数的最小值的宽度相同。</p><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_int2(f1 INT,f2 INT( 5 ),f3 INT( 5 ) ZEROFILL)DESC test_int2;INSERT INTO test_int2(f1,f2,f3)VALUES( 1 , 123 , 123 );INSERT INTO test_int2(f1,f2)VALUES( 123456 , 123456 );INSERT INTO test_int2(f1,f2,f3)VALUES( 123456 , 123456 , 123456 );mysql&gt; SELECT * FROM test_int2;+--------+--------+--------+| f1 | f2 | f3 |+--------+--------+--------+| 1 | 123 | 00123 || 123456 | 123456 | NULL || 123456 | 123456 | 123456 |+--------+--------+--------+3 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2-UNSIGNED"><a href="#2-2-2-UNSIGNED" class="headerlink" title="2. 2. 2 UNSIGNED"></a>2. 2. 2 UNSIGNED</h4><p><code>UNSIGNED</code>: 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无符号整数类型的最小取值为 0 。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型。</p><p>int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)。</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_int3(f1 INT UNSIGNED);mysql&gt; desc test_int3;+-------+------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| f1 | int( 10 ) unsigned | YES | | NULL | |+-------+------------------+------+-----+---------+-------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-3-ZEROFILL"><a href="#2-2-3-ZEROFILL" class="headerlink" title="2. 2. 3 ZEROFILL"></a>2. 2. 3 ZEROFILL</h4><p><code>ZEROFILL</code>: 0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果指定了ZEROFILL只是表示不够M位时，用 0 在左边填充，如果超过M位，只要不超过数据存储范围即可。</p><p>原来，在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都是占用 4 bytes 的存储空间。也就是说，<strong>int(M)，必须和UNSIGNED ZEROFILL一起使用才有意义。</strong>如果整数值超过M位，就按照实际位数存储。只是无须再用字符 0 进行填充。</p><h3 id="2-3-适用场景"><a href="#2-3-适用场景" class="headerlink" title="2. 3 适用场景"></a>2. 3 适用场景</h3><p><code>TINYINT</code>：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。</p><p><code>SMALLINT</code>：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。</p><p><code>MEDIUMINT</code>：用于较大整数的计算，比如车站每日的客流量等。</p><p><code>INT、INTEGER</code>：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。</p><p><code>BIGINT</code>：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等。</p><h3 id="2-4-如何选择？"><a href="#2-4-如何选择？" class="headerlink" title="2. 4 如何选择？"></a>2. 4 如何选择？</h3><p>在评估用哪种整数类型的时候，你需要考虑<code>存储空间</code>和<code>可靠性</code>的平衡问题：一方 面，用占用字节数少的整数类型可以节省存储空间；另一方面，要是为了节省存储空间， 使用的整数类型取值范围太小，一旦遇到超出取值范围的情况，就可能引起<code>系统错误</code>，影响可靠性。</p><p>举个例子，商品编号采用的数据类型是 INT。原因就在于，客户门店中流通的商品种类较多，而且，每天都有旧商品下架，新商品上架，这样不断迭代，日积月累。</p><p>如果使用 SMALLINT 类型，虽然占用字节数比 INT 类型的整数少，但是却不能保证数据不会超出范围65535 。相反，使用 INT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。</p><p>你要注意的是，在实际工作中， <strong>系统故障产生的成本远远超过增加几个字段存储空间所产生的成本</strong> 。因此，我建议你首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。</p><hr><h2 id="3-浮点类型"><a href="#3-浮点类型" class="headerlink" title="3. 浮点类型"></a>3. 浮点类型</h2><hr><h3 id="3-1-类型介绍"><a href="#3-1-类型介绍" class="headerlink" title="3. 1 类型介绍"></a>3. 1 类型介绍</h3><p>浮点数和定点数类型的特点是可以<code>处理小数</code>，你可以把整数看成小数的一个特例。因此，浮点数和定点数的使用场景，比整数大多了。 MySQL支持的浮点数类型，分别是 FLOAT、DOUBLE、REAL。</p><ul><li><p>FLOAT 表示单精度浮点数；</p></li><li><p>DOUBLE 表示双精度浮点数；<br><img src="/../pic/%E7%AC%AC12%E7%AB%A0_MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/1650166255153.png" alt="1650166255153"></p></li><li><p>REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用“<code>REAL_AS_FLOAT</code>”，那 么，MySQL 就认为REAL 是 FLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下 SQL 语句实现：</p><pre class="line-numbers language-none"><code class="language-none">SET sql_mode &#x3D; “REAL_AS_FLOAT”;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>问题 1</strong> ： FLOAT 和 DOUBLE 这两种数据类型的区别是啥呢？</p><p>FLOAT 占用字节数少，取值范围小；DOUBLE 占用字节数多，取值范围也大。</p><p><strong>问题 2</strong> ： 为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于有符号数取值范围大于等于零的部分呢？</p><p>MySQL 存储浮点数的格式为：<code>符号(S)</code>、<code>尾数(M)</code>和 <code>阶码(E)</code>。因此，无论有没有符号，MySQL 的浮点数都会存储表示符号的部分。因此， 所谓的无符号数取值范围，其实就是有符号数取值范围大于等于零的部分。</p><h3 id="3-2-数据精度说明"><a href="#3-2-数据精度说明" class="headerlink" title="3. 2 数据精度说明"></a>3. 2 数据精度说明</h3><p>对于浮点类型，在MySQL中单精度值使用 <code>4</code> 个字节，双精度值使用 <code>8</code> 个字节。</p><ul><li><p>MySQL允许使用<code>非标准语法</code>（其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么用）：<code>FLOAT(M,D)</code>或<code>DOUBLE(M,D)</code>。这里，M称为<code>精度</code>，D称为<code>标度</code>。(M,D)中 M&#x3D;整数位+小数位，D&#x3D;小数位。 D&lt;&#x3D;M&lt;&#x3D; 255 ， 0 &lt;&#x3D;D&lt;&#x3D; 30 。<br>例如，定义为FLOAT( 5 , 2 )的一个列可以显示为- 999. 99 - 999. 99 。如果超过这个范围会报错。</p></li><li><p>FLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定）来显示。</p></li><li><p>说明：浮点类型，也可以加<code>UNSIGNED</code>，但是不会改变数据范围，例如：FLOAT( 3 , 2 ) UNSIGNED仍然只能表示 0 - 9. 99 的范围。</p></li><li><p>不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下：</p><ul><li>如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值</li><li>如果存储时，小数点部分若超出范围，就分以下情况：<ul><li>若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。例如在FLOAT( 5 , 2 )列内插入 999. 009 ，近似结果是 999. 01 。</li><li>若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如FLOAT( 5 , 2 )列内插入999.995 和- 999. 995 都会报错。</li></ul></li></ul></li><li><p><strong>从MySQL 8. 0. 17 开始，FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用</strong> ，将来可能被移除。另外，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了，将来也可能被移除。</p></li><li><p>举例</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_double1(f1 FLOAT,f2 FLOAT( 5 , 2 ),f3 DOUBLE,f4 DOUBLE( 5 , 2 ));DESC test_double1;INSERT INTO test_doubleVALUES(123.456,123.456,123.4567,123.45);#Out of range value for column &#39;f2&#39; at row 1INSERT INTO test_doubleVALUES(123.456,1234.456,123.4567,123.45);SELECT * FROM test_double1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="3-3-精度误差说明"><a href="#3-3-精度误差说明" class="headerlink" title="3. 3 精度误差说明"></a>3. 3 精度误差说明</h3><p>浮点数类型有个缺陷，就是不精准。下面我来重点解释一下为什么 MySQL 的浮点数不够精准。比如，我们设计一个表，有f 1 这个字段，插入值分别为 0. 47 , 0. 44 , 0. 19 ，我们期待的运行结果是： 0. 47 + 0. 44 + 0. 19 &#x3D;1.1 。而使用sum之后查询：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_double2(f1 DOUBLE);INSERT INTO test_doubleVALUES(0.47),(0.44),(0.19);mysql&gt; SELECT SUM(f1)-&gt; FROM test_double2;+--------------------+| SUM(f1) |+--------------------+| 1.0999999999999999 |+--------------------+1 row in set (0.00 sec)mysql&gt; SELECT SUM(f1) &#x3D; 1.1,1.1 &#x3D; 1.-&gt; FROM test_double2;+---------------+-----------+| SUM(f1) &#x3D; 1.1 | 1.1 &#x3D; 1.1 |+---------------+-----------+| 0 | 1 |+---------------+-----------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查询结果是 1. 0999999999999999 。看到了吗？虽然误差很小，但确实有误差。 你也可以尝试把数据类型改成 FLOAT，然后运行求和查询，得到的是， 1. 0999999940395355 。显然，误差更大了。</p><p>那么，为什么会存在这样的误差呢？问题还是出在 MySQL 对浮点类型数据的存储方式上。</p><p>MySQL 用 4 个字节存储 FLOAT 类型数据，用 8 个字节来存储 DOUBLE 类型数据。无论哪个，都是采用二进制的方式来进行存储的。比如 9. 625 ，用二进制来表达，就是 1001. 101 ，或者表达成 1. 001101 × 2 ^ 3 。如果尾数不是 0 或 5 （比如 9. 624 ），你就无法用一个二进制数来精确表达。进而，就只好在取值允许的范围内进行四舍五入。</p><p>在编程中，如果用到浮点数，要特别注意误差问题，<strong>因为浮点数是不准确的，所以我们要避免使用“&#x3D;”来判断两个数是否相等。</strong>同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成不可挽回的损失。那么，MySQL 有没有精准的数据类型呢？当然有，这就是定点数类型：<code>DECIMAL</code>。</p><hr><h2 id="4-定点数类型"><a href="#4-定点数类型" class="headerlink" title="4. 定点数类型"></a>4. 定点数类型</h2><hr><h3 id="4-1-类型介绍"><a href="#4-1-类型介绍" class="headerlink" title="4. 1 类型介绍"></a>4. 1 类型介绍</h3><ul><li><p>MySQL中的定点数类型只有 DECIMAL 一种类型。</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>含义</th></tr></thead><tbody><tr><td>DECIMAL(M,D),DEC,NUMERIC</td><td>M+2字节</td><td>有效范围由M和D决定</td></tr></tbody></table><p>使用 DECIMAL(M,D) 的方式表示高精度小数。其中，M被称为精度，D被称为标度。0&lt;&#x3D;M&lt;&#x3D;65，0&lt;&#x3D;D&lt;&#x3D;30，D&lt;M。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99。</p></li><li><p><strong>DECIMAL(M,D)的最大取值范围与DOUBLE类型一样</strong> ，但是有效的数据范围是由M和D决定的。<br>DECIMAL 的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些。</p></li><li><p>定点数在MySQL内部是以<code>字符串</code>的形式进行存储，这就决定了它一定是精准的。</p></li><li><p>当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行四舍五入处理。</p></li><li><p><strong>浮点数 vs 定点数</strong></p><ul><li>浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）</li><li>定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉及金额计算的场景）</li></ul></li><li><p>举例</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_decimal1(f1 DECIMAL,f2 DECIMAL( 5 , 2 ));DESC test_decimal1;INSERT INTO test_decimal1(f1,f2)VALUES(123.123,123.456);#Out of range value for column &#39;f2&#39; at row 1INSERT INTO test_decimal1(f2)VALUES(1234.34);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM test_decimal1;+------+--------+| f1 | f2 |+------+--------+| 123 | 123.46 |+------+--------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>举例<br>我们运行下面的语句，把test_double2表中字段“f1”的数据类型修改为 DECIMAL(5,2)：</p><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE test_doubleMODIFY f1 DECIMAL( 5 , 2 );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后，我们再一次运行求和语句：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT SUM(f1)-&gt; FROM test_double2;+---------+| SUM(f1) |+---------+|  1.10 |+---------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT SUM(f1) &#x3D; 1.-&gt; FROM test_double2;+---------------+| SUM(f1) &#x3D; 1.1 |+---------------+| 1 |+---------------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="4-2-开发中经验"><a href="#4-2-开发中经验" class="headerlink" title="4. 2 开发中经验"></a>4. 2 开发中经验</h3><blockquote><p>“由于 DECIMAL 数据类型的精准性，在我们的项目中，除了极少数（比如商品编号）用到整数类型外，其他的数值都用的是 DECIMAL，原因就是这个项目所处的零售行业，要求精准，一分钱也不能差。 ” ——来自某项目经理</p></blockquote><hr><h2 id="5-位类型：BIT"><a href="#5-位类型：BIT" class="headerlink" title="5. 位类型：BIT"></a>5. 位类型：BIT</h2><hr><p>BIT类型中存储的是二进制值，类似 010110 。</p><table><thead><tr><th>二进制字符串类型</th><th>长度</th><th>长度范围</th><th>占用空间</th></tr></thead><tbody><tr><td>BIT(M)</td><td>M</td><td>1 &lt;&#x3D; M &lt;&#x3D; 64</td><td>约为(M + 7 )&#x2F; 8 个字节</td></tr></tbody></table><p>BIT类型，如果没有指定(M)，默认是 1 位。这个 1 位，表示只能存 1 位的二进制值。这里(M)是表示二进制的位数，位数最小值为 1 ，最大值为 64 。</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_bit1(f1 BIT,f2 BIT( 5 ),f3 BIT( 64 ));INSERT INTO test_bit1(f1)VALUES( 1 );#Data too long for column &#39;f1&#39; at row 1INSERT INTO test_bit1(f1)VALUES( 2 );INSERT INTO test_bit1(f2)VALUES( 23 );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：在向BIT类型的字段中插入数据时，一定要确保插入的数据在BIT类型支持的范围内。</p><p>使用SELECT命令查询位字段时，可以用<code>BIN()</code>或<code>HEX()</code>函数进行读取。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM test_bit1;+------------+------------+------------+| f1 | f2 | f3 |+------------+------------+------------+| 0x01 | NULL | NULL || NULL | 0x17 | NULL |+------------+------------+------------+2 rows in set (0.00 sec)mysql&gt; SELECT BIN(f2),HEX(f2)-&gt; FROM test_bit1;+---------+---------+| BIN(f2) | HEX(f2) |+---------+---------+| NULL | NULL || 10111 | 17 |+---------+---------+2 rows in set (0.00 sec)mysql&gt; SELECT f2 + 0-&gt; FROM test_bit1;+--------+| f2 + 0 |+--------+| NULL || 23 |+--------+2 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，使用b+ 0 查询数据时，可以直接查询出存储的十进制数据的值。</p><hr><h2 id="6-日期与时间类型"><a href="#6-日期与时间类型" class="headerlink" title="6. 日期与时间类型"></a>6. 日期与时间类型</h2><hr><p>日期与时间是重要的信息，在我们的系统中，几乎所有的数据表都用得到。原因是客户需要知道数据的时间标签，从而进行数据查询、统计和处理。</p><p>MySQL有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL 8. 0 版本支持的日期和时间类型主要有：YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。</p><ul><li>YEAR类型通常用来表示年</li><li>DATE类型通常用来表示年、月、日</li><li>TIME类型通常用来表示时、分、秒</li><li>DATETIME类型通常用来表示年、月、日、时、分、秒</li><li>TIMESTAMP类型通常用来表示带时区的年、月、日、时、分、秒</li></ul><table><thead><tr><th>类型</th><th>名称</th><th>字节</th><th>日期格式</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td><td>1</td><td>YYYY或YY</td><td>1901</td><td>2155</td></tr><tr><td>TIME</td><td>时间</td><td>3</td><td>HH:MM:SS</td><td>- 838 : 59 : 59</td><td>838 : 59 : 59</td></tr><tr><td>DATE</td><td>日期</td><td>3</td><td>YYYY-MM-DD</td><td>1000 - 01 - 01</td><td>9999 - 12 - 03</td></tr><tr><td>DATETIME</td><td>日期 时间</td><td>8</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000 - 01 - 01 00 : 00 : 00</td><td>9999 - 12 - 31 23 : 59 : 59</td></tr><tr><td>TIMESTAMP</td><td>日期 时间</td><td>4</td><td>YYYY-MM-DD HH:MM:SS</td><td>1970 - 01 - 01 00 : 00 : 00 UTC</td><td>2038 - 01 - 19 03 : 14 : 07 UTC</td></tr></tbody></table><p>可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，你要根据实际需要灵活选取。</p><p>为什么时间类型 TIME 的取值范围不是 - 23 : 59 : 59 ～ 23 : 59 : 59 呢？原因是 MySQL 设计的 TIME 类型，不光表示一天之内的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过 24 小时。</p><h3 id="6-1-YEAR类型"><a href="#6-1-YEAR类型" class="headerlink" title="6. 1 YEAR类型"></a>6. 1 YEAR类型</h3><p>YEAR类型用来表示年份，在所有的日期时间类型中所占用的存储空间最小，只需要 1 个字节的存储空间。</p><p>在MySQL中，YEAR有以下几种存储格式：</p><ul><li>以 4 位字符串或数字格式表示YEAR类型，其格式为YYYY，最小值为 1901 ，最大值为2155。</li><li>以 2 位字符串格式表示YEAR类型，最小值为 00 ，最大值为 99 。<ul><li>当取值为 01 到 69 时，表示 2001 到 2069 ；</li><li>当取值为 70 到 99 时，表示 1970 到 1999 ；</li><li>当取值整数的 0 或 00 添加的话，那么是 0000 年；</li><li>当取值是日期&#x2F;字符串的’ 0 ‘添加的话，是 2000 年。</li></ul></li></ul><p><strong>从MySQL 5. 5. 27 开始， 2 位格式的YEAR已经不推荐使用</strong> 。YEAR默认格式就是“YYYY”，没必要写成YEAR( 4 )，从MySQL 8. 0. 19 开始，不推荐使用指定显示宽度的YEAR( 4 )数据类型。</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_year(f1 YEAR,f2 YEAR( 4 ));mysql&gt; DESC test_year;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| f1 | year( 4 ) | YES | | NULL | || f2 | year( 4 ) | YES | | NULL | |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)INSERT INTO test_yearVALUES(&#39;2020&#39;,&#39;2021&#39;);mysql&gt; SELECT * FROM test_year;+------+------+| f1 | f2 |+------+------+| 2020 | 2021 |+------+------+1 rows in set (0.00 sec)INSERT INTO test_yearVALUES(&#39;45&#39;,&#39;71&#39;);INSERT INTO test_yearVALUES( 0 ,&#39;0&#39;);mysql&gt; SELECT * FROM test_year;+------+------+| f1 | f2 |+------+------+| 2020 | 2021 || 2045 | 1971 || 0000 | 2000 |+------+------+3 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-DATE类型"><a href="#6-2-DATE类型" class="headerlink" title="6. 2 DATE类型"></a>6. 2 DATE类型</h3><p>DATE类型表示日期，没有时间部分，格式为<code>YYYY-MM-DD</code>，其中，YYYY表示年份，MM表示月份，DD表示日期。需要 <code>3 个字节</code>的存储空间。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li>以<code>YYYY-MM-DD</code>格式或者<code>YYYYMMDD</code>格式表示的字符串日期，其最小取值为 1000 - 01 - 01 ，最大取值为9999 - 12 - 03 。YYYYMMDD格式会被转化为YYYY-MM-DD格式。</li><li>以<code>YY-MM-DD</code>格式或者<code>YYMMDD</code>格式表示的字符串日期，此格式中，年份为两位数值或字符串满足YEAR类型的格式条件为：当年份取值为 00 到 69 时，会被转化为 2000 到 2069 ；当年份取值为70 到 99时，会被转化为 1970 到 1999 。</li><li>使用<code>CURRENT_DATE()</code>或者<code>NOW()</code>函数，会插入当前系统的日期。</li></ul><p>举例：</p><p>创建数据表，表中只包含一个DATE类型的字段f1 。</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_date1(f1 DATE);Query OK, 0 rows affected (0.13 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>插入数据：</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO test_dateVALUES (&#39;2020-10-01&#39;), (&#39;20201001&#39;),( 20201001 );INSERT INTO test_dateVALUES (&#39;00-01-01&#39;), (&#39;000101&#39;), (&#39;69-10-01&#39;), (&#39;691001&#39;), (&#39;70-01-01&#39;), (&#39;700101&#39;),(&#39;99-01-01&#39;), (&#39;990101&#39;);INSERT INTO test_dateVALUES ( 000301 ), ( 690301 ), ( 700301 ), ( 990301 );INSERT INTO test_dateVALUES (CURRENT_DATE()), (NOW());SELECT *FROM test_date1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3-TIME类型"><a href="#6-3-TIME类型" class="headerlink" title="6. 3 TIME类型"></a>6. 3 TIME类型</h3><p>TIME类型用来表示时间，不包含日期部分。在MySQL中，需要 <code>3 个字节</code>的存储空间来存储TIME类型的数据，可以使用“HH:MM:SS”格式来表示TIME类型，其中，HH表示小时，MM表示分钟，SS表示秒。</p><p>在MySQL中，向TIME类型的字段插入数据时，也可以使用几种不同的格式。</p><ol><li>可以使用带有冒号的字符串，比如’<code>D HH:MM:SS</code>‘、’<code>HH:MM:SS</code>‘、’<code>HH:MM</code>‘、’<code>D HH:MM</code>‘、’<code>D HH</code>‘或’<code>SS</code>‘格式，都能被正确地插入TIME类型的字段中。其中D表示天，其最小值为0，最大值为34。如果使用带有D格式的字符串插入TIME类型的字段时，D会被转化为小时，计算格式为D* 24 +HH。当使用带有冒号并且不带D的字符串表示时间时，表示当天的时间，比如12 : 10表示12:10:00，而不是00 :12 : 10 。</li><li>可以使用不带有冒号的字符串或者数字，格式为’<code>HHMMSS</code>‘或者<code>HHMMSS</code>。如果插入一个不合法的字符串或者数字，MySQL在存储数据时，会将其自动转化为 00 : 00 : 00 进行存储。比如1210，MySQL会将最右边的两位解析成秒，表示00 : 12 : 10 ，而不是 12 : 10 : 00 。</li><li>使用<code>CURRENT_TIME()</code>或者<code>NOW()</code>，会插入当前系统的时间。</li></ol><p><strong>举例：</strong></p><p>创建数据表，表中包含一个TIME类型的字段f1 。</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_time1(f1 TIME);Query OK, 0 rows affected (0.02 sec)INSERT INTO test_timeVALUES(&#39;2 12:30:29&#39;), (&#39;12:35:29&#39;), (&#39;12:40&#39;), (&#39;2 12:40&#39;),(&#39;1 05&#39;), (&#39;45&#39;);INSERT INTO test_timeVALUES (&#39;123520&#39;), ( 124011 ),( 1210 );INSERT INTO test_timeVALUES (NOW()), (CURRENT_TIME());SELECT * FROM test_time1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-4-DATETIME类型"><a href="#6-4-DATETIME类型" class="headerlink" title="6. 4 DATETIME类型"></a>6. 4 DATETIME类型</h3><p>DATETIME类型在所有的日期时间类型中占用的存储空间最大，总共需要 <code>8</code> 个字节的存储空间。在格式上为DATE类型和TIME类型的组合，可以表示为<code>YYYY-MM-DD HH:MM:SS</code>，其中YYYY表示年份，MM表示月份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。</p><p>在向DATETIME类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li>以<code>YYYY-MM-DD HH:MM:SS</code>格式或者<code>YYYYMMDDHHMMSS</code>格式的字符串插入DATETIME类型的字段时，最小值为 1000 - 01 - 01 00 : 00 : 00 ，最大值为 9999 - 12 - 03 23 : 59 : 59 。<ul><li>以YYYYMMDDHHMMSS格式的数字插入DATETIME类型的字段时，会被转化为YYYY-MM-DD HH:MM:SS格式。</li></ul></li><li>以<code>YY-MM-DD HH:MM:SS</code>格式或者<code>YYMMDDHHMMSS</code>格式的字符串插入DATETIME类型的字段时，两位数的年份规则符合YEAR类型的规则， 00 到 69 表示 2000 到 2069 ； 70 到 99 表示 1970 到 1999 。</li><li>使用函数<code>CURRENT_TIMESTAMP()</code>和<code>NOW()</code>，可以向DATETIME类型的字段插入系统的当前日期和时间。</li></ul><p><strong>举例：</strong></p><p>创建数据表，表中包含一个DATETIME类型的字段dt。</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_datetime1(dt DATETIME);Query OK, 0 rows affected (0.02 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>插入数据：</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO test_datetimeVALUES (&#39;2021-01-01 06:50:30&#39;), (&#39;20210101065030&#39;);INSERT INTO test_datetimeVALUES (&#39;99-01-01 00:00:00&#39;), (&#39;990101000000&#39;), (&#39;20-01-01 00:00:00&#39;),(&#39;200101000000&#39;);INSERT INTO test_datetimeVALUES (20200101000000), (200101000000), ( 19990101000000 ), ( 990101000000);INSERT INTO test_datetimeVALUES (CURRENT_TIMESTAMP()), (NOW());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-5-TIMESTAMP类型"><a href="#6-5-TIMESTAMP类型" class="headerlink" title="6. 5 TIMESTAMP类型"></a>6. 5 TIMESTAMP类型</h3><p>TIMESTAMP类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是<code>YYYY-MM-DD HH:MM:SS</code>，需要 4 个字节的存储空间。但是TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储“ 1970 - 01 - 01 00 : 00 : 01 UTC”到“ 2038 - 01 - 19 03 : 14 : 07 UTC”之间的时间。其中，UTC表示世界统一时间，也叫作世界标准时间。</p><ul><li><strong>存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。</strong></li></ul><p>向TIMESTAMP类型的字段插入数据时，当插入的数据格式满足YY-MM-DD HH:MM:SS和YYMMDDHHMMSS时，两位数值的年份同样符合YEAR类型的规则条件，只不过表示的时间范围要小很多。</p><p>如果向TIMESTAMP类型的字段插入的时间超出了TIMESTAMP类型的范围，则MySQL会抛出错误信息。</p><p><strong>举例：</strong></p><p>创建数据表，表中包含一个TIMESTAMP类型的字段ts。</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_timestamp1(ts TIMESTAMP);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>插入数据：</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO test_timestampVALUES (&#39;1999-01-01 03:04:50&#39;), (&#39;19990101030405&#39;), (&#39;99-01-01 03:04:05&#39;),(&#39;990101030405&#39;);INSERT INTO test_timestampVALUES (&#39;2020@01@01@00@00@00&#39;), (&#39;20@01@01@00@00@00&#39;);INSERT INTO test_timestampVALUES (CURRENT_TIMESTAMP()), (NOW());#Incorrect datetime valueINSERT INTO test_timestampVALUES (&#39;2038-01-20 03:14:07&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>TIMESTAMP和DATETIME的区别：</strong></p><ul><li><p>TIMESTAMP存储空间比较小，表示的日期时间范围也比较小</p></li><li><p>底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离 1970 - 1 - 1 0 : 0 : 0 0 毫秒的毫秒值。</p></li><li><p>两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。</p></li><li><p>TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE temp_time(d1 DATETIME,d2 TIMESTAMP);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">INSERT INTO temp_time VALUES(&#39;2021-9-2 14:45:52&#39;,&#39;2021-9-2 14:45:52&#39;);INSERT INTO temp_time VALUES(NOW(),NOW());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM temp_time;+---------------------+---------------------+| d1 | d2 |+---------------------+---------------------+| 2021 - 09 - 02 14 :45:52 | 2021 - 09 - 02 14 :45:52 || 2021 - 11 - 03 17 :38:17 | 2021 - 11 - 03 17 :38:17 |+---------------------+---------------------+2 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#修改当前的时区SET time_zone &#x3D; &#39;+9:00&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM temp_time;+---------------------+---------------------+| d1 | d2 |+---------------------+---------------------+| 2021 - 09 - 02 14 :45:52 | 2021 - 09 - 02 15 :45:52 || 2021 - 11 - 03 17 :38:17 | 2021 - 11 - 03 18 :38:17 |+---------------------+---------------------+2 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="6-6-开发中经验"><a href="#6-6-开发中经验" class="headerlink" title="6. 6 开发中经验"></a>6. 6 开发中经验</h3><p>用得最多的日期时间类型，就是 <code>DATETIME</code>。虽然 MySQL 也支持 YEAR（年）、 TIME（时间）、DATE（日期），以及 TIMESTAMP 类型，但是在实际项目中，尽量用 DATETIME 类型。因为这个数据类型包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。毕竟，如果日期时间信息分散在好几个字段，很不容易记，而且查询的时候，SQL 语句也会更加复杂。</p><p>此外，一般存注册时间、商品发布时间等，不建议使用DATETIME存储，而是使用<code>时间戳</code>，因为<br>DATETIME虽然直观，但不便于计算。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT UNIX_TIMESTAMP();+------------------+| UNIX_TIMESTAMP() |+------------------+| 1635932762 |+------------------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="7-文本字符串类型"><a href="#7-文本字符串类型" class="headerlink" title="7. 文本字符串类型"></a>7. 文本字符串类型</h2><hr><p>在实际的项目中，我们还经常遇到一种数据，就是字符串数据。</p><p>MySQL中，文本字符串总体上分为<code>CHAR</code>、<code>VARCHAR</code>、<code>TINYTEXT</code>、<code>TEXT</code>、<code>MEDIUMTEXT</code>、<br><code>LONGTEXT</code>、<code>ENUM</code>、<code>SET</code>等类型。</p><p><img src="/../pic/%E7%AC%AC12%E7%AB%A0_MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/1650171877133.png" alt="1650171877133"></p><h3 id="7-1-CHAR与VARCHAR类型"><a href="#7-1-CHAR与VARCHAR类型" class="headerlink" title="7. 1 CHAR与VARCHAR类型"></a>7. 1 CHAR与VARCHAR类型</h3><p>CHAR和VARCHAR类型都可以存储比较短的字符串。</p><table><thead><tr><th>字符串(文本)类型</th><th>特点</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度</td><td>M</td><td>0 &lt;&#x3D; M &lt;&#x3D; 255</td><td>M个字节</td></tr><tr><td>VARCHAR(M)</td><td>可变长度</td><td>M</td><td>0 &lt;&#x3D; M &lt;&#x3D; 65535</td><td>(实际长度 + 1 ) 个字节</td></tr></tbody></table><p><strong>CHAR类型：</strong></p><ul><li>CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是 1 个字符。</li><li>如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在<code>右侧填充</code>空格以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。</li><li>定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数。</li></ul><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_char1(c1 CHAR,c2 CHAR( 5 ));DESC test_char1;INSERT INTO test_charVALUES(&#39;a&#39;,&#39;Tom&#39;);SELECT c1,CONCAT(c2,&#39;***&#39;) FROM test_char1;INSERT INTO test_char1(c2)VALUES(&#39;a &#39;);SELECT CHAR_LENGTH(c2)FROM test_char1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>VARCHAR类型：</strong></p><ul><li>VARCHAR(M) 定义时，必须指定长度M，否则报错。</li><li>MySQL4.0版本以下，varchar(20)：指的是 20 字节，如果存放UTF8汉字时，只能存 6 个（每个汉字 3 字节） ；MySQL5.0版本以上，varchar(20)：指的是 20 字符。</li><li>检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加 1 个字节。</li></ul><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_varchar1(NAME VARCHAR #错误);#Column length too big for column &#39;NAME&#39; (max &#x3D; 21845);CREATE TABLE test_varchar2(NAME VARCHAR( 65535 )  #错误);CREATE TABLE test_varchar3(NAME VARCHAR( 5 ));INSERT INTO test_varcharVALUES(&#39;尚硅谷&#39;),(&#39;尚硅谷教育&#39;);#Data too long for column &#39;NAME&#39; at row 1INSERT INTO test_varcharVALUES(&#39;尚硅谷IT教育&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>哪些情况使用 CHAR 或 VARCHAR 更好</strong></p><table><thead><tr><th>类型</th><th>特点</th><th>空间上</th><th>时间上</th><th>适用场景</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度</td><td>浪费存储空间</td><td>效率高</td><td>存储不大，速度要求高</td></tr><tr><td>VARCHAR(M)</td><td>可变长度</td><td>节省存储空间</td><td>效率低</td><td>非CHAR的情况</td></tr></tbody></table><p>情况 1 ：存储很短的信息。比如门牌号码 101 ，201……这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失。</p><p>情况 2 ：固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息。</p><p>情况 3 ：十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。</p><p>情况 4 ：具体存储引擎中的情况：</p><ul><li><code>MyISAM</code> 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使<code>数据检索更快</code>，用空间换时间。</li><li><code>MEMORY</code> 存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的。</li><li><code>InnoDB</code>存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且 <strong>主要影响性能的因素是数据行使用的存储总量</strong> ，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I&#x2F;O和数据存储总量比较好。</li></ul><h3 id="7-2-TEXT类型"><a href="#7-2-TEXT类型" class="headerlink" title="7. 2 TEXT类型"></a>7. 2 TEXT类型</h3><p>在MySQL中，TEXT用来保存文本类型的字符串，总共包含 4 种类型，分别为TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT 类型。</p><p>在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和VARCHAR类型相同。</p><p>每种TEXT类型保存的数据长度和所占用的存储空间不同，如下：</p><table><thead><tr><th>文本字符串类型</th><th>特点</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>TINYTEXT</td><td>小文本、可变长度</td><td>L</td><td>0 &lt;&#x3D; L &lt;&#x3D; 255</td><td>L + 2 个字节</td></tr><tr><td>TEXT</td><td>文本、可变长度</td><td>L</td><td>0 &lt;&#x3D; L &lt;&#x3D; 65535</td><td>L + 2 个字节</td></tr><tr><td>MEDIUMTEXT</td><td>中等文本、可变长度</td><td>L</td><td>0 &lt;&#x3D; L &lt;&#x3D; 16777215</td><td>L + 3 个字节</td></tr><tr><td>LONGTEXT</td><td>大文本、可变长度</td><td>L</td><td>0 &lt;&#x3D; L&lt;&#x3D; 4294967295（相当于4GB）</td><td>L + 4 个字节</td></tr></tbody></table><p><strong>由于实际存储的长度不确定，MySQL 不允许 TEXT 类型的字段做主键</strong> 。遇到这种情况，你只能采用CHAR(M)，或者 VARCHAR(M)。</p><p><strong>举例：</strong></p><p>创建数据表：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_text(tx TEXT);INSERT INTO test_textVALUES(&#39;atguigu &#39;);SELECT CHAR_LENGTH(tx)FROM test_text; #10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明在保存和查询数据时，并没有删除TEXT类型的数据尾部的空格。</p><p><strong>开发中经验：</strong></p><p>TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR，VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表。</p><hr><h2 id="8-ENUM类型"><a href="#8-ENUM类型" class="headerlink" title="8. ENUM类型"></a>8. ENUM类型</h2><hr><p>ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值。</p><p>其所需要的存储空间由定义ENUM类型时指定的成员个数决定。</p><table><thead><tr><th>文本字符串类型</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>ENUM</td><td>L</td><td>1 &lt;&#x3D; L &lt;&#x3D; 65535</td><td>1 或 2 个字节</td></tr></tbody></table><ul><li>当ENUM类型包含 1 ～ 255 个成员时，需要 1 个字节的存储空间；</li><li>当ENUM类型包含 256 ～ 65535 个成员时，需要 2 个字节的存储空间。</li><li>ENUM类型的成员个数的上限为 65535 个。</li></ul><p>举例：</p><p>创建表如下：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_enum(season ENUM(&#39;春&#39;,&#39;夏&#39;,&#39;秋&#39;,&#39;冬&#39;,&#39;unknow&#39;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>添加数据：</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO test_enumVALUES(&#39;春&#39;),(&#39;秋&#39;);# 忽略大小写INSERT INTO test_enumVALUES(&#39;UNKNOW&#39;);# 允许按照角标的方式获取指定索引位置的枚举值INSERT INTO test_enumVALUES(&#39;1&#39;),( 3 );# Data truncated for column &#39;season&#39; at row 1INSERT INTO test_enumVALUES(&#39;ab&#39;);# 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的INSERT INTO test_enumVALUES(NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="9-SET类型"><a href="#9-SET类型" class="headerlink" title="9. SET类型"></a>9. SET类型</h2><hr><p>SET表示一个字符串对象，可以包含 0 个或多个成员，但成员个数的上限为 64 。设置字段值时，可以取取值范围内的 0 个或多个值。</p><p>当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：</p><table><thead><tr><th>成员个数范围（L表示实际成员个数）</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>1 &lt;&#x3D; L &lt;&#x3D; 8</td><td>1 个字节</td></tr><tr><td>9 &lt;&#x3D; L &lt;&#x3D; 16</td><td>2 个字节</td></tr><tr><td>17 &lt;&#x3D; L &lt;&#x3D; 24</td><td>3 个字节</td></tr><tr><td>25 &lt;&#x3D; L &lt;&#x3D; 32</td><td>4 个字节</td></tr><tr><td>33 &lt;&#x3D; L &lt;&#x3D; 64</td><td>8 个字节</td></tr></tbody></table><p>SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同。</p><p>举例：</p><p>创建表：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_set(s SET (&#39;A&#39;, &#39;B&#39;, &#39;C&#39;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>向表中插入数据：</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO test_set (s) VALUES (&#39;A&#39;), (&#39;A,B&#39;);#插入重复的SET类型成员时，MySQL会自动删除重复的成员INSERT INTO test_set (s) VALUES (&#39;A,B,C,A&#39;);#向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误。INSERT INTO test_set (s) VALUES (&#39;A,B,C,D&#39;);SELECT *FROM test_set;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE temp_mul(gender ENUM(&#39;男&#39;,&#39;女&#39;),hobby SET(&#39;吃饭&#39;,&#39;睡觉&#39;,&#39;打豆豆&#39;,&#39;写代码&#39;));INSERT INTO temp_mul VALUES(&#39;男&#39;,&#39;睡觉,打豆豆&#39;); #成功# Data truncated for column &#39;gender&#39; at row 1INSERT INTO temp_mul VALUES(&#39;男,女&#39;,&#39;睡觉,写代码&#39;); #失败# Data truncated for column &#39;gender&#39; at row 1INSERT INTO temp_mul VALUES(&#39;妖&#39;,&#39;睡觉,写代码&#39;);#失败INSERT INTO temp_mul VALUES(&#39;男&#39;,&#39;睡觉,写代码,吃饭&#39;); #成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="10-二进制字符串类型"><a href="#10-二进制字符串类型" class="headerlink" title="10. 二进制字符串类型"></a>10. 二进制字符串类型</h2><hr><p>MySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。</p><p>MySQL中支持的二进制字符串类型主要包括BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和LONGBLOB类型。</p><p><strong>BINARY与VARBINARY类型</strong></p><p>BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串。</p><p>BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是 0 ~ 255 个字符。如果未指定(M)，表示只能存储 <code>1 个字节</code>。例如BINARY ( 8 )，表示最多能存储 8 个字节，如果字段值不足(M)个字节，将在右边填充’\ 0 ‘以补齐指定长度。</p><p>VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制 65535 ，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要 1 或 2 个字节来存储数据的字节数。VARBINARY类型<code>必须指定(M)</code>，否则报错。</p><table><thead><tr><th>二进制字符串类型</th><th>特点</th><th>值的长度</th><th>占用空间</th></tr></thead><tbody><tr><td>BINARY(M)</td><td>固定长度</td><td>M（ 0 &lt;&#x3D; M &lt;&#x3D; 255 ）</td><td>M个字节</td></tr><tr><td>VARBINARY(M)</td><td>可变长度</td><td>M（ 0 &lt;&#x3D; M &lt;&#x3D; 65535 ）</td><td>M+ 1 个字节</td></tr></tbody></table><p>举例：</p><p>创建表：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_binary1(f1 BINARY,f2 BINARY( 3 ),# f3 VARBINARY,f4 VARBINARY( 10 ));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加数据：</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO test_binary1(f1,f2)VALUES(&#39;a&#39;,&#39;a&#39;);INSERT INTO test_binary1(f1,f2)VALUES(&#39;尚&#39;,&#39;尚&#39;);#失败INSERT INTO test_binary1(f2,f4)VALUES(&#39;ab&#39;,&#39;ab&#39;);mysql&gt; SELECT LENGTH(f2),LENGTH(f4)-&gt; FROM test_binary1;+------------+------------+| LENGTH(f2) | LENGTH(f4) |+------------+------------+| 3 | NULL || 3 | 2 |+------------+------------+2 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>BLOB类型</strong></p><p>BLOB是一个<code>二进制大对象</code>，可以容纳可变数量的数据。</p><p>MySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB 4种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如<code>图片</code>、<code>音频</code>和<code>视频</code>等。</p><p>需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图片、音频和视频文件存储到<code>服务器的磁盘上</code>，并将图片、音频和视频的访问路径存储到MySQL中。</p><table><thead><tr><th>二进制字符串类型</th><th>值的长度</th><th>长度范围</th><th>占用空间</th></tr></thead><tbody><tr><td>TINYBLOB</td><td>L</td><td>0 &lt;&#x3D; L &lt;&#x3D; 255</td><td>L + 1 个字节</td></tr><tr><td>BLOB</td><td>L</td><td>0 &lt;&#x3D; L &lt;&#x3D; 65535（相当于64KB）</td><td>L + 2 个字节</td></tr><tr><td>MEDIUMBLOB</td><td>L</td><td>0 &lt;&#x3D; L &lt;&#x3D; 16777215 （相当于16MB）</td><td>L + 3 个字节</td></tr><tr><td>LONGBLOB</td><td>L</td><td>0 &lt;&#x3D; L &lt;&#x3D; 4294967295（相当于4GB）</td><td>L + 4 个字节</td></tr></tbody></table><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_blob1(id INT,img MEDIUMBLOB);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>TEXT和BLOB的使用注意事项：</strong></p><p>在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。</p><p>① BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的”<code>空洞</code>“，以后填入这些”空洞”的记录可能长度不同。为了提高性能，建议定期使用 OPTIMIZE TABLE 功能对这类表进行<code>碎片整理</code>。</p><p>② 如果需要对大文本字段进行模糊查询，MySQL 提供了<code>前缀索引</code>。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。</p><p>③ 把BLOB或TEXT列<code>分离到单独的表</code>中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会<code>减少主表中的碎片</code>，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过网络传输大量的BLOB或TEXT值。</p><hr><h2 id="11-JSON-类型"><a href="#11-JSON-类型" class="headerlink" title="11. JSON 类型"></a>11. JSON 类型</h2><hr><p>JSON（JavaScript Object Notation）是一种轻量级的<code>数据交换格式</code>。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 <strong>JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。</strong></p><p>在MySQL 5.7中，就已经支持JSON数据类型。在MySQL 8.x版本中，JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使得在MySQL中存储和读取JSON类型的数据更加方便和高效。 创建数据表，表中包含一个JSON类型的字段 js 。</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE test_json(js json);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>向表中插入JSON数据。</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO test_json (js)VALUES (&#39;&#123;&quot;name&quot;:&quot;songhk&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;province&quot;:&quot;beijing&quot;,&quot;city&quot;:&quot;beijing&quot;&#125;&#125;&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查询t19表中的数据。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT *-&gt; FROM test_json;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/../pic/%E7%AC%AC12%E7%AB%A0_MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/1650173453029.png" alt="1650173453029"></p><p>当需要检索JSON类型的字段中数据的某个具体值时，可以使用“-&gt;”和“-&gt;&gt;”符号。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT js -&gt; &#39;$.name&#39; AS NAME,js -&gt; &#39;$.age&#39; AS age ,js -&gt; &#39;$.address.province&#39; AS province, js -&gt; &#39;$.address.city&#39; AS city-&gt; FROM test_json;+----------+------+-----------+-----------+| NAME | age | province | city |+----------+------+-----------+-----------+| &quot;songhk&quot; | 18 | &quot;beijing&quot; | &quot;beijing&quot; |+----------+------+-----------+-----------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过“-&gt;”和“-&gt;&gt;”符号，从JSON字段中正确查询出了指定的JSON数据的值。</p><hr><h2 id="12-空间类型"><a href="#12-空间类型" class="headerlink" title="12. 空间类型"></a>12. 空间类型</h2><hr><p>MySQL 空间类型扩展支持地理特征的生成、存储和分析。这里的地理特征表示世界上具有位置的任何东西，可以是一个实体，例如一座山；可以是空间，例如一座办公楼；也可以是一个可定义的位置，例如一个十字路口等等。MySQL中使用<code>Geometry（几何）</code>来表示所有地理特征。Geometry指一个点或点的集合，代表世界上任何具有位置的事物。</p><p>MySQL的空间数据类型（Spatial Data Type）对应于OpenGIS类，包括单值类型：GEOMETRY、POINT、LINESTRING、POLYGON以及集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION 。</p><ul><li>Geometry是所有空间集合类型的基类，其他类型如POINT、LINESTRING、POLYGON都是Geometry的子类。<ul><li>Point，顾名思义就是点，有一个坐标值。例如POINT(121.213342 31.234532)，POINT(30 10)，坐标值支持DECIMAL类型，经度（longitude）在前，维度（latitude）在后，用空格分隔。</li><li>LineString，线，由一系列点连接而成。如果线从头至尾没有交叉，那就是简单的（simple）；如果起点和终点重叠，那就是封闭的（closed）。例如LINESTRING(30 10,10 30,40 40)，点与点之间用逗号分隔，一个点中的经纬度用空格分隔，与POINT格式一致。</li><li>Polygon，多边形。可以是一个实心平面形，即没有内部边界，也可以有空洞，类似纽扣。最简单的就是只有一个外边界的情况，例如POLYGON((0 0,10 0,10 10, 0 10))。</li></ul></li></ul><p>下面展示几种常见的几何图形元素：</p><p><img src="/../pic/%E7%AC%AC12%E7%AB%A0_MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/1650173649831.png" alt="1650173649831"></p><ul><li>MultiPoint、MultiLineString、MultiPolygon、GeometryCollection 这 4 种类型都是集合类，是多个Point、LineString或Polygon组合而成。</li></ul><p>下面展示的是多个同类或异类几何图形元素的组合：</p><p><img src="/../pic/%E7%AC%AC12%E7%AB%A0_MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/1650173684352.png" alt="1650173684352"></p><hr><h2 id="13-小结及选择建议"><a href="#13-小结及选择建议" class="headerlink" title="13. 小结及选择建议"></a>13. 小结及选择建议</h2><hr><p>在定义数据类型时，如果确定是<code>整数</code>，就用<code>INT</code>； 如果是<code>小数</code>，一定用定点数类型<code>DECIMAL(M,D)</code>； 如果是日期与时间，就用 <code>DATETIME</code>。</p><p>这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两面的，可靠性好，并不意味着高效。比如，TEXT 虽然使用方便，但是效率不如 CHAR(M) 和 VARCHAR(M)。</p><p>关于字符串的选择，建议参考如下阿里巴巴的《Java开发手册》规范：</p><p><strong>阿里巴巴《Java开发手册》之MySQL数据库：</strong></p><ul><li><p>任何字段如果为非负数，必须是 UNSIGNED</p></li><li><p>【<code>强制</code>】小数类型为 DECIMAL，禁止使用 FLOAT 和 DOUBLE。</p><ul><li>说明：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并分开存储。</li></ul></li><li><p>【<code>强制</code>】如果存储的字符串长度几乎相等，使用 CHAR 定长字符串类型。</p></li><li><p>【<code>强制</code>】VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 5000 。如果存储长度大于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视图</title>
      <link href="/2022/07/17/di-14-zhang-shi-tu/"/>
      <url>/2022/07/17/di-14-zhang-shi-tu/</url>
      
        <content type="html"><![CDATA[<h1 id="第14章-视图"><a href="#第14章-视图" class="headerlink" title="第14章_视图"></a>第14章_视图</h1><h2 id="1-常见的数据库对象"><a href="#1-常见的数据库对象" class="headerlink" title="1. 常见的数据库对象"></a>1. 常见的数据库对象</h2><hr><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>表(TABLE)</td><td>表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录</td></tr><tr><td>数据字典</td><td>就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看</td></tr><tr><td>约束(CONSTRAINT)</td><td>执行数据校验的规则，用于保证数据完整性的规则</td></tr><tr><td>视图(VIEW)</td><td>一个或者多个数据表里的数据的逻辑显示，视图并不存储数据</td></tr><tr><td>索引(INDEX)</td><td>用于提高查询性能，相当于书的目录</td></tr><tr><td>存储过程(PROCEDURE)</td><td>用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境</td></tr><tr><td>存储函数(FUNCTION)</td><td>用于完成一次特定的计算，具有一个返回值</td></tr><tr><td>触发器(TRIGGER)</td><td>相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理</td></tr></tbody></table><hr><h2 id="2-视图概述"><a href="#2-视图概述" class="headerlink" title="2. 视图概述"></a>2. 视图概述</h2><hr><p><img src="https://new-wangz.github.io/2022/04/20/%E7%AC%AC14%E7%AB%A0-%E8%A7%86%E5%9B%BE/1650462824019.png" alt="1650462824019"></p><h3 id="2-1-为什么使用视图？"><a href="#2-1-为什么使用视图？" class="headerlink" title="2. 1 为什么使用视图？"></a>2. 1 为什么使用视图？</h3><p>视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的价格，则不会提供给他。再比如，人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中则不提供这个字段。</p><p>刚才讲的只是视图的一个使用场景，实际上视图还有很多作用。最后，我们总结视图的优点。</p><h3 id="2-2-视图的理解"><a href="#2-2-视图的理解" class="headerlink" title="2. 2 视图的理解"></a>2. 2 视图的理解</h3><ul><li><p>视图是一种<code>虚拟表</code>，本身是<code>不具有数据</code>的，占用很少的内存空间，它是 SQL 中的一个重要概念。</p></li><li><p><strong>视图建立在已有表的基础上</strong> , 视图赖以建立的这些表称为 <strong>基表</strong> 。<br><img src="https://new-wangz.github.io/2022/04/20/%E7%AC%AC14%E7%AB%A0-%E8%A7%86%E5%9B%BE/1650462971974.png" alt="1650462971974"></p></li><li><p>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</p></li><li><p>向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为</p><p>存储起来的 SELECT 语句</p><ul><li>在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化；反之亦然。</li></ul></li><li><p>视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</p></li></ul><hr><h2 id="3-创建视图"><a href="#3-创建视图" class="headerlink" title="3. 创建视图"></a>3. 创建视图</h2><hr><ul><li><p><strong>在 CREATE VIEW 语句中嵌入子查询</strong></p><pre class="line-numbers language-none"><code class="language-none">CREATE [OR REPLACE][ALGORITHM &#x3D; &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]VIEW 视图名称 [(字段列表)]AS 查询语句[WITH [CASCADED|LOCAL] CHECK OPTION]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>精简版</p><pre class="line-numbers language-none"><code class="language-none">CREATE VIEW 视图名称AS 查询语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="3-1-创建单表视图"><a href="#3-1-创建单表视图" class="headerlink" title="3. 1 创建单表视图"></a>3. 1 创建单表视图</h3><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">CREATE VIEW empvuASSELECT employee_id, last_name, salaryFROM employeesWHERE department_id &#x3D; 80 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查询视图：</p><pre class="line-numbers language-none"><code class="language-none">SELECT *FROM salvu80;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://new-wangz.github.io/2022/04/20/%E7%AC%AC14%E7%AB%A0-%E8%A7%86%E5%9B%BE/1650463064557.png" alt="1650463064557"></p><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">CREATE VIEW emp_year_salary (ename,year_salary)ASSELECT ename,salary* 12 *( 1 +IFNULL(commission_pct, 0 ))FROM t_employee;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">CREATE VIEW salvuASSELECT employee_id ID_NUMBER, last_name NAME,salary* 12 ANN_SALARYFROM employeesWHERE department_id &#x3D; 50 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明 1 ：实际上就是我们在 SQL 查询语句的基础上封装了视图 VIEW，这样就会基于 SQL 语句的结果集形成一张虚拟表。</p><p>说明 2 ：在创建视图时，没有在视图名后面指定字段列表，则视图中字段列表默认和SELECT语句中的字段列表一致。如果SELECT语句中给字段取了别名，那么视图中的字段名和别名相同。</p><h3 id="3-2-创建多表联合视图"><a href="#3-2-创建多表联合视图" class="headerlink" title="3. 2 创建多表联合视图"></a>3. 2 创建多表联合视图</h3><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">CREATE VIEW empviewASSELECT employee_id emp_id,last_name NAME,department_nameFROM employees e,departments dWHERE e.department_id &#x3D; d.department_id;CREATE VIEW emp_deptASSELECT ename,dnameFROM t_employee LEFT JOIN t_departmentON t_employee.did &#x3D; t_department.did;CREATE VIEW dept_sum_vu(name, minsal, maxsal, avgsal)ASSELECT d.department_name, MIN(e.salary), MAX(e.salary),AVG(e.salary)FROM employees e, departments dWHERE e.department_id &#x3D; d.department_idGROUP BY d.department_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>利用视图对数据进行格式化</strong><br>我们经常需要输出某个格式的内容，比如我们想输出员工姓名和对应的部门名，对应格式为emp_name(department_name)，就可以使用视图来完成数据格式化的操作：</p><pre class="line-numbers language-none"><code class="language-none">CREATE VIEW emp_departASSELECT CONCAT(last_name,&#39;(&#39;,department_name,&#39;)&#39;) AS emp_deptFROM employees e JOIN departments dWHERE e.department_id &#x3D; d.department_id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="3-3-基于视图创建视图"><a href="#3-3-基于视图创建视图" class="headerlink" title="3. 3 基于视图创建视图"></a>3. 3 基于视图创建视图</h3><p>当我们创建好一张视图之后，还可以在它的基础上继续创建视图。</p><p>举例：联合“emp_dept”视图和“emp_year_salary”视图查询员工姓名、部门名称、年薪信息创建“emp_dept_ysalary”视图。</p><pre class="line-numbers language-none"><code class="language-none">CREATE VIEW emp_dept_ysalaryASSELECT emp_dept.ename,dname,year_salaryFROM emp_dept INNER JOIN emp_year_salaryON emp_dept.ename &#x3D; emp_year_salary.ename;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="4-查看视图"><a href="#4-查看视图" class="headerlink" title="4. 查看视图"></a>4. 查看视图</h2><hr><p>语法 1 ：查看数据库的表对象、视图对象</p><pre class="line-numbers language-none"><code class="language-none">SHOW TABLES;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>语法 2 ：查看视图的结构</p><pre class="line-numbers language-none"><code class="language-none">DESC &#x2F; DESCRIBE 视图名称;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>语法 3 ：查看视图的属性信息</p><pre class="line-numbers language-none"><code class="language-none"># 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）SHOW TABLE STATUS LIKE &#39;视图名称&#39;\G<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。</p><p>语法 4 ：查看视图的详细定义信息</p><pre class="line-numbers language-none"><code class="language-none">SHOW CREATE VIEW 视图名称;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="5-更新视图的数据"><a href="#5-更新视图的数据" class="headerlink" title="5. 更新视图的数据"></a>5. 更新视图的数据</h2><hr><h3 id="5-1-一般情况"><a href="#5-1-一般情况" class="headerlink" title="5. 1 一般情况"></a>5. 1 一般情况</h3><p>MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。</p><p>举例：UPDATE操作</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename &#x3D; &#39;孙洪亮&#39;;+---------+-------------+| ename | tel |+---------+-------------+| 孙洪亮 | 13789098765 |+---------+-------------+1 row in set (0.01 sec)mysql&gt; UPDATE emp_tel SET tel &#x3D; &#39;13789091234&#39; WHERE ename &#x3D; &#39;孙洪亮&#39;;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename &#x3D; &#39;孙洪亮&#39;;+---------+-------------+| ename | tel |+---------+-------------+| 孙洪亮 | 13789091234 |+---------+-------------+1 row in set (0.00 sec)mysql&gt; SELECT ename,tel FROM t_employee WHERE ename &#x3D; &#39;孙洪亮&#39;;+---------+-------------+| ename | tel |+---------+-------------+| 孙洪亮 | 13789091234 |+---------+-------------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：DELETE操作</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename &#x3D; &#39;孙洪亮&#39;;+---------+-------------+| ename | tel |+---------+-------------+| 孙洪亮 | 13789091234 |+---------+-------------+1 row in set (0.00 sec)mysql&gt; DELETE FROM emp_tel  WHERE ename &#x3D; &#39;孙洪亮&#39;;Query OK, 1 row affected (0.01 sec)mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename &#x3D; &#39;孙洪亮&#39;;Empty set (0.00 sec)mysql&gt; SELECT ename,tel FROM t_employee WHERE ename &#x3D; &#39;孙洪亮&#39;;Empty set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-不可更新的视图"><a href="#5-2-不可更新的视图" class="headerlink" title="5. 2 不可更新的视图"></a>5. 2 不可更新的视图</h3><p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在<code>一对一</code>的关系。另外当视图定义出现如下情况时，视图不支持更新操作：</p><ul><li>在定义视图的时候指定了“ALGORITHM &#x3D; TEMPTABLE”，视图将不支持INSERT和DELETE操作；</li><li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；</li><li>在定义视图的SELECT语句中使用了<code>JOIN联合查询</code>，视图将不支持INSERT和DELETE操作；</li><li>在定义视图的SELECT语句后的字段列表中使用了<code>数学表达式</code>或<code>子查询</code>，视图将不支持INSERT，也不支持UPDATE使用了数学表达式、子查询的字段值；</li><li>在定义视图的SELECT语句后的字段列表中使用<code>DISTINCT</code>、<code>聚合函数</code>、<code>GROUP BY</code>、<code>HAVING</code>、<code>UNION</code>等，视图将不支持INSERT、UPDATE、DELETE；</li><li>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE；</li><li>视图定义基于一个<code>不可更新视图</code>；</li><li>常量视图。</li></ul><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; CREATE OR REPLACE VIEW emp_dept-&gt; (ename,salary,birthday,tel,email,hiredate,dname)-&gt; AS SELECT ename,salary,birthday,tel,email,hiredate,dname-&gt; FROM t_employee INNER JOIN t_department-&gt; ON t_employee.did &#x3D; t_department.did ;Query OK, 0 rows affected (0.01 sec)mysql&gt; INSERT INTO emp_dept(ename,salary,birthday,tel,email,hiredate,dname)-&gt; VALUES(&#39;张三&#39;, 15000 ,&#39;1995-01-08&#39;,&#39;18201587896&#39;,-&gt; &#39;zs@atguigu.com&#39;,&#39;2022-02-14&#39;,&#39;新部门&#39;);#ERROR 1393 (HY000): Can not modify more than one base table through a join view &#39;atguigu_chapter9.emp_dept&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的SQL执行结果可以看出，在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持更新操作。</p><blockquote><p>虽然可以更新视图数据，但总的来说，视图作为<code>虚拟表</code>，主要用于<code>方便查询</code>，不建议更新视图的数据。 <strong>对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。</strong></p></blockquote><hr><h2 id="6-修改、删除视图"><a href="#6-修改、删除视图" class="headerlink" title="6. 修改、删除视图"></a>6. 修改、删除视图</h2><hr><h3 id="6-1-修改视图"><a href="#6-1-修改视图" class="headerlink" title="6. 1 修改视图"></a>6. 1 修改视图</h3><p>方式 1 ：使用CREATE OR REPLACE VIEW 子句 <strong>修改视图</strong></p><pre class="line-numbers language-none"><code class="language-none">CREATE OR REPLACE VIEW empvu(id_number, name, sal, department_id)ASSELECT employee_id, first_name || &#39; &#39; || last_name, salary, department_idFROM employeesWHERE department_id &#x3D; 80 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>说明：CREATE VIEW 子句中各列的别名应和子查询中各列相对应。</p></blockquote><p>方式 2 ：ALTER VIEW</p><p>修改视图的语法是：</p><pre class="line-numbers language-none"><code class="language-none">ALTER VIEW 视图名称AS查询语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="6-2-删除视图"><a href="#6-2-删除视图" class="headerlink" title="6. 2 删除视图"></a>6. 2 删除视图</h3><ul><li><p>删除视图只是删除视图的定义，并不会删除基表的数据。</p></li><li><p>删除视图的语法是：</p><pre class="line-numbers language-none"><code class="language-none">DROP VIEW IF EXISTS 视图名称;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">DROP VIEW IF EXISTS 视图名称1,视图名称2,视图名称3,...;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">DROP VIEW empvu80;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>说明：基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这样的视图c需要手动删除或修改，否则影响使用。</p></li></ul><hr><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><hr><h3 id="7-1-视图优点"><a href="#7-1-视图优点" class="headerlink" title="7. 1 视图优点"></a>7. 1 视图优点</h3><p><strong>1. 操作简单</strong></p><p>将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简化了开发人员对数据库的操作。</p><p><strong>2. 减少数据冗余</strong></p><p>视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。</p><p><strong>3. 数据安全</strong></p><p>MySQL将用户对数据的<code>访问限制</code>在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有<code>隔离性</code>。视图相当于在用户和实际的数据表之间加了一层虚拟表。<br><img src="https://new-wangz.github.io/2022/04/20/%E7%AC%AC14%E7%AB%A0-%E8%A7%86%E5%9B%BE/1650463730838.png" alt="1650463730838"></p><p>同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上， <strong>用户不需要查询数据表，可以直接通过视图获取数据表中的信息</strong> 。这在一定程度上保障了数据表中数据的安全性。</p><p><strong>4. 适应灵活多变的需求</strong> 当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。</p><p><strong>5. 能够分解复杂的查询逻辑</strong> 数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。</p><h3 id="7-2-视图不足"><a href="#7-2-视图不足" class="headerlink" title="7. 2 视图不足"></a>7. 2 视图不足</h3><p>如果我们在实际数据表的基础上创建了视图，那么， <strong>如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护</strong> 。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂，<code>可读性不好</code>，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。</p><p>实际项目中，如果视图过多，会导致数据库维护成本的问题。</p><p>所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储过程与函数</title>
      <link href="/2022/07/17/di-15-zhang-cun-chu-guo-cheng-yu-han-shu/"/>
      <url>/2022/07/17/di-15-zhang-cun-chu-guo-cheng-yu-han-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="第15章-存储过程与函数"><a href="#第15章-存储过程与函数" class="headerlink" title="第15章_存储过程与函数"></a>第15章_存储过程与函数</h1><p>MySQL从 5. 0 版本开始支持存储过程和函数。存储过程和函数能够将复杂的SQL逻辑封装在一起，应用程序无须关注存储过程和函数内部复杂的SQL逻辑，而只需要简单地调用存储过程和函数即可。</p><hr><h2 id="1-存储过程概述"><a href="#1-存储过程概述" class="headerlink" title="1. 存储过程概述"></a>1. 存储过程概述</h2><hr><h3 id="1-1-理解"><a href="#1-1-理解" class="headerlink" title="1. 1 理解"></a>1. 1 理解</h3><p><strong>含义</strong> ：存储过程的英文是 <code>Stored Procedure</code>。它的思想很简单，就是一组经过<code>预先编译</code>的 SQL 语句的封装。</p><p>执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p><p><strong>好处</strong> ：</p><ol><li>简化操作，提高了sql语句的重用性，减少了开发程序员的压力</li><li>减少操作过程中的失误，提高效率</li><li>减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器）</li><li>减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性</li></ol><p><strong>和视图、函数的对比</strong> ：</p><p>它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是<code>虚拟表</code>，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以<code>直接操作底层数据表</code>，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。</p><p>一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是<code>没有返回值</code>的。</p><h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1. 2 分类"></a>1. 2 分类</h3><p>存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下：</p><ol><li>没有参数（无参数无返回）</li><li>仅仅带 IN 类型（有参数无返回）</li><li>仅仅带 OUT 类型（无参数有返回）</li><li>既带 IN 又带 OUT（有参数有返回）</li><li>带 INOUT（有参数有返回）</li></ol><p>注意：IN、OUT、INOUT 都可以在一个存储过程中带多个。</p><hr><h2 id="2-创建存储过程"><a href="#2-创建存储过程" class="headerlink" title="2. 创建存储过程"></a>2. 创建存储过程</h2><hr><h3 id="2-1-语法分析"><a href="#2-1-语法分析" class="headerlink" title="2. 1 语法分析"></a>2. 1 语法分析</h3><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)[characteristics ...]BEGIN存储过程体END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似于Java中的方法：</p><pre class="line-numbers language-none"><code class="language-none">修饰符 返回类型 方法名(参数类型 参数名,...)&#123;方法体;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>说明：</p><ol><li><p>参数前面的符号的意思</p><ul><li><code>IN</code>：当前参数为输入参数，也就是表示入参；<br>存储过程只是读取这个参数的值。如果没有定义参数种类，<code>默认就是 IN</code>，表示输入参数。</li><li><code>OUT</code>：当前参数为输出参数，也就是表示出参；<br>执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。</li><li><code>INOUT</code>：当前参数既可以为输入参数，也可以为输出参数。</li></ul></li><li><p>形参类型可以是 MySQL数据库中的任意类型。</p></li><li><p><code>characteristics</code> 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：</p><pre class="line-numbers language-none"><code class="language-none">LANGUAGE SQL| [NOT] DETERMINISTIC| &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;| SQL SECURITY &#123; DEFINER | INVOKER &#125;| COMMENT &#39;string&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>LANGUAGE SQL</code>：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。</p></li><li><p><code>[NOT] DETERMINISTIC</code>：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。</p></li><li><pre><code>&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;<pre class="line-numbers language-none"><code class="language-none">  ：指明子程序使用SQL语句的限制。  - CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句；  - NO SQL表示当前存储过程的子程序中不包含任何SQL语句；  - READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句；  - MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。  - 默认情况下，系统会指定为CONTAINS SQL。- &#96;&#96;&#96;  SQL SECURITY &#123; DEFINER | INVOKER &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。- `DEFINER`表示只有当前存储过程的创建者或者定义者才能执行当前存储过程；- `INVOKER`表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。- 如果没有设置相关的值，则MySQL默认指定值为DEFINER。</code></pre></li><li><p><code>COMMENT &#39;string&#39;</code>：注释信息，可以用来描述存储过程。</p></li></ul></li><li><p>存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END<br>编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的 SQL 语句。</p><pre class="line-numbers language-none"><code class="language-none">1. BEGIN...END：BEGIN...END 中间包含了多个语句，每个语句都以（;）号为结束符。2. DECLARE：DECLARE 用来声明变量，使用的位置在于 BEGIN...END 语句中间，而且需要在其他语句使用之前进行变量的声明。3. SET：赋值语句，用于对变量进行赋值。4. SELECT... INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>需要设置新的结束标记</p><pre class="line-numbers language-none"><code class="language-none">DELIMITER 新的结束标记<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为MySQL默认的语句结束符号为分号‘;’。为了避免与存储过程中SQL语句结束符相冲突，需要使用DELIMITER改变存储过程的结束符。</p><p>比如：“DELIMITER &#x2F;&#x2F;”语句的作用是将MySQL的结束符设置为&#x2F;&#x2F;，并以“END &#x2F;&#x2F;”结束存储过程。存储过程定义完毕之后再使用“DELIMITER ;”恢复默认结束符。DELIMITER也可以指定其他符号作为结束符。</p><p>当使用DELIMITER命令时，应该避免使用反斜杠（‘\’）字符，因为反斜线是MySQL的转义字符。</p><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">DELIMITER $CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)[characteristics ...]BEGINsql语句1;sql语句2;END $<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="2-2-代码举例"><a href="#2-2-代码举例" class="headerlink" title="2. 2 代码举例"></a>2. 2 代码举例</h3><p>举例 1 ：创建存储过程select_all_data()，查看 emps 表的所有数据</p><pre class="line-numbers language-none"><code class="language-none">DELIMITER $CREATE PROCEDURE select_all_data()BEGINSELECT * FROM emps;END $DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例 2 ：创建存储过程avg_employee_salary()，返回所有员工的平均工资</p><pre class="line-numbers language-none"><code class="language-none">DELIMITER &#x2F;&#x2F;CREATE PROCEDURE avg_employee_salary ()BEGINSELECT AVG(salary) AS avg_salary FROM emps;END &#x2F;&#x2F;DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例 3 ：创建存储过程show_max_salary()，用来查看“emps”表的最高薪资值。</p><pre class="line-numbers language-none"><code class="language-none">CREATE PROCEDURE show_max_salary()LANGUAGE SQLNOT DETERMINISTICCONTAINS SQLSQL SECURITY DEFINERCOMMENT &#39;查看最高薪资&#39;BEGINSELECT MAX(salary) FROM emps;END &#x2F;&#x2F;DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例 4 ：创建存储过程show_min_salary()，查看“emps”表的最低薪资值。并将最低薪资通过OUT参数“ms”输出</p><pre class="line-numbers language-none"><code class="language-none">DELIMITER &#x2F;&#x2F;CREATE PROCEDURE show_min_salary(OUT ms DOUBLE)BEGINSELECT MIN(salary) INTO ms FROM emps;END &#x2F;&#x2F;DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例 5 ：创建存储过程show_someone_salary()，查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名。</p><pre class="line-numbers language-none"><code class="language-none">DELIMITER &#x2F;&#x2F;CREATE PROCEDURE show_someone_salary(IN empname VARCHAR( 20 ))BEGINSELECT salary FROM emps WHERE ename &#x3D; empname;END &#x2F;&#x2F;DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例 6 ：创建存储过程show_someone_salary2()，查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名，用OUT参数empsalary输出员工薪资。</p><pre class="line-numbers language-none"><code class="language-none">DELIMITER &#x2F;&#x2F;CREATE PROCEDURE show_someone_salary2(IN empname VARCHAR( 20 ),OUT empsalary DOUBLE)BEGINSELECT salary INTO empsalary FROM emps WHERE ename &#x3D; empname;END &#x2F;&#x2F;DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例 7 ：创建存储过程show_mgr_name()，查询某个员工领导的姓名，并用INOUT参数“empname”输入员工姓名，输出领导的姓名。</p><pre class="line-numbers language-none"><code class="language-none">DELIMITER &#x2F;&#x2F;CREATE PROCEDURE show_mgr_name(INOUT empname VARCHAR( 20 ))BEGINSELECT ename INTO empname FROM empsWHERE eid &#x3D; (SELECT MID FROM emps WHERE ename&#x3D;empname);END &#x2F;&#x2F;DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="3-调用存储过程"><a href="#3-调用存储过程" class="headerlink" title="3. 调用存储过程"></a>3. 调用存储过程</h2><hr><h3 id="3-1-调用格式"><a href="#3-1-调用格式" class="headerlink" title="3. 1 调用格式"></a>3. 1 调用格式</h3><p>存储过程有多种调用方法。存储过程必须使用CALL语句调用，并且存储过程和数据库相关，如果要执行其他数据库中的存储过程，需要指定数据库名称，例如CALL dbname.procname。</p><pre class="line-numbers language-none"><code class="language-none">CALL 存储过程名(实参列表)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>格式：</strong></p><ol><li><p>调用in模式的参数：</p><pre class="line-numbers language-none"><code class="language-none">CALL sp1(&#39;值&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>调用out模式的参数：</p><pre class="line-numbers language-none"><code class="language-none">SET @name;CALL sp1(@name);SELECT @name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>调用inout模式的参数：</p><pre class="line-numbers language-none"><code class="language-none">SET @name&#x3D;值;CALL sp1(@name);SELECT @name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="3-2-代码举例"><a href="#3-2-代码举例" class="headerlink" title="3. 2 代码举例"></a>3. 2 代码举例</h3><p><strong>举例 1 ：</strong></p><pre class="line-numbers language-none"><code class="language-none">DELIMITER &#x2F;&#x2F;CREATE PROCEDURE CountProc(IN sid INT,OUT num INT)BEGINSELECT COUNT(*) INTO num FROM fruitsWHERE s_id &#x3D; sid;END &#x2F;&#x2F;DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用存储过程：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; CALL CountProc ( 101 , @num);Query OK, 1 row affected (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看返回结果：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT @num;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该存储过程返回了指定 s_id&#x3D;101 的水果商提供的水果种类，返回值存储在num变量中，使用SELECT查看，返回结果为 3 。</p><p><strong>举例 2 ：</strong> 创建存储过程，实现累加运算，计算 1+2+…+n 等于多少。具体的代码如下：</p><pre class="line-numbers language-none"><code class="language-none">DELIMITER &#x2F;&#x2F;CREATE PROCEDURE &#96;add_num&#96;(IN n INT)BEGINDECLARE i INT;DECLARE sum INT;SET i &#x3D; 1 ;SET sum &#x3D; 0 ;WHILE i &lt;&#x3D; n DOSET sum &#x3D; sum + i;SET i &#x3D; i + 1 ;        END WHILE;        SELECT sum;END &#x2F;&#x2F;DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你用的是 Navicat 工具，那么在编写存储过程的时候，Navicat 会自动设置 DELIMITER 为其他符号，我们不需要再进行 DELIMITER 的操作。</p><p>直接使用 <code>CALL add_num(50);</code>即可。这里我传入的参数为50，也就是统计1+2+…+50的积累之和。</p><h3 id="3-3-如何调试"><a href="#3-3-如何调试" class="headerlink" title="3. 3 如何调试"></a>3. 3 如何调试</h3><p>在 MySQL 中，存储过程不像普通的编程语言（比如 VC++、Java 等）那样有专门的集成开发环境。因此，你可以通过 SELECT 语句，把程序执行的中间结果查询出来，来调试一个 SQL 语句的正确性。调试成功之后，把 SELECT 语句后移到下一个 SQL 语句之后，再调试下一个 SQL 语句。这样<code>逐步推进</code>，就可以完成对存储过程中所有操作的调试了。当然，你也可以把存储过程中的 SQL 语句复制出来，逐段单独调试。</p><hr><h2 id="4-存储函数的使用"><a href="#4-存储函数的使用" class="headerlink" title="4. 存储函数的使用"></a>4. 存储函数的使用</h2><hr><p>前面学习了很多函数，使用这些函数可以对数据进行的各种处理操作，极大地提高用户对数据库的管理效率。MySQL支持自定义函数，定义好之后，调用方式与调用MySQL预定义的系统函数一样。</p><h3 id="4-1-语法分析"><a href="#4-1-语法分析" class="headerlink" title="4. 1 语法分析"></a>4. 1 语法分析</h3><p>学过的函数：LENGTH、SUBSTR、CONCAT等</p><p>语法格式：</p><pre class="line-numbers language-none"><code class="language-none">CREATE FUNCTION 函数名(参数名 参数类型,...)RETURNS 返回值类型[characteristics ...]BEGIN函数体 #函数体中肯定有 RETURN 语句END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ol><li>参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数。</li><li>RETURNS type 语句表示函数返回数据的类型；<br>RETURNS子句只能对FUNCTION做指定，对函数而言这是<code>强制</code>的。它用来指定函数的返回类型，而且函数体必须包含一个<code>RETURN value</code>语句。</li><li>characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。</li><li>函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。</li></ol><h3 id="4-2-调用存储函数"><a href="#4-2-调用存储函数" class="headerlink" title="4. 2 调用存储函数"></a>4. 2 调用存储函数</h3><p>在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。区别在于，存储函数是<code>用户自己定义</code>的，而内部函数是MySQL的<code>开发者定义</code>的。</p><pre class="line-numbers language-none"><code class="language-none">SELECT 函数名(实参列表)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-3-代码举例"><a href="#4-3-代码举例" class="headerlink" title="4. 3 代码举例"></a>4. 3 代码举例</h3><p><strong>举例 1 ：</strong></p><p>创建存储函数，名称为email_by_name()，参数定义为空，该函数查询Abel的email，并返回，数据类型为字符串型。</p><pre class="line-numbers language-none"><code class="language-none">DELIMITER &#x2F;&#x2F;CREATE FUNCTION email_by_name()RETURNS VARCHAR( 25 )DETERMINISTICCONTAINS SQLBEGINRETURN (SELECT email FROM employees WHERE last_name &#x3D; &#39;Abel&#39;);END &#x2F;&#x2F;DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用：</p><pre class="line-numbers language-none"><code class="language-none">SELECT email_by_name();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>举例 2 ：</strong></p><p>创建存储函数，名称为email_by_id()，参数传入emp_id，该函数查询emp_id的email，并返回，数据类型为字符串型。</p><pre class="line-numbers language-none"><code class="language-none">DELIMITER &#x2F;&#x2F;CREATE FUNCTION email_by_id(emp_id INT)RETURNS VARCHAR( 25 )DETERMINISTICCONTAINS SQLBEGINRETURN (SELECT email FROM employees WHERE employee_id &#x3D; emp_id);END &#x2F;&#x2F;DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用：</p><pre class="line-numbers language-none"><code class="language-none">SET @emp_id &#x3D; 102 ;SELECT email_by_id( 102 );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>举例 3 ：</strong></p><p>创建存储函数count_by_id()，参数传入dept_id，该函数查询dept_id部门的员工人数，并返回，数据类型为整型。</p><pre class="line-numbers language-none"><code class="language-none">DELIMITER &#x2F;&#x2F;CREATE FUNCTION count_by_id(dept_id INT)RETURNS INTLANGUAGE SQLNOT DETERMINISTICREADS SQL DATASQL SECURITY DEFINERCOMMENT &#39;查询部门平均工资&#39;BEGINRETURN (SELECT COUNT(*) FROM employees WHERE department_id &#x3D; dept_id);END &#x2F;&#x2F;DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用：</p><pre class="line-numbers language-none"><code class="language-none">SET @dept_id &#x3D; 50 ;SELECT count_by_id(@dept_id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意：</strong></p><p>若在创建存储函数中报错“<code>you might want to use the less safe log_bin_trust_function_creators variable</code>”，有两种处理方法：</p><ul><li><p>方式 1 ：加上必要的函数特性“[NOT] DETERMINISTIC”和“{CONTAINS SQL | NO SQL | READS SQL DATA |MODIFIES SQL DATA}”</p></li><li><p>方式 2 ：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SET GLOBAL log_bin_trust_function_creators &#x3D; 1 ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="4-4-对比存储函数和存储过程"><a href="#4-4-对比存储函数和存储过程" class="headerlink" title="4. 4 对比存储函数和存储过程"></a>4. 4 对比存储函数和存储过程</h3><table><thead><tr><th></th><th>关键字</th><th>调用语法</th><th>返回值</th><th>应用场景</th></tr></thead><tbody><tr><td>存储过程</td><td>PROCEDURE</td><td>CALL 存储过程()</td><td>理解为有 0 个或多个</td><td>一般用于更新</td></tr><tr><td>存储函数</td><td>FUNCTION</td><td>SELECT 函数()</td><td>只能是一个</td><td>一般用于查询结果为一个值并返回时</td></tr></tbody></table><p>此外， <strong>存储函数可以放在查询语句中使用，存储过程不行</strong> 。反之，存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。</p><hr><h2 id="5-存储过程和函数的查看、修改、删除"><a href="#5-存储过程和函数的查看、修改、删除" class="headerlink" title="5. 存储过程和函数的查看、修改、删除"></a>5. 存储过程和函数的查看、修改、删除</h2><hr><h3 id="5-1-查看"><a href="#5-1-查看" class="headerlink" title="5. 1 查看"></a>5. 1 查看</h3><p>创建完之后，怎么知道我们创建的存储过程、存储函数是否成功了呢？</p><p>MySQL存储了存储过程和函数的状态信息，用户可以使用SHOW STATUS语句或SHOW CREATE语句来查看，也可直接从系统的information_schema数据库中查询。这里介绍 3 种方法。</p><p><strong>1. 使用SHOW CREATE语句查看存储过程和函数的创建信息</strong></p><p>基本语法结构如下：</p><pre class="line-numbers language-none"><code class="language-none">SHOW CREATE &#123;PROCEDURE | FUNCTION&#125; 存储过程名或函数名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">SHOW CREATE FUNCTION test_db.CountProc \G<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2. 使用SHOW STATUS语句查看存储过程和函数的状态信息</strong></p><p>基本语法结构如下：</p><pre class="line-numbers language-none"><code class="language-none">SHOW &#123;PROCEDURE | FUNCTION&#125; STATUS [LIKE &#39;pattern&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个语句返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。</p><p>[LIKE ‘pattern’]：匹配存储过程或函数的名称，可以省略。当省略不写时，会列出MySQL数据库中存在的所有存储过程或函数的信息。 举例：SHOW STATUS语句示例，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SHOW PROCEDURE STATUS LIKE &#39;SELECT%&#39; \G*************************** 1. row ***************************Db: test_dbName: SelectAllDataType: PROCEDUREDefiner: root@localhostModified: 2021 - 10 - 16 15 :55:Created: 2021 - 10 - 16 15 :55:Security_type: DEFINERComment:character_set_client: utf8mbcollation_connection: utf8mb4_general_ciDatabase Collation: utf8mb4_general_ci1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 从information_schema.Routines表中查看存储过程和函数的信息</strong></p><p>MySQL中存储过程和函数的信息存储在information_schema数据库下的Routines表中。可以通过查询该表的记录来查询存储过程和函数的信息。其基本语法形式如下：</p><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM information_schema.RoutinesWHERE ROUTINE_NAME&#x3D;&#39;存储过程或函数的名&#39;[AND ROUTINE_TYPE&#x3D;&#123;&#39;PROCEDURE|FUNCTION&#39;&#125;];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>说明：如果在MySQL数据库中存在存储过程和函数名称相同的情况，最好指定ROUTINE_TYPE查询条件来指明查询的是存储过程还是函数。</p><p>举例：从Routines表中查询名称为CountProc的存储函数的信息，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM information_schema.RoutinesWHERE ROUTINE_NAME&#x3D;&#39;count_by_id&#39; AND ROUTINE_TYPE &#x3D; &#39;FUNCTION&#39; \G<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-2-修改"><a href="#5-2-修改" class="headerlink" title="5. 2 修改"></a>5. 2 修改</h3><p>修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。</p><pre class="line-numbers language-none"><code class="language-none">ALTER &#123;PROCEDURE | FUNCTION&#125; 存储过程或函数的名 [characteristic ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。</p><pre class="line-numbers language-none"><code class="language-none">&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;| SQL SECURITY &#123; DEFINER | INVOKER &#125;| COMMENT &#39;string&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p><code>CONTAINS SQL</code>，表示子程序包含SQL语句，但不包含读或写数据的语句。</p></li><li><p><code>NO SQL</code>，表示子程序中不包含SQL语句。</p></li><li><p><code>READS SQL DATA</code>，表示子程序中包含读数据的语句。</p></li><li><p><code>MODIFIES SQL DATA</code>，表示子程序中包含写数据的语句。</p></li><li><p>&#96;&#96;&#96;<br>SQL SECURITY { DEFINER | INVOKER }</p><pre class="line-numbers language-none"><code class="language-none">  ，指明谁有权限来执行。  - &#96;DEFINER&#96;，表示只有定义者自己才能够执行。  - &#96;INVOKER&#96;，表示调用者可以执行。- &#96;COMMENT &#39;string&#39;&#96;，表示注释信息。&gt; 修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。但是，这两个语句的结构是一样的，语句中的所有参数也是一样的。**举例 1 ：**修改存储过程CountProc的定义。将读写权限改为MODIFIES SQL DATA，并指明调用者可以执行，代码如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ALTER PROCEDURE CountProc<br>MODIFIES SQL DATA<br>SQL SECURITY INVOKER ;</p><pre class="line-numbers language-none"><code class="language-none">查询修改后的信息：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>SELECT specific_name,sql_data_access,security_type<br>FROM information_schema.<code>ROUTINES</code><br>WHERE routine_name &#x3D; ‘CountProc’ AND routine_type &#x3D; ‘PROCEDURE’;</p><pre class="line-numbers language-none"><code class="language-none">结果显示，存储过程修改成功。从查询的结果可以看出，访问数据的权限（SQL_DATA_ ACCESS）已经变成MODIFIES SQL DATA，安全类型（SECURITY_TYPE）已经变成INVOKER。**举例 2 ：**修改存储函数CountProc的定义。将读写权限改为READS SQL DATA，并加上注释信息“FIND NAME”，代码如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ALTER FUNCTION CountProc<br>READS SQL DATA<br>COMMENT ‘FIND NAME’ ;</p><pre class="line-numbers language-none"><code class="language-none">存储函数修改成功。从查询的结果可以看出，访问数据的权限（SQL_DATA_ACCESS）已经变成READS SQL DATA，函数注释（ROUTINE_COMMENT）已经变成FIND NAME。### 5. 3 删除删除存储过程和函数，可以使用DROP语句，其语法结构如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DROP {PROCEDURE | FUNCTION} [IF EXISTS] 存储过程或函数的名</p><pre class="line-numbers language-none"><code class="language-none">IF EXISTS：如果程序或函数不存储，它可以防止发生错误，产生一个用SHOW WARNINGS查看的警告。举例：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>DROP PROCEDURE CountProc;<br>DROP FUNCTION CountProc;</p></li></ul><p>&#96;&#96;&#96;</p><hr><h2 id="6-关于存储过程使用的争议"><a href="#6-关于存储过程使用的争议" class="headerlink" title="6. 关于存储过程使用的争议"></a>6. 关于存储过程使用的争议</h2><hr><p>尽管存储过程有诸多优点，但是对于存储过程的使用， <strong>一直都存在着很多争议</strong> ，比如有些公司对于大型项目要求使用存储过程，而有些公司在手册中明确禁止使用存储过程，为什么这些公司对存储过程的使用需求差别这么大呢？</p><h3 id="6-1-优点"><a href="#6-1-优点" class="headerlink" title="6. 1 优点"></a>6. 1 优点</h3><ol><li><strong>存储过程可以一次编译多次使用。</strong>存储过程只在创建时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。</li><li><strong>可以减少开发工作量。</strong> 将代码<code>封装</code>成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以<code>重复使用</code>，在减少开发工作量的同时，还能保证代码的结构清晰。</li><li><strong>存储过程的安全性强。</strong> 我们在设定存储过程的时候可以<code>设置对用户的使用权限</code>，这样就和视图一样具有较强的安全性。</li><li><strong>可以减少网络传输量。</strong> 因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。</li><li><strong>良好的封装性。</strong> 在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要<code>连接一次即可</code>。</li></ol><h3 id="6-2-缺点"><a href="#6-2-缺点" class="headerlink" title="6. 2 缺点"></a>6. 2 缺点</h3><p>基于上面这些优点，不少大公司都要求大型项目使用存储过程，比如微软、IBM 等公司。但是国内的阿里并不推荐开发人员使用存储过程，这是为什么呢？</p><blockquote><p><strong>阿里开发规范</strong></p><p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p></blockquote><p>存储过程虽然有诸如上面的好处，但缺点也是很明显的。</p><ol><li><strong>可移植性差。</strong> 存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</li><li><strong>调试困难。</strong> 只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。</li><li><strong>存储过程的版本管理很困难。</strong> 比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</li><li><strong>它不适合高并发的场景。</strong> 高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，<code>增加数据库的压力</code>，显然就不适用了。</li></ol><p>小结：</p><p>存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说，不论怎样，掌握存储过程都是必备的技能之一。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量、流程控制与游标</title>
      <link href="/2022/07/17/di-16-zhang-bian-liang-liu-cheng-kong-zhi-yu-you-biao/"/>
      <url>/2022/07/17/di-16-zhang-bian-liang-liu-cheng-kong-zhi-yu-you-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="第16章-变量、流程控制与游标"><a href="#第16章-变量、流程控制与游标" class="headerlink" title="第16章_变量、流程控制与游标"></a>第16章_变量、流程控制与游标</h1><h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><hr><p>在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据。</p><p>在 MySQL 数据库中，变量分为<code>系统变量</code>以及<code>用户自定义变量</code>。</p><h3 id="1-1-系统变量"><a href="#1-1-系统变量" class="headerlink" title="1. 1 系统变量"></a>1. 1 系统变量</h3><h4 id="1-1-1-系统变量分类"><a href="#1-1-1-系统变量分类" class="headerlink" title="1. 1. 1 系统变量分类"></a>1. 1. 1 系统变量分类</h4><p>变量由系统定义，不是用户定义，属于<code>服务器</code>层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是<code>编译MySQL时参数</code>的默认值，要么是<code>配置文件</code>（例如my.ini等）中的参数值。大家可以通过网址 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html">https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html</a> 查看MySQL文档的系统变量。</p><p>系统变量分为全局系统变量（需要添加<code>global</code> 关键字）以及会话系统变量（需要添加 <code>session</code> 关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。 <strong>如果不写，默认会话级别。</strong> 静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。</p><p>每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。如下图：</p><p><img src="/../pic/%E7%AC%AC16%E7%AB%A0_%E5%8F%98%E9%87%8F%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%B8%B8%E6%A0%87/1650603237705.png" alt="1650603237705"></p><ul><li>全局系统变量针对于所有会话（连接）有效，但<code>不能跨重启</code></li><li>会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。</li><li>会话 1 对某个全局系统变量值的修改会导致会话 2 中同一个全局系统变量值的修改。</li></ul><p>在MySQL中有些系统变量只能是全局的，例如 max_connections 用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如 character_set_client 用于设置客户端的字符集；有些系统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。</p><h4 id="1-1-2-查看系统变量"><a href="#1-1-2-查看系统变量" class="headerlink" title="1. 1. 2 查看系统变量"></a>1. 1. 2 查看系统变量</h4><ul><li><p><strong>查看所有或部分系统变量</strong></p><pre class="line-numbers language-none"><code class="language-none">#查看所有全局变量SHOW GLOBAL VARIABLES;#查看所有会话变量SHOW SESSION VARIABLES;或SHOW VARIABLES;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#查看满足条件的部分系统变量。SHOW GLOBAL VARIABLES LIKE &#39;%标识符%&#39;;#查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE &#39;%标识符%&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">SHOW GLOBAL VARIABLES LIKE &#39;admin_%&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>查看指定系统变量</strong><br>作为 MySQL 编码规范，MySQL 中的系统变量以<code>两个“@”</code>开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。</p><pre class="line-numbers language-none"><code class="language-none">#查看指定的系统变量的值SELECT @@global.变量名;#查看指定的会话变量的值SELECT @@session.变量名;#或者SELECT @@变量名;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>修改系统变量的值</strong></p><p>有些时候，数据库管理员需要修改系统变量的默认值，以便修改当前会话或者MySQL服务实例的属性、特征。具体方法：<br>方式 1 ：修改MySQL<code>配置文件</code>，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）</p><p>方式 2 ：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值</p><pre class="line-numbers language-none"><code class="language-none">SET @@session.变量名&#x3D;变量值;#方式 2 ：SET SESSION 变量名&#x3D;变量值;#为某个系统变量赋值#方式 1 ：SET @@global.变量名&#x3D;变量值;#方式 2 ：SET GLOBAL 变量名&#x3D;变量值;#为某个会话变量赋值#方式 1 ：SET @@session.变量名&#x3D;变量值;#方式 2 ：SET SESSION 变量名&#x3D;变量值;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">SELECT @@global.autocommit;SET GLOBAL autocommit&#x3D; 0 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">SELECT @@session.tx_isolation;SET @@session.tx_isolation&#x3D;&#39;read-uncommitted&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">SET GLOBAL max_connections &#x3D; 1000 ;SELECT @@global.max_connections;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="1-2-用户变量"><a href="#1-2-用户变量" class="headerlink" title="1. 2 用户变量"></a>1. 2 用户变量</h3><h4 id="1-2-1-用户变量分类"><a href="#1-2-1-用户变量分类" class="headerlink" title="1. 2. 1 用户变量分类"></a>1. 2. 1 用户变量分类</h4><p>用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以<code>一个“@”</code>开头。根据作用范围不同，又分为<code>会话用户变量</code>和<code>局部变量</code>。</p><ul><li>会话用户变量：作用域和会话变量一样，只对<code>当前连接</code>会话有效。</li><li>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在<code>存储过程和函数</code>中使用。</li></ul><h4 id="1-2-2-会话用户变量"><a href="#1-2-2-会话用户变量" class="headerlink" title="1. 2. 2 会话用户变量"></a>1. 2. 2 会话用户变量</h4><ul><li><p>变量的定义</p><pre class="line-numbers language-none"><code class="language-none">#方式 1 ：“&#x3D;”或“:&#x3D;”SET @用户变量 &#x3D; 值;SET @用户变量 :&#x3D; 值;#方式 2 ：“:&#x3D;” 或 INTO关键字SELECT @用户变量 :&#x3D; 表达式 [FROM 等子句];SELECT 表达式 INTO @用户变量 [FROM 等子句];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查看用户变量的值 （查看、比较、运算等）</p><pre class="line-numbers language-none"><code class="language-none">SELECT @用户变量<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>举例</p><pre class="line-numbers language-none"><code class="language-none">SET @a &#x3D; 1 ;SELECT @a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">SELECT @num :&#x3D; COUNT(*) FROM employees;SELECT @num;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">SELECT AVG(salary) INTO @avgsalary FROM employees;SELECT @avgsalary;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">SELECT @big;  #查看某个未声明的变量时，将得到NULL值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="1-2-3-局部变量"><a href="#1-2-3-局部变量" class="headerlink" title="1. 2. 3 局部变量"></a>1. 2. 3 局部变量</h4><p>定义：可以使用<code>DECLARE</code>语句定义一个局部变量</p><p>作用域：仅仅在定义它的 BEGIN … END 中有效</p><p>位置：只能放在 BEGIN … END 中，而且只能放在第一句</p><pre class="line-numbers language-none"><code class="language-none">BEGIN#声明局部变量DECLARE 变量名 1 变量数据类型 [DEFAULT 变量默认值];DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];#为局部变量赋值SET 变量名1 &#x3D; 值;SELECT 值 INTO 变量名2 [FROM 子句];#查看局部变量的值SELECT 变量1,变量2,变量3;END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p><strong>定义变量</strong></p><pre class="line-numbers language-none"><code class="language-none">DECLARE 变量名 类型 [default 值];  # 如果没有DEFAULT子句，初始值为NULL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">DECLARE myparam INT DEFAULT 100 ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>变量赋值</strong><br>方式 1 ：一般用于赋简单的值</p><pre class="line-numbers language-none"><code class="language-none">SET 变量名&#x3D;值;SET 变量名:&#x3D;值;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>方式 2 ：一般用于赋表中的字段值</p><pre class="line-numbers language-none"><code class="language-none">SELECT 字段名或表达式 INTO 变量名 FROM 表;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>使用变量</strong> （查看、比较、运算等）</p><pre class="line-numbers language-none"><code class="language-none">SELECT 局部变量名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>举例 1 ：声明局部变量，并分别赋值为employees表中employee_id为 102 的last_name和salary</p><pre class="line-numbers language-none"><code class="language-none">DELIMITER &#x2F;&#x2F;CREATE PROCEDURE set_value()BEGINDECLARE emp_name VARCHAR( 25 );DECLARE sal DOUBLE( 10 , 2 );SELECT last_name,salary INTO emp_name,salFROM employeesWHERE employee_id &#x3D; 102 ;SELECT emp_name,sal;END &#x2F;&#x2F;DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例 2 ：声明两个变量，求和并打印 （分别使用会话用户变量、局部变量的方式实现）</p><pre class="line-numbers language-none"><code class="language-none">#方式 1 ：使用用户变量SET @m&#x3D; 1 ;SET @n&#x3D; 1 ;SET @sum&#x3D;@m+@n;SELECT @sum;#方式 2 ：使用局部变量DELIMITER &#x2F;&#x2F;CREATE PROCEDURE add_value()BEGIN    #局部变量    DECLARE m INT DEFAULT 1 ;    DECLARE n INT DEFAULT 3 ;    DECLARE SUM INT;    SET SUM &#x3D; m+n;    SELECT SUM;END &#x2F;&#x2F;DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例 3 ：创建存储过程“different_salary”查询某员工和他领导的薪资差距，并用IN参数emp_id接收员工id，用OUT参数dif_salary输出薪资差距结果。</p><pre class="line-numbers language-none"><code class="language-none">#声明DELIMITER &#x2F;&#x2F;CREATE PROCEDURE different_salary(IN emp_id INT,OUT dif_salary DOUBLE)BEGIN    #声明局部变量    DECLARE emp_sal,mgr_sal DOUBLE DEFAULT 0.0;    DECLARE mgr_id INT;    SELECT salary INTO emp_sal FROM employees WHERE employee_id &#x3D; emp_id;    SELECT manager_id INTO mgr_id FROM employees WHERE employee_id &#x3D; emp_id;    SELECT salary INTO mgr_sal FROM employees WHERE employee_id &#x3D; mgr_id;    SET dif_salary &#x3D; mgr_sal - emp_sal;END &#x2F;&#x2F;DELIMITER ;#调用SET @emp_id &#x3D; 102 ;CALL different_salary(@emp_id,@diff_sal);#查看SELECT @diff_sal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-4-对比会话用户变量与局部变量"><a href="#1-2-4-对比会话用户变量与局部变量" class="headerlink" title="1. 2. 4 对比会话用户变量与局部变量"></a>1. 2. 4 对比会话用户变量与局部变量</h4><table><thead><tr><th></th><th>作用域</th><th>定义位置</th><th>语法</th></tr></thead><tbody><tr><td>会话用户变量</td><td>当前会话</td><td>会话的任何地方</td><td>加@符号，不用指定类型</td></tr><tr><td>局部变量</td><td>定义它的BEGIN END中</td><td>BEGIN END的第一句话</td><td>一般不用加@,需要指定类型</td></tr></tbody></table><hr><h2 id="2-定义条件与处理程序"><a href="#2-定义条件与处理程序" class="headerlink" title="2. 定义条件与处理程序"></a>2. 定义条件与处理程序</h2><hr><p><code>定义条件</code>是事先定义程序执行过程中可能遇到的问题，<code>处理程序</code>定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。</p><p>说明：定义条件和处理程序在存储过程、存储函数中都是支持的。</p><h3 id="2-1-案例分析"><a href="#2-1-案例分析" class="headerlink" title="2. 1 案例分析"></a>2. 1 案例分析</h3><p><strong>案例分析</strong>：创建一个名称为“UpdateDataNoCondition”的存储过程。代码如下：</p><pre class="line-numbers language-none"><code class="language-none">DELIMITER &#x2F;&#x2F;CREATE PROCEDURE UpdateDataNoCondition()    BEGIN        SET @x &#x3D; 1 ;        UPDATE employees SET email &#x3D; NULL WHERE last_name &#x3D; &#39;Abel&#39;;        SET @x &#x3D; 2 ;        UPDATE employees SET email &#x3D; &#39;aabbel&#39; WHERE last_name &#x3D; &#39;Abel&#39;;        SET @x &#x3D; 3 ;    END &#x2F;&#x2F;DELIMITER ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用存储过程：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; CALL UpdateDataNoCondition();ERROR 1048 ( 23000 ): Column &#39;email&#39; cannot be nullmysql&gt; SELECT @x;+------+| @x |+------+| 1 |+------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，此时@x变量的值为 1 。结合创建存储过程的SQL语句代码可以得出：在存储过程中未定义条件和处理程序，且当存储过程中执行的SQL语句报错时，MySQL数据库会抛出错误，并退出当前SQL逻辑，不再向下继续执行。</p><h3 id="2-2-定义条件"><a href="#2-2-定义条件" class="headerlink" title="2. 2 定义条件"></a>2. 2 定义条件</h3><p>定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个<code>错误名字</code>和<code>指定的错误条件</code>关联起来。这个名字可以随后被用在定义处理程序的<code>DECLARE HANDLER</code>语句中。</p><p>定义条件使用DECLARE语句，语法格式如下：</p><pre class="line-numbers language-none"><code class="language-none">DECLARE 错误名称 CONDITION FOR 错误码（或错误条件）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>错误码的说明：</p><ul><li>&#96;&#96;&#96;<br>MySQL_error_code<pre class="line-numbers language-none"><code class="language-none">和<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>sqlstate_value<pre class="line-numbers language-none"><code class="language-none">  都可以表示MySQL的错误。  - MySQL_error_code是数值类型错误代码。  - sqlstate_value是长度为 5 的字符串类型错误代码。- 例如，在ERROR 1418 (HY000)中,1418 是MySQL_error_code，’HY000’是sqlstate_value。- 例如，在ERROR 1142 (42000)中,1142 是MySQL_error_code，’42000’是sqlstate_value。**举例 1** ： 定义“Field_Not_Be_NULL”错误名与MySQL中违反非空约束的错误类型是“ERROR 1048 (23000)”对应。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>#使用MySQL_error_code<br>DECLARE Field_Not_Be_NULL CONDITION FOR 1048 ;</li></ul><p>#使用sqlstate_value<br>DECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE ‘23000’;</p><pre class="line-numbers language-none"><code class="language-none">**举例 2** ： 定义”ERROR 1148(42000)”错误，名称为command_not_allowed。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>#使用MySQL_error_code<br>DECLARE command_not_allowed CONDITION FOR 1148 ;</p><p>#使用sqlstate_value<br>DECLARE command_not_allowed CONDITION FOR SQLSTATE ‘42000’;</p><pre class="line-numbers language-none"><code class="language-none">### 2. 3 定义处理程序可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。定义处理程序时，使用DECLARE语句的语法如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>DECLARE 处理方式 HANDLER FOR 错误类型 处理语句</p><pre class="line-numbers language-none"><code class="language-none">- 处理方式     ：处理方式有 3 个取值：CONTINUE、EXIT、UNDO。  - &#96;CONTINUE&#96;：表示遇到错误不处理，继续执行。  - &#96;EXIT&#96;：表示遇到错误马上退出。  - &#96;UNDO&#96;：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。- 错误类型     （即条件）可以有如下取值：  - &#96;SQLSTATE &#39;字符串错误码&#39;&#96;：表示长度为 5 的sqlstate_value类型的错误代码；  - &#96;MySQL_error_code&#96;：匹配数值类型错误代码；  - &#96;错误名称&#96;：表示DECLARE … CONDITION定义的错误条件名称。  - &#96;SQLWARNING&#96;：匹配所有以 01 开头的SQLSTATE错误代码；  - &#96;NOT FOUND&#96;：匹配所有以 02 开头的SQLSTATE错误代码；  - &#96;SQLEXCEPTION&#96;：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码；- **处理语句** ：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是像“&#96;SET 变量 &#x3D; 值&#96;”这样的简单语句，也可以是使用&#96;BEGIN ... END&#96;编写的复合语句。定义处理程序的几种方式，代码如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#方法 1 ：捕获sqlstate_value<br>DECLARE CONTINUE HANDLER FOR SQLSTATE ‘42S02’ SET @info&#x3D;’NO_SUCH_TABLE’;</p><p>#方法 2 ：捕获mysql_error_value<br>DECLARE CONTINUE HANDLER FOR 1146 SET @info &#x3D; ‘NO_SUCH_TABLE’;</p><p>#方法 3 ：先定义条件，再调用<br>DECLARE no_such_table CONDITION FOR 1146 ;<br>DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info &#x3D; ‘NO_SUCH_TABLE’;</p><p>#方法 4 ：使用SQLWARNING<br>DECLARE EXIT HANDLER FOR SQLWARNING SET @info &#x3D; ‘ERROR’;</p><p>#方法 5 ：使用NOT FOUND<br>DECLARE EXIT HANDLER FOR NOT FOUND SET @info &#x3D; ‘NO_SUCH_TABLE’;</p><p>#方法 6 ：使用SQLEXCEPTION<br>DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info &#x3D; ‘ERROR’;</p><pre class="line-numbers language-none"><code class="language-none">### 2. 4 案例解决在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到MySQL_error_code值为 1048 时，执行CONTINUE操作，并且将@proc_value的值设置为-1。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>DELIMITER &#x2F;&#x2F;</p><p>CREATE PROCEDURE UpdateDataNoCondition()<br>    BEGIN<br>        #定义处理程序<br>        DECLARE CONTINUE HANDLER FOR 1048 SET @proc_value &#x3D; - 1 ;</p><pre><code>    SET @x = 1 ;    UPDATE employees SET email = NULL WHERE last_name = &#39;Abel&#39;;    SET @x = 2 ;    UPDATE employees SET email = &#39;aabbel&#39; WHERE last_name = &#39;Abel&#39;;    SET @x = 3 ;END //</code></pre><p>DELIMITER ;</p><pre class="line-numbers language-none"><code class="language-none">调用过程：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>mysql&gt; CALL UpdateDataWithCondition();<br>Query OK, 0 rows affected (0.01 sec)</p><pre class="line-numbers language-none"><code class="language-none">**举例：**创建一个名称为“InsertDataWithCondition”的存储过程，代码如下。在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到sqlstate_value值为 23000 时，执行EXIT操作，并且将@proc_value的值设置为-1。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#准备工作<br>CREATE TABLE departments<br>AS<br>SELECT * FROM atguigudb.<code>departments</code>;</p><p>ALTER TABLE departments<br>ADD CONSTRAINT uk_dept_name UNIQUE(department_id);<br>DELIMITER &#x2F;&#x2F;</p><p>CREATE PROCEDURE InsertDataWithCondition()<br>    BEGIN<br>        DECLARE duplicate_entry CONDITION FOR SQLSTATE ‘23000’ ;<br>        DECLARE EXIT HANDLER FOR duplicate_entry SET @proc_value &#x3D; - 1 ;</p><pre><code>    SET @x = 1 ;    INSERT INTO departments(department_name) VALUES(&#39;测试&#39;);    SET @x = 2 ;    INSERT INTO departments(department_name) VALUES(&#39;测试&#39;);    SET @x = 3 ;END //</code></pre><p>DELIMITER ;</p><pre class="line-numbers language-none"><code class="language-none">调用存储过程：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>mysql&gt; CALL InsertDataWithCondition();<br>Query OK, 0 rows affected (0.01 sec)</p><p>mysql&gt; SELECT @x,@proc_value;<br>+——+————-+<br>| @x | @proc_value |<br>+——+————-+<br>| 2 | - 1 |<br>+——+————-+<br>1 row in set (0.00 sec)</p><pre class="line-numbers language-none"><code class="language-none">------## 3. 流程控制------解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL 操作。流程控制语句的作用就是控制存储过程中 SQL 语句的执行顺序，是我们完成复杂操作必不可少的一部分。只要是执行的程序，流程就分为三大类：- &#96;顺序结构&#96;：程序从上往下依次执行- &#96;分支结构&#96;：程序按条件进行选择执行，从两条或多条路径中选择一条执行- &#96;循环结构&#96;：程序满足一定条件下，重复执行一组语句针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。- &#96;条件判断语句&#96;：IF 语句和 CASE 语句- &#96;循环语句&#96;：LOOP、WHILE 和 REPEAT 语句- &#96;跳转语句&#96;：ITERATE 和 LEAVE 语句### 3. 1 分支结构之 IF- IF 语句的语法结构是：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  IF 表达式 1 THEN 操作 1<br>  [ELSEIF 表达式 2 THEN 操作2]……<br>  [ELSE 操作N]<br>  END IF<br>  <pre class="line-numbers language-none"><code class="language-none">  根据表达式的结果为TRUE或FALSE执行相应的语句。这里“[]”中的内容是可选的。- 特点：① 不同的表达式对应不同的操作 ② 使用在begin end中- **举例 1 ：**<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>  IF val IS NULL<br>      THEN SELECT ‘val is null’;<br>  ELSE SELECT ‘val is not null’;</p><p>  END IF;<br>  <pre class="line-numbers language-none"><code class="language-none">- 举例 2 ： 声明存储过程“update_salary_by_eid1”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于 8000 元并且入职时间超过 5 年，就涨薪 500 元；否则就不变。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>  DELIMITER &#x2F;&#x2F;</p><p>  CREATE PROCEDURE update_salary_by_eid1(IN emp_id INT)<br>  BEGIN<br>      DECLARE emp_salary DOUBLE;<br>      DECLARE hire_year DOUBLE;</p><pre><code>  SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;  SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_year  FROM employees WHERE employee_id = emp_id;  IF emp_salary &lt; 8000 AND hire_year &gt; 5  THEN UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id;  END IF;</code></pre><p>  END &#x2F;&#x2F;</p><p>  DELIMITER ;<br>  <pre class="line-numbers language-none"><code class="language-none">- 举例 3 ： 声明存储过程“update_salary_by_eid2”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于 9000 元并且入职时间超过 5 年，就涨薪 500 元；否则就涨薪 100 元。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>  DELIMITER &#x2F;&#x2F;</p><p>  CREATE PROCEDURE update_salary_by_eid2(IN emp_id INT)<br>  BEGIN<br>      DECLARE emp_salary DOUBLE;<br>      DECLARE hire_year DOUBLE;</p><pre><code>  SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;  SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_year  FROM employees WHERE employee_id = emp_id;  IF emp_salary &lt; 8000 AND hire_year &gt; 5      THEN UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id;  ELSE      UPDATE employees SET salary = salary + 100 WHERE employee_id = emp_id;  END IF;</code></pre><p>  END &#x2F;&#x2F;</p><p>  DELIMITER ;<br>  <pre class="line-numbers language-none"><code class="language-none">- 举例 4 ： 声明存储过程“update_salary_by_eid3”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于 9000 元，就更新薪资为 9000 元；薪资如果大于等于 9000 元且低于 10000 的，但是奖金比例为NULL的，就更新奖金比例为0.01；其他的涨薪 100 元。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>  DELIMITER &#x2F;&#x2F;</p><p>  CREATE PROCEDURE update_salary_by_eid3(IN emp_id INT)<br>  BEGIN<br>      DECLARE emp_salary DOUBLE;<br>      DECLARE bonus DECIMAL( 3 , 2 );</p><pre><code>  SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;  SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;  IF emp_salary &lt; 9000      THEN UPDATE employees SET salary = 9000 WHERE employee_id = emp_id;  ELSEIF emp_salary &lt; 10000 AND bonus IS NULL      THEN UPDATE employees SET commission_pct = 0.01 WHERE employee_id = emp_id;  ELSE      UPDATE employees SET salary = salary + 100 WHERE employee_id = emp_id;  END IF;</code></pre><p>  END &#x2F;&#x2F;</p><p>  DELIMITER ;<br>  <pre class="line-numbers language-none"><code class="language-none">### 3. 2 分支结构之 CASECASE 语句的语法结构 1 ：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>#情况一：类似于switch<br>CASE 表达式<br>WHEN 值 1 THEN 结果 1 或语句1(如果是语句，需要加分号)<br>WHEN 值 2 THEN 结果 2 或语句2(如果是语句，需要加分号)<br>…<br>ELSE 结果n或语句n(如果是语句，需要加分号)<br>END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）</p><pre class="line-numbers language-none"><code class="language-none">CASE 语句的语法结构 2 ：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>#情况二：类似于多重if<br>CASE<br>WHEN 条件 1 THEN 结果 1 或语句1(如果是语句，需要加分号)<br>WHEN 条件 2 THEN 结果 2 或语句2(如果是语句，需要加分号)<br>…<br>ELSE 结果n或语句n(如果是语句，需要加分号)<br>END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）</p><pre class="line-numbers language-none"><code class="language-none">- **举例 1 ：**  使用CASE流程控制语句的第 1 种格式，判断val值等于 1 、等于 2 ，或者两者都不等。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>  CASE val<br>      WHEN 1 THEN SELECT ‘val is 1’;<br>      WHEN 2 THEN SELECT ‘val is 2’;<br>      ELSE SELECT ‘val is not 1 or 2’;<br>  END CASE;<br>  <pre class="line-numbers language-none"><code class="language-none">- **举例 2 ：**  使用CASE流程控制语句的第2种格式，判断val是否为空、小于0 、大于0或者等于 0 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>  CASE<br>      WHEN val IS NULL THEN SELECT ‘val is null’;<br>      WHEN val &lt; 0 THEN SELECT ‘val is less than 0’;<br>      WHEN val &gt; 0 THEN SELECT ‘val is greater than 0’;<br>      ELSE SELECT ‘val is 0’;<br>  END CASE;<br>  <pre class="line-numbers language-none"><code class="language-none">- 举例 3 ：  声明存储过程“update_salary_by_eid4”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于 9000 元，就更新薪资为 9000 元；薪资大于等于 9000 元且低于 10000 的，但是奖金比例为NULL的，就更新奖金比例为0.01；其他的涨薪 100 元。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>  DELIMITER &#x2F;&#x2F;</p><p>  CREATE PROCEDURE update_salary_by_eid4(IN emp_id INT)<br>  BEGIN<br>      DECLARE emp_sal DOUBLE;<br>      DECLARE bonus DECIMAL( 3 , 2 );</p><pre><code>  SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;  SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;  CASE  WHEN emp_sal&lt; 9000      THEN UPDATE employees SET salary= 9000 WHERE employee_id = emp_id;  WHEN emp_sal&lt; 10000 AND bonus IS NULL      THEN UPDATE employees SET commission_pct=0.01 WHERE employee_id = emp_id;  ELSE      UPDATE employees SET salary=salary+ 100 WHERE employee_id = emp_id;  END CASE;</code></pre><p>  END &#x2F;&#x2F;</p><p>  DELIMITER ;<br>  <pre class="line-numbers language-none"><code class="language-none">- 举例 4 ：  声明存储过程update_salary_by_eid5，定义IN参数emp_id，输入员工编号。判断该员工的入职年限，如果是 0 年，薪资涨 50 ；如果是 1 年，薪资涨 100 ；如果是 2 年，薪资涨 200 ；如果是 3 年，薪资涨 300 ；如果是 4 年，薪资涨 400 ；其他的涨薪 500 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>  DELIMITER &#x2F;&#x2F;</p><p>  CREATE PROCEDURE update_salary_by_eid5(IN emp_id INT)<br>  BEGIN<br>      DECLARE emp_sal DOUBLE;<br>      DECLARE hire_year DOUBLE;</p><pre><code>  SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;  SELECT ROUND(DATEDIFF(CURDATE(),hire_date)/365) INTO hire_year FROM employees  WHERE employee_id = emp_id;  CASE hire_year      WHEN 0 THEN UPDATE employees SET salary=salary+ 50 WHERE employee_id = emp_id;      WHEN 1 THEN UPDATE employees SET salary=salary+ 100 WHERE employee_id = emp_id;      WHEN 2 THEN UPDATE employees SET salary=salary+ 200 WHERE employee_id = emp_id;      WHEN 3 THEN UPDATE employees SET salary=salary+ 300 WHERE employee_id = emp_id;      WHEN 4 THEN UPDATE employees SET salary=salary+ 400 WHERE employee_id = emp_id;      ELSE UPDATE employees SET salary=salary+ 500 WHERE employee_id = emp_id;  END CASE;</code></pre><p>  END &#x2F;&#x2F;</p><p>  DELIMITER ;<br>  <pre class="line-numbers language-none"><code class="language-none">### 3. 3 循环结构之LOOPLOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子句），跳出循环过程。LOOP语句的基本格式如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>[loop_label:] LOOP<br>    循环执行的语句<br>END LOOP [loop_label]</p><pre class="line-numbers language-none"><code class="language-none">其中loop_label表示LOOP语句的标注名称，该参数可以省略。**举例 1 ：**使用LOOP语句进行循环操作，id值小于 10 时将重复执行循环过程。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DECLARE id INT DEFAULT 0 ;<br>add_loop:LOOP<br>    SET id &#x3D; id + 1 ;<br>    IF id &gt;&#x3D; 10 THEN LEAVE add_loop;<br>    END IF;</p><p>END LOOP add_loop;</p><pre class="line-numbers language-none"><code class="language-none">**举例 2 ：**当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程“update_salary_loop()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为原来的1.1倍。直到全公司的平均薪资达到 12000 结束。并统计循环次数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>DELIMITER &#x2F;&#x2F;</p><p>CREATE PROCEDURE update_salary_loop(OUT num INT)<br>BEGIN<br>    DECLARE avg_salary DOUBLE;<br>    DECLARE loop_count INT DEFAULT 0 ;</p><pre><code>SELECT AVG(salary) INTO avg_salary FROM employees;label_loop:LOOP    IF avg_salary &gt;= 12000 THEN LEAVE label_loop;    END IF;    UPDATE employees SET salary = salary * 1.1;    SET loop_count = loop_count + 1 ;    SELECT AVG(salary) INTO avg_salary FROM employees;END LOOP label_loop;SET num = loop_count;</code></pre><p>END &#x2F;&#x2F;</p><p>DELIMITER ;</p><pre class="line-numbers language-none"><code class="language-none">### 3. 4 循环结构之WHILEWHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>[while_label:] WHILE 循环条件 DO<br>    循环体<br>END WHILE [while_label];</p><pre class="line-numbers language-none"><code class="language-none">while_label为WHILE语句的标注名称；如果循环条件结果为真，WHILE语句内的语句或语句群被执行，直至循环条件为假，退出循环。**举例 1 ：**WHILE语句示例，i值小于 10 时，将重复执行循环过程，代码如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DELIMITER &#x2F;&#x2F;</p><p>CREATE PROCEDURE test_while()<br>BEGIN<br>    DECLARE i INT DEFAULT 0 ;</p><pre><code>WHILE i &lt; 10 DO    SET i = i + 1 ;END WHILE;SELECT i;</code></pre><p>END &#x2F;&#x2F;</p><p>DELIMITER ;<br>#调用<br>CALL test_while();</p><pre class="line-numbers language-none"><code class="language-none">**举例 2 ：**市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“update_salary_while()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家降薪，薪资降为原来的90%。直到全公司的平均薪资达到 5000 结束。并统计循环次数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>DELIMITER &#x2F;&#x2F;</p><p>CREATE PROCEDURE update_salary_while(OUT num INT)<br>BEGIN<br>    DECLARE avg_sal DOUBLE ;<br>    DECLARE while_count INT DEFAULT 0 ;</p><pre><code>SELECT AVG(salary) INTO avg_sal FROM employees;WHILE avg_sal &gt; 5000 DO    UPDATE employees SET salary = salary * 0.9;    SET while_count = while_count + 1 ;    SELECT AVG(salary) INTO avg_sal FROM employees;END WHILE;SET num = while_count;</code></pre><p>END &#x2F;&#x2F;</p><p>DELIMITER ;</p><pre class="line-numbers language-none"><code class="language-none">### 3. 5 循环结构之REPEATREPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。REPEAT语句的基本格式如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[repeat_label:] REPEAT<br>　　　　循环体的语句<br>UNTIL 结束循环的条件表达式<br>END REPEAT [repeat_label]</p><pre class="line-numbers language-none"><code class="language-none">repeat_label为REPEAT语句的标注名称，该参数可以省略；REPEAT语句内的语句或语句群被重复，直至expr_condition为真。**举例 1 ：**<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>DELIMITER &#x2F;&#x2F;</p><p>CREATE PROCEDURE test_repeat()<br>BEGIN<br>    DECLARE i INT DEFAULT 0 ;</p><pre><code>REPEAT    SET i = i + 1 ;UNTIL i &gt;= 10END REPEAT;SELECT i;</code></pre><p>END &#x2F;&#x2F;</p><p>DELIMITER ;</p><pre class="line-numbers language-none"><code class="language-none">**举例 2 ：**当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程“update_salary_repeat()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为原来的1.15倍。直到全公司的平均薪资达到 13000 结束。并统计循环次数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>DELIMITER &#x2F;&#x2F;</p><p>CREATE PROCEDURE update_salary_repeat(OUT num INT)<br>BEGIN<br>    DECLARE avg_sal DOUBLE ;<br>    DECLARE repeat_count INT DEFAULT 0 ;</p><pre><code>SELECT AVG(salary) INTO avg_sal FROM employees;REPEAT    UPDATE employees SET salary = salary * 1.15;    SET repeat_count = repeat_count + 1 ;    SELECT AVG(salary) INTO avg_sal FROM employees;UNTIL avg_sal &gt;= 13000END REPEAT;SET num = repeat_count;</code></pre><p>END &#x2F;&#x2F;</p><p>DELIMITER ;</p><pre class="line-numbers language-none"><code class="language-none">**对比三种循环结构：**1. 这三种循环都可以省略名称，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加名称。2. LOOP：一般用于实现简单的”死”循环 WHILE：先判断后执行 REPEAT：先执行后判断，无条件至少执行一次### 3. 6 跳转语句之LEAVE语句LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出程序体的操作。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 break。基本格式如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LEAVE 标记名</p><pre class="line-numbers language-none"><code class="language-none">其中，label参数表示循环的标志。LEAVE和BEGIN … END或循环一起被使用。**举例 1 ：**创建存储过程 “leave_begin()”，声明INT类型的IN参数num。给BEGIN…END加标记名，并在BEGIN…END中使用IF语句判断num参数的值。- 如果num&lt;&#x3D;0，则使用LEAVE语句退出BEGIN…END；- 如果num&#x3D;1，则查询“employees”表的平均薪资；- 如果num&#x3D;2，则查询“employees”表的最低薪资；- 如果num&gt;2，则查询“employees”表的最高薪资。IF语句结束后查询“employees”表的总人数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DELIMITER &#x2F;&#x2F;</p><p>CREATE PROCEDURE leave_begin(IN num INT)<br>    begin_label: BEGIN<br>        IF num&lt;&#x3D; 0<br>            THEN LEAVE begin_label;<br>        ELSEIF num&#x3D; 1<br>            THEN SELECT AVG(salary) FROM employees;<br>        ELSEIF num&#x3D; 2<br>            THEN SELECT MIN(salary) FROM employees;<br>        ELSE<br>            SELECT MAX(salary) FROM employees;<br>        END IF;</p><pre><code>    SELECT COUNT(*) FROM employees;END //</code></pre><p>DELIMITER ;</p><pre class="line-numbers language-none"><code class="language-none">**举例 2 ：**当市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“leave_while()”，声明OUT参数num，输出循环次数，存储过程中使用WHILE循环给大家降低薪资为原来薪资的90%，直到全公司的平均薪资小于等于 10000 ，并统计循环次数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>DELIMITER &#x2F;&#x2F;</p><p>CREATE PROCEDURE leave_while(OUT num INT)<br>BEGIN<br>    #<br>    DECLARE avg_sal DOUBLE;#记录平均工资<br>    DECLARE while_count INT DEFAULT 0 ; #记录循环次数</p><pre><code>SELECT AVG(salary) INTO avg_sal FROM employees; #① 初始化条件while_label:WHILE TRUE DO #② 循环条件    #③ 循环体    IF avg_sal &lt;= 10000 THEN    LEAVE while_label;    END IF;    UPDATE employees SET salary = salary * 0.9;    SET while_count = while_count + 1 ;    #④ 迭代条件    SELECT AVG(salary) INTO avg_sal FROM employees;END WHILE;#赋值SET num = while_count;</code></pre><p>END &#x2F;&#x2F;</p><p>DELIMITER ;</p><pre class="line-numbers language-none"><code class="language-none">### 3. 7 跳转语句之ITERATE语句ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序转到语句段开头处。如果你有面向过程的编程语言的使用经验，你可以把 ITERATE 理解为 continue，意思为“再次循环”。语句基本格式如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ITERATE label</p><pre class="line-numbers language-none"><code class="language-none">label参数表示循环的标志。ITERATE语句必须跟在循环标志前面。**举例：** 定义局部变量num，初始值为 0 。循环结构中执行num + 1操作。- 如果num &lt; 10，则继续执行循环；- 如果num &gt; 15，则退出循环结构；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DELIMITER &#x2F;&#x2F;</p><p>CREATE PROCEDURE test_iterate()<br>BEGIN<br>    DECLARE num INT DEFAULT 0 ;</p><pre><code>my_loop:LOOP    SET num = num + 1 ;    IF num &lt; 10        THEN ITERATE my_loop;    ELSEIF num &gt; 15        THEN LEAVE my_loop;    END IF;    SELECT &#39;尚硅谷：让天下没有难学的技术&#39;;END LOOP my_loop;</code></pre><p>END &#x2F;&#x2F;</p><p>DELIMITER ;</p><pre class="line-numbers language-none"><code class="language-none">------## 4. 游标------### 4. 1 什么是游标（或光标）虽然我们也可以通过筛选条件 WHERE 和 HAVING，或者是限定返回记录的关键字 LIMIT 返回一条记录，但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是&#96;随意定位到某一条记录&#96;，并对记录的数据进行处理。这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。 **游标让 SQL 这种面向集合的语言有了面向过程开发的能力。**在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标&#96;充当了指针的作用&#96;，我们可以通过操作游标来对数据行进行操作。MySQL中游标可以在存储过程和函数中使用。比如，我们查询了 employees 数据表中工资高于 15000 的员工都有哪些：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SELECT employee_id,last_name,salary FROM employees<br>WHERE salary &gt; 15000 ;</p><pre class="line-numbers language-none"><code class="language-none">![1650606584642](..&#x2F;pic&#x2F;第16章_变量、流程控制与游标&#x2F;1650606584642.png)这里我们就可以通过游标来操作数据行，如图所示此时游标所在的行是“108”的记录，我们也可以在结果集上滚动游标，指向结果集中的任意一行。### 4. 2 使用游标步骤游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。如果我们想要使用游标，一般需要经历四个步骤。不同的 DBMS 中，使用游标的语法可能略有不同。**第一步，声明游标**在MySQL中，使用DECLARE关键字来声明游标，其语法的基本形式如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DECLARE cursor_name CURSOR FOR select_statement;</p><pre class="line-numbers language-none"><code class="language-none">这个语法适用于 MySQL，SQL Server，DB2 和 MariaDB。如果是用 Oracle 或者 PostgreSQL，需要写成：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>DECLARE cursor_name CURSOR IS select_statement;</p><pre class="line-numbers language-none"><code class="language-none">要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是SELECT 语句，返回一个用于创建游标的结果集。比如：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>DECLARE cur_emp CURSOR FOR<br>SELECT employee_id,salary FROM employees;<br>DECLARE cursor_fruit CURSOR FOR<br>SELECT f_name, f_price FROM fruits ;</p><pre class="line-numbers language-none"><code class="language-none">**第二步，打开游标**打开游标的语法如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>OPEN cursor_name</p><pre class="line-numbers language-none"><code class="language-none">当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的&#96;逐条读取&#96;结果集中的记录做准备。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>OPEN cur_emp ;</p><pre class="line-numbers language-none"><code class="language-none">**第三步，使用游标（从游标中取得数据）**语法如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>FETCH cursor_name INTO var_name [, var_name] …</p><pre class="line-numbers language-none"><code class="language-none">这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。注意：var_name必须在声明游标之前就定义好。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>FETCH cur_emp INTO emp_id, emp_sal ;</p><pre class="line-numbers language-none"><code class="language-none">注意： **游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致** ，否则，在存储过程执行的时候，MySQL 会提示错误。**第四步，关闭游标**<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>CLOSE cursor_name</p><pre class="line-numbers language-none"><code class="language-none">有 OPEN 就会有 CLOSE，也就是打开和关闭游标。当我们使用完游标后需要关闭掉该游标。因为游标会&#96;占用系统资源&#96;，如果不及时关闭， **游标会一直保持到存储过程结束** ，影响系统运行的效率。而关闭游标的操作，会释放游标占用的系统资源。关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>CLOSE cur_emp;</p><pre class="line-numbers language-none"><code class="language-none">### 4. 3 举例创建存储过程“get_count_by_limit_total_salary()”，声明IN参数 limit_total_salary，DOUBLE类型；声明OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和达到limit_total_salary参数的值，返回累加的人数给total_count。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>DELIMITER &#x2F;&#x2F;</p><p>CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUT total_count INT)<br>BEGIN<br>    DECLARE sum_salary DOUBLE DEFAULT 0 ;  #记录累加的总工资<br>    DECLARE cursor_salary DOUBLE DEFAULT 0 ; #记录某一个工资值<br>    DECLARE emp_count INT DEFAULT 0 ; #记录循环个数<br>    #定义游标<br>    DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;<br>    #打开游标<br>    OPEN emp_cursor;</p><pre><code>REPEAT    #使用游标（从游标中获取数据）    FETCH emp_cursor INTO cursor_salary;    SET sum_salary = sum_salary + cursor_salary;    SET emp_count = emp_count + 1 ;    UNTIL sum_salary &gt;= limit_total_salaryEND REPEAT;SET total_count = emp_count;#关闭游标CLOSE emp_cursor;</code></pre><p>END &#x2F;&#x2F;</p><p>DELIMITER ;</p><pre class="line-numbers language-none"><code class="language-none">### 4. 5 小结游标是 MySQL 的一个重要的功能，为&#96;逐条读取&#96;结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行&#96;加锁&#96;，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会&#96;消耗系统资源&#96;，造成内存不足，这是因为游标是在内存中进行的处理。建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。------## 补充：MySQL 8. 0 的新特性—全局变量的持久化------在MySQL数据库中，全局变量可以通过SET GLOBAL语句来设置。例如，设置服务器语句超时的限制，可以通过设置系统变量max_execution_time来实现：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SET GLOBAL MAX_EXECUTION_TIME&#x3D; 2000 ;</p><pre class="line-numbers language-none"><code class="language-none">使用SET GLOBAL语句设置的变量值只会&#96;临时生效&#96;。&#96;数据库重启后&#96;，服务器又会从MySQL配置文件中读取变量的默认值。 MySQL 8.0版本新增了&#96;SET PERSIST&#96;命令。例如，设置服务器的最大连接数为 1000 ：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>SET PERSIST global max_connections &#x3D; 1000 ;</p><pre class="line-numbers language-none"><code class="language-none">MySQL会将该命令的配置保存到数据目录下的&#96;mysqld-auto.cnf&#96;文件中，下次启动时会读取该文件，用其中的配置来覆盖默认的配置文件。举例：查看全局变量max_connections的值，结果如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mysql&gt; show variables like ‘%max_connections%’;<br>+————————+——-+<br>| Variable_name | Value |<br>+————————+——-+<br>| max_connections | 151 |<br>| mysqlx_max_connections | 100 |<br>+————————+——-+<br>2 rows in set, 1 warning (0.00 sec)</p><pre class="line-numbers language-none"><code class="language-none">设置全局变量max_connections的值：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>mysql&gt; set persist max_connections&#x3D; 1000 ;<br>Query OK, 0 rows affected (0.00 sec)</p><pre class="line-numbers language-none"><code class="language-none">&#96;重启MySQL服务器&#96;，再次查询max_connections的值：&#96;&#96;&#96;sqlmysql&gt; show variables like &#39;%max_connections%&#39;;+------------------------+-------+| Variable_name | Value |+------------------------+-------+| max_connections | 1000 || mysqlx_max_connections | 100 |+------------------------+-------+2 rows in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>触发器</title>
      <link href="/2022/07/17/di-17-zhang-hong-fa-qi/"/>
      <url>/2022/07/17/di-17-zhang-hong-fa-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="第17章-触发器"><a href="#第17章-触发器" class="headerlink" title="第17章_触发器"></a>第17章_触发器</h1><p>在实际开发中，我们经常会遇到这样的情况：有 2 个或者多个相互关联的表，如<code>商品信息</code>和<code>库存信息</code>分别存放在 2 个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时在库存表中添加一条库存记录。</p><p>这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用<code>事务</code>包裹起来，确保这两个操作成为一个<code>原子操作</code>，要么全部执行，要么全部不执行。要是遇到特殊情况，可能还需要对数据进行手动维护，这样就很<code>容易忘记其中的一步</code>，导致数据缺失。</p><p>这个时候，咱们可以使用触发器。 <strong>你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数据的插入操作。</strong> 这样一来，就不用担心因为忘记添加库存数据而导致的数据缺失了。</p><hr><h2 id="1-触发器概述"><a href="#1-触发器概述" class="headerlink" title="1. 触发器概述"></a>1. 触发器概述</h2><hr><p>MySQL从<code>5.0.2</code>版本开始支持触发器。MySQL的触发器和存储过程一样，都是嵌入到MySQL服务器的一段程序。</p><p>触发器是由<code>事件来触发</code>某个操作，这些事件包括<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会<code>自动</code>激发触发器执行相应的操作。</p><p>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p><hr><h2 id="2-触发器的创建"><a href="#2-触发器的创建" class="headerlink" title="2. 触发器的创建"></a>2. 触发器的创建</h2><hr><h3 id="2-1-创建触发器语法"><a href="#2-1-创建触发器语法" class="headerlink" title="2. 1 创建触发器语法"></a>2. 1 创建触发器语法</h3><p>创建触发器的语法结构是：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TRIGGER 触发器名称&#123;BEFORE|AFTER&#125; &#123;INSERT|UPDATE|DELETE&#125; ON 表名FOR EACH ROW触发器执行的语句块;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li><p><code>表名</code>：表示触发器监控的对象。</p></li><li><p><code>BEFORE|AFTER</code>：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。</p></li><li><p>&#96;&#96;&#96;<br>INSERT|UPDATE|DELETE</p><pre class="line-numbers language-none"><code class="language-none">  ：表示触发的事件。  - INSERT 表示插入记录时触发；  - UPDATE 表示更新记录时触发；  - DELETE 表示删除记录时触发。- &#96;触发器执行的语句块&#96;：可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块。### 2. 2 代码举例**举例 1 ：**1. 创建数据表：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> CREATE TABLE test_trigger (<br> id INT PRIMARY KEY AUTO_INCREMENT,<br> t_note VARCHAR( 30 )<br> );</p><p> CREATE TABLE test_trigger_log (<br> id INT PRIMARY KEY AUTO_INCREMENT,<br> t_log VARCHAR( 30 )<br> );</p> <pre class="line-numbers language-none"><code class="language-none">2. 创建触发器：创建名称为before_insert的触发器，向test_trigger数据表插入数据之前，向test_trigger_log数据表中插入before_insert的日志信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> DELIMITER &#x2F;&#x2F;</p><p> CREATE TRIGGER before_insert<br> BEFORE INSERT ON test_trigger<br> FOR EACH ROW<br> BEGIN<br> INSERT INTO test_trigger_log (t_log)<br> VALUES(‘before_insert’);<br> END &#x2F;&#x2F;</p><p> DELIMITER ;</p> <pre class="line-numbers language-none"><code class="language-none">3. 向test_trigger数据表中插入数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> INSERT INTO test_trigger (t_note) VALUES (‘测试 BEFORE INSERT 触发器’);</p> <pre class="line-numbers language-none"><code class="language-none">4. 查看test_trigger_log数据表中的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> mysql&gt; SELECT * FROM test_trigger_log;<br> +—-+—————+<br> | id | t_log |<br> +—-+—————+<br> | 1 | before_insert |<br> +—-+—————+<br> 1 row in set (0.00 sec)</p> <pre class="line-numbers language-none"><code class="language-none">**举例 2 ：**1. 创建名称为after_insert的触发器，向test_trigger数据表插入数据之后，向test_trigger_log数据表中插入after_insert的日志信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> DELIMITER &#x2F;&#x2F;</p><p> CREATE TRIGGER after_insert<br> AFTER INSERT ON test_trigger<br> FOR EACH ROW<br> BEGIN<br> INSERT INTO test_trigger_log (t_log)<br> VALUES(‘after_insert’);<br> END &#x2F;&#x2F;</p><p> DELIMITER ;</p> <pre class="line-numbers language-none"><code class="language-none">2. 向test_trigger数据表中插入数据。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> INSERT INTO test_trigger (t_note) VALUES (‘测试 AFTER INSERT 触发器’);</p> <pre class="line-numbers language-none"><code class="language-none">3. 查看test_trigger_log数据表中的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> mysql&gt; SELECT * FROM test_trigger_log;<br> +—-+—————+<br> | id | t_log |<br> +—-+—————+<br> | 1 | before_insert |<br> | 2 | before_insert |<br> | 3 | after_insert |<br> +—-+—————+<br> 3 rows in set (0.00 sec)</p> <pre class="line-numbers language-none"><code class="language-none">**举例 3 ：** 定义触发器“salary_check_trigger”，基于员工表“employees”的INSERT事件，在INSERT之前检查将要添加的新员工薪资是否大于他领导的薪资，如果大于领导薪资，则报sqlstate_value为’HY000’的错误，从而使得添加失败。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>DELIMITER &#x2F;&#x2F;</p><p>CREATE TRIGGER salary_check_trigger<br>BEFORE INSERT ON employees FOR EACH ROW<br>BEGIN<br>    DECLARE mgrsalary DOUBLE;<br>    SELECT salary INTO mgrsalary FROM employees WHERE employee_id &#x3D; NEW.manager_id;</p><pre><code>IF NEW.salary &gt; mgrsalary THEN    SIGNAL SQLSTATE &#39;HY000&#39; SET MESSAGE_TEXT = &#39;薪资高于领导薪资错误&#39;;END IF;</code></pre><p>END &#x2F;&#x2F;</p><p>DELIMITER ;</p><pre class="line-numbers language-none"><code class="language-none">上面触发器声明过程中的NEW关键字代表INSERT添加语句的新记录。------## 3. 查看、删除触发器------### 3. 1 查看触发器查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。方式 1 ：查看当前数据库的所有触发器的定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SHOW TRIGGERS\G</p><pre class="line-numbers language-none"><code class="language-none">方式 2 ：查看当前数据库中某个触发器的定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>SHOW CREATE TRIGGER 触发器名</p><pre class="line-numbers language-none"><code class="language-none">方式 3 ：从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>SELECT * FROM information_schema.TRIGGERS;</p><pre class="line-numbers language-none"><code class="language-none">### 3. 2 删除触发器触发器也是数据库对象，删除触发器也用DROP语句，语法格式如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>DROP TRIGGER IF EXISTS 触发器名称;</p><pre class="line-numbers language-none"><code class="language-none">------## 4. 触发器的优缺点------### 4. 1 优点**1. 触发器可以确保数据的完整性 。**假设我们用&#96;进货单头表&#96;（demo.importhead）来保存进货单的总体信息，包括进货单编号、供货商编号、仓库编号、总计进货数量、总计进货金额和验收日期。![1650770696541](..&#x2F;pic&#x2F;第17章_触发器&#x2F;1650770696541.png)用&#96;进货单明细表&#96;（demo.importdetails）来保存进货商品的明细，包括进货单编号、商品编号、进货数量、进货价格和进货金额。![1650770713937](..&#x2F;pic&#x2F;第17章_触发器&#x2F;1650770713937.png)每当我们录入、删除和修改一条进货单明细数据的时候，进货单明细表里的数据就会发生变动。这个时候，在进货单头表中的总计数量和总计金额就必须重新计算，否则，进货单头表中的总计数量和总计金额就不等于进货单明细表中数量合计和金额合计了，这就是数据不一致。为了解决这个问题，我们就可以使用触发器， **规定每当进货单明细表有数据插入、修改和删除的操作时，自动触发 2 步操作：**1 ）重新计算进货单明细表中的数量合计和金额合计；2 ）用第一步中计算出来的值更新进货单头表中的合计数量与合计金额。这样一来，进货单头表中的合计数量与合计金额的值，就始终与进货单明细表中计算出来的合计数量与合计金额的值相同，数据就是一致的，不会互相矛盾。**2. 触发器可以帮助我们记录操作日志。**利用触发器，可以具体记录什么时间发生了什么。比如，记录修改会员储值金额的触发器，就是一个很好的例子。这对我们还原操作执行时的具体场景，更好地定位问题原因很有帮助。**3. 触发器还可以用在操作数据前，对数据进行合法性检查。**比如，超市进货的时候，需要库管录入进货价格。但是，人为操作很容易犯错误，比如说在录入数量的时候，把条形码扫进去了；录入金额的时候，看串了行，录入的价格远超售价，导致账面上的巨亏……这些都可以通过触发器，在实际插入或者更新操作之前，对相应的数据进行检查，及时提示错误，防止错误数据进入系统。### 4. 2 缺点**1. 触发器最大的一个问题就是可读性差。**因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能&#96;不受应用层的控制&#96;。这对系统维护是非常有挑战的。比如，创建触发器用于修改会员储值操作。如果触发器中的操作出了问题，会导致会员储值金额更新失败。我用下面的代码演示一下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mysql&gt; update demo.membermaster set memberdeposit&#x3D; 20 where memberid &#x3D; 2 ;<br>ERROR 1054 ( 42 S22): Unknown column ‘aa’ in ‘field list’</p><p>&#96;&#96;&#96;</p><p>结果显示，系统提示错误，字段“aa”不存在。</p><p>这是因为，触发器中的数据插入操作多了一个字段，系统提示错误。可是，如果你不了解这个触发器，很可能会认为是更新语句本身的问题，或者是会员信息表的结构出了问题。说不定你还会给会员信息表添加一个叫“aa”的字段，试图解决这个问题，结果只能是白费力。</p><p><strong>2. 相关数据的变更，可能会导致触发器出错。</strong></p><p>特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。</p><h3 id="4-3-注意点"><a href="#4-3-注意点" class="headerlink" title="4. 3 注意点"></a>4. 3 注意点</h3><p>注意，如果在子表中定义了外键约束，并且外键指定了ON UPDATE&#x2F;DELETE CASCADE&#x2F;SET NULL子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子表的UPDATE和DELETE语句定义的触发器并不会被激活。</p><p>例如：基于子表员工表（t_employee）的DELETE语句定义了触发器t1，而子表的部门编号（did）字段定义了外键约束引用了父表部门表（t_department）的主键列部门编号（did），并且该外键加了“ON DELETE SET NULL”子句，那么如果此时删除父表部门表（t_department）在子表员工表（t_employee）有匹配记录的部门记录时，会引起子表员工表（t_employee）匹配记录的部门编号（did）修改为NULL，但是此时不会激活触发器t1。只有直接对子表员工表（t_employee）执行DELETE语句时才会激活触发器t1。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的数据目录</title>
      <link href="/2022/07/17/gao-ji-pian-di-02-zhang-mysql-de-shu-ju-mu-lu/"/>
      <url>/2022/07/17/gao-ji-pian-di-02-zhang-mysql-de-shu-ju-mu-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="高级篇-第02章-MySQL的数据目录"><a href="#高级篇-第02章-MySQL的数据目录" class="headerlink" title="高级篇-第02章-MySQL的数据目录"></a>高级篇-第02章-MySQL的数据目录</h1><h2 id="1-MySQL8的主要目录结构"><a href="#1-MySQL8的主要目录结构" class="headerlink" title="1. MySQL8的主要目录结构"></a><strong>1. MySQL8的主要目录结构</strong></h2><hr><pre class="line-numbers language-none"><code class="language-none">find &#x2F; -name mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-1-数据库文件的存放路径"><a href="#1-1-数据库文件的存放路径" class="headerlink" title="1.1 数据库文件的存放路径"></a><strong>1.1</strong> <strong>数据库文件的存放路径</strong></h3><pre class="line-numbers language-none"><code class="language-none">show variables like &#39;datadir&#39;; # &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-相关命令目录"><a href="#1-2-相关命令目录" class="headerlink" title="1.2 相关命令目录"></a><strong>1.2</strong> <strong>相关命令目录</strong></h3><p><strong>相关命令目录：&#x2F;usr&#x2F;bin 和&#x2F;usr&#x2F;sbin。</strong></p><h3 id="1-3-配置文件目录"><a href="#1-3-配置文件目录" class="headerlink" title="1.3 配置文件目录"></a><strong>1.3</strong> <strong>配置文件目录</strong></h3><p><strong>配置文件目录：&#x2F;usr&#x2F;share&#x2F;mysql-8.0（命令及配置文件），&#x2F;etc&#x2F;mysql（如my.cnf）</strong></p><hr><h2 id="2-数据库和文件系统的关系"><a href="#2-数据库和文件系统的关系" class="headerlink" title="2. 数据库和文件系统的关系"></a>2. 数据库和文件系统的关系</h2><hr><h3 id="2-1-表在文件系统中的表示"><a href="#2-1-表在文件系统中的表示" class="headerlink" title="2.1 表在文件系统中的表示"></a><strong>2.1</strong> <strong>表在文件系统中的表示</strong></h3><h4 id="2-3-1-InnoDB存储引擎模式"><a href="#2-3-1-InnoDB存储引擎模式" class="headerlink" title="2.3.1 InnoDB存储引擎模式"></a><strong>2.3.1 InnoDB存储引擎模式</strong></h4><p><strong>1.</strong> <strong>表结构</strong></p><p>为了保存表结构，<code>InnoDB</code>在<code>数据目录</code>下对应的数据库子目录下创建了一个专门用于<code>描述表结构的文件</code></p><pre class="line-numbers language-none"><code class="language-none">表名.frm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2.</strong> <strong>表中数据和索引</strong></p><p><strong>① 系统表空间（system tablespace）</strong></p><p>默认情况下，InnoDB会在数据目录下创建一个名为<code>ibdata1</code>、大小为<code>12M</code>的<code>自拓展</code>文件，这个文件就是对应的<code>系统表空间</code>在文件系统上的表示。</p><p><strong>② 独立表空间(file-per-table tablespace)</strong></p><p>在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为<code>每一个表建立一个独立表空间</code>，也就是说我们创建了多少个表，就有多少个独立表空间。使用<code>独立表空间</code>来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同。</p><pre class="line-numbers language-none"><code class="language-none">表名.ibd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>MySQL8.0中不再单独提供<code>表名.frm</code>，而是合并在<code>表名.ibd</code>文件中。</p></blockquote><p><strong>③ 系统表空间与独立表空间的设置</strong></p><p>我们可以自己指定使用<code>系统表空间</code>还是<code>独立表空间</code>来存储数据，这个功能由启动参数<code>innodb_file_per_table</code>控制</p><pre class="line-numbers language-none"><code class="language-none">[server] innodb_file_per_table&#x3D;0 # 0：代表使用系统表空间； 1：代表使用独立表空间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>④ 其他类型的表空间</strong></p><p>随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。</p><h4 id="2-3-2-MyISAM存储引擎模式"><a href="#2-3-2-MyISAM存储引擎模式" class="headerlink" title="2.3.2 MyISAM存储引擎模式"></a><strong>2.3.2 MyISAM存储引擎模式</strong></h4><p><strong>1.</strong> <strong>表结构</strong></p><p>在存储表结构方面， MyISAM 和 InnoDB 一样，也是在<code>数据目录</code>下对应的数据库子目录下创建了一个专门用于描述表结构的文件</p><pre class="line-numbers language-none"><code class="language-none">表名.frm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2.</strong> <strong>表中数据和索引</strong></p><p>在MyISAM中的索引全部都是<code>二级索引</code>，该存储引擎的<code>数据和索引是分开存放</code>的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。</p><pre class="line-numbers language-none"><code class="language-none">test.frm 存储表结构 #MySQL8.0 改为了 b.xxx.sditest.MYD 存储数据 (MYData) test.MYI 存储索引 (MYIndex<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL8其他新特性</title>
      <link href="/2022/07/17/di-18-zhang-mysql8-qi-ta-xin-te-xing/"/>
      <url>/2022/07/17/di-18-zhang-mysql8-qi-ta-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="第18章-MySQL8其他新特性"><a href="#第18章-MySQL8其他新特性" class="headerlink" title="第18章_MySQL8其他新特性"></a>第18章_MySQL8其他新特性</h1><h2 id="1-MySQL-8-新特性概述"><a href="#1-MySQL-8-新特性概述" class="headerlink" title="1. MySQL 8 新特性概述"></a>1. MySQL 8 新特性概述</h2><hr><p><code>MySQL从5.7版本直接跳跃发布了8.0版本</code>，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。</p><h3 id="1-1-MySQL-8-0-新增特性"><a href="#1-1-MySQL-8-0-新增特性" class="headerlink" title="1. 1 MySQL 8. 0 新增特性"></a>1. 1 MySQL 8. 0 新增特性</h3><ol><li><p><strong>更简便的NoSQL支持</strong> NoSQL泛指非关系型数据库和数据存储。随着互联网平台的规模飞速发展，传统的关系型数据库已经越来越不能满足需求。从5.6版本开始，MySQL就开始支持简单的NoSQL存储功能。MySQL 8对这一功能做了优化，以更灵活的方式实现NoSQL功能，不再依赖模式（schema）。</p></li><li><p><strong>更好的索引</strong> 在查询中，正确地使用索引可以提高查询的效率。MySQL 8中新增了<code>隐藏索引</code>和<code>降序索引</code>。隐藏索引可以用来测试去掉索引对查询性能的影响。在查询中混合存在多列索引时，使用降序索引可以提高查询的性能。</p></li><li><p><strong>更完善的JSON支持</strong> MySQL从5.7开始支持原生JSON数据的存储，MySQL 8对这一功能做了优化，增加了聚合函数<code>JSON_ARRAYAGG()</code>和<code>JSON_OBJECTAGG()</code>，将参数聚合为JSON数组或对象，新增了行内操作符 -&gt;&gt;，是列路径运算符 -&gt;的增强，对JSON排序做了提升，并优化了JSON的更新操作。</p></li><li><p><strong>安全和账户管理</strong> MySQL 8中新增了<code>caching_sha2_password</code> 授权插件、角色、密码历史记录和FIPS模式支持，这些特性提高了数据库的安全性和性能，使数据库管理员能够更灵活地进行账户管理工作。</p></li><li><p><strong>InnoDB的变化</strong> <code>InnoDB是MySQL默认的存储引擎</code>，是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。在MySQL 8 版本中，InnoDB在自增、索引、加密、死锁、共享锁等方面做了大量的<code>改进和优化</code>，并且支持原子数据定义语言（DDL），提高了数据安全性，对事务提供更好的支持。</p></li><li><p><strong>数据字典</strong> 在之前的MySQL版本中，字典数据都存储在元数据文件和非事务表中。从MySQL 8开始新增了事务数据字典，在这个字典里存储着数据库对象信息，这些数据字典存储在内部事务表中。</p></li><li><p><strong>原子数据定义语句</strong> MySQL 8开始支持原子数据定义语句（Automic DDL），即<code>原子DDL</code>。目前，只有InnoDB存储引擎支持原子DDL。原子数据定义语句（DDL）将与DDL操作相关的数据字典更新、存储引擎操作、二进制日志写入结合到一个单独的原子事务中，这使得即使服务器崩溃，事务也会提交或回滚。使用支持原子操作的存储引擎所创建的表，在执行DROP TABLE、CREATE TABLE、ALTER TABLE、RENAME TABLE、TRUNCATE TABLE、CREATE TABLESPACE、DROP TABLESPACE等操作时，都支持原子操作，即事务要么完全操作成功，要么失败后回滚，不再进行部分提交。 对于从MySQL 5.7复制到MySQL 8版本中的语句，可以添加<code>IF EXISTS</code>或<code>IF NOT EXISTS</code>语句来避免发生错误。</p></li><li><p><strong>资源管理</strong> MySQL 8开始支持创建和管理资源组，允许将服务器内运行的线程分配给特定的分组，以便线程根据组内可用资源执行。组属性能够控制组内资源，启用或限制组内资源消耗。数据库管理员能够根据不同的工作负载适当地更改这些属性。 目前，CPU时间是可控资源，由“虚拟CPU”这个概念来表示，此术语包含CPU的核心数，超线程，硬件线程等等。服务器在启动时确定可用的虚拟CPU数量。拥有对应权限的数据库管理员可以将这些CPU与资源组关联，并为资源组分配线程。 资源组组件为MySQL中的资源组管理提供了SQL接口。资源组的属性用于定义资源组。MySQL中存在两个默认组，系统组和用户组，默认的组不能被删除，其属性也不能被更改。对于用户自定义的组，资源组创建时可初始化所有的属性，除去名字和类型，其他属性都可在创建之后进行更改。 在一些平台下，或进行了某些MySQL的配置时，资源管理的功能将受到限制，甚至不可用。例如，如果安装了线程池插件，或者使用的是macOS系统，资源管理将处于不可用状态。在FreeBSD和Solaris系统中，资源线程优先级将失效。在Linux系统中，只有配置了CAP_SYS_NICE属性，资源管理优先级才能发挥作用。</p></li><li><p><strong>字符集支持</strong> MySQL 8中默认的字符集由<code>latin1</code>更改为<code>utf8mb4</code>，并首次增加了日语所特定使用的集合，utf8mb4_ja_0900_as_cs。</p></li><li><p><strong>优化器增强</strong> MySQL优化器开始支持隐藏索引和降序索引。隐藏索引不会被优化器使用，验证索引的必要性时不需要删除索引，先将索引隐藏，如果优化器性能无影响就可以真正地删除索引。降序索引允许优化器对多个列进行排序，并且允许排序顺序不一致。</p></li><li><p><strong>公用表表达式</strong> 公用表表达式（Common Table Expressions）简称为CTE，MySQL现在支持递归和非递归两种形式的CTE。CTE通过在SELECT语句或其他特定语句前<code>使用WITH语句对临时结果集</code>进行命名。<br>基础语法如下：</p><pre class="line-numbers language-none"><code class="language-none">WITH cte_name (col_name1,col_name2 ...) AS (Subquery)SELECT * FROM cte_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Subquery代表子查询，子查询前使用WITH语句将结果集命名为cte_name，在后续的查询中即可使用cte_name进行查询。</p></li><li><p><strong>窗口函数</strong> MySQL 8开始支持窗口函数。在之前的版本中已存在的大部分<code>聚合函数</code>在MySQL 8中也可以作为窗口函数来使用。<br><img src="C:/Users/86188/pic/test/1650771871461.png" alt="1650771871461"></p></li><li><p><strong>正则表达式支持</strong> MySQL在8.0.4以后的版本中采用支持Unicode的国际化组件库实现正则表达式操作，这种方式不仅能提供完全的Unicode支持，而且是多字节安全编码。MySQL增加了REGEXP_LIKE()、EGEXP_INSTR()、REGEXP_REPLACE()和 REGEXP_SUBSTR()等函数来提升性能。另外，regexp_stack_limit和regexp_time_limit 系统变量能够通过匹配引擎来控制资源消耗。</p></li><li><p><strong>内部临时表</strong> <code>TempTable存储引擎取代MEMORY存储引擎成为内部临时表的默认存储引擎</code>。TempTable存储引擎为VARCHAR和VARBINARY列提供高效存储。internal_tmp_mem_storage_engine会话变量定义了内部临时表的存储引擎，可选的值有两个，TempTable和MEMORY，其中TempTable为默认的存储引擎。temptable_max_ram系统配置项定义了TempTable存储引擎可使用的最大内存数量。</p></li><li><p><strong>日志记录</strong> 在MySQL 8中错误日志子系统由一系列MySQL组件构成。这些组件的构成由系统变量log_error_services来配置，能够实现日志事件的过滤和写入。</p></li><li><p><strong>备份锁</strong> 新的备份锁允许在线备份期间执行数据操作语句，同时阻止可能造成快照不一致的操作。新备份锁由 LOCK INSTANCE FOR BACKUP 和 UNLOCK INSTANCE 语法提供支持，执行这些操作需要备份管理员特权。</p></li><li><p><strong>增强的MySQL复制</strong> MySQL 8复制支持对<code>JSON文档</code>进行部分更新的<code>二进制日志记录</code>，该记录<code>使用紧凑的二进制格式</code>，从而节省记录完整JSON文档的空间。当使用基于语句的日志记录时，这种紧凑的日志记录会自动完成，并且可以通过将新的binlog_row_value_options系统变量值设置为PARTIAL_JSON来启用。</p></li></ol><h3 id="1-2-MySQL-8-0-移除的旧特性"><a href="#1-2-MySQL-8-0-移除的旧特性" class="headerlink" title="1. 2 MySQL 8. 0 移除的旧特性"></a>1. 2 MySQL 8. 0 移除的旧特性</h3><p>在MySQL 5.7版本上开发的应用程序如果使用了MySQL8.0 移除的特性，语句可能会失败，或者产生不同的执行结果。为了避免这些问题，对于使用了移除特性的应用，应当尽力修正避免使用这些特性，并尽可能使用替代方法。</p><ol><li><strong>查询缓存</strong> <code>查询缓存已被移除</code>，删除的项有：<br>( 1 ) 语句： FLUSH QUERY CACHE和RESET QUERY CACHE。<br>( 2 ) 系统变量： query_cache_limit、query_cache_min_res_unit、query_cache_size、query_cache_type、query_cache_wlock_invalidate。<br>( 3 ) 状态变量： Qcache_free_blocks、Qcache_free_memory、Qcache_hits、Qcache_inserts、Qcache_lowmem_prunes、Qcache_not_cached、Qcache_queries_in_cache、Qcache_total_blocks。<br>( 4 ) 线程状态： checking privileges on cached query、checking query cache for query、invalidating query cache entries、sending cached result to client、storing result in query cache、waiting for query cache lock。</li><li><strong>加密相关</strong> 删除的加密相关的内容有：ENCODE()、DECODE()、ENCRYPT()、DES_ENCRYPT()和DES_DECRYPT()函数，配置项des-key-file，系统变量have_crypt，FLUSH语句的DES_KEY_FILE选项，HAVE_CRYPT CMake选项。 对于移除的ENCRYPT()函数，考虑使用SHA2()替代，对于其他移除的函数，使用AES_ENCRYPT()和AES_DECRYPT()替代。</li><li><strong>空间函数相关</strong> 在MySQL 5.7版本中，多个空间函数已被标记为过时。这些过时函数在MySQL 8中都已被移除，只保留了对应的ST_和MBR函数。</li><li><strong>\N和NULL</strong> 在SQL语句中，解析器不再将\N视为NULL，所以在SQL语句中应使用NULL代替\N。这项变化不会影响使用LOAD DATA INFILE或者SELECT…INTO OUTFILE操作文件的导入和导出。在这类操作中，NULL仍等同于\N。</li><li><strong>mysql_install_db</strong> 在MySQL分布中，已移除了mysql_install_db程序，数据字典初始化需要调用带着–initialize或者–initialize-insecure选项的mysqld来代替实现。另外，–bootstrap和INSTALL_SCRIPTDIR CMake也已被删除。</li><li><strong>通用分区处理程序</strong> 通用分区处理程序已从MySQL服务中被移除。为了实现给定表分区，表所使用的存储引擎需要自有的分区处理程序。 提供本地分区支持的MySQL存储引擎有两个，即InnoDB和NDB，而在MySQL 8中只支持InnoDB。</li><li><strong>系统和状态变量信息</strong> 在INFORMATION_SCHEMA数据库中，对系统和状态变量信息不再进行维护。GLOBAL_VARIABLES、SESSION_VARIABLES、GLOBAL_STATUS、SESSION_STATUS表都已被删除。另外，系统变量show_compatibility_56也已被删除。被删除的状态变量有Slave_heartbeat_period、Slave_last_heartbeat,Slave_received_heartbeats、Slave_retried_transactions、Slave_running。以上被删除的内容都可使用性能模式中对应的内容进行替代。</li><li><strong>mysql_plugin工具</strong> mysql_plugin工具用来配置MySQL服务器插件，现已被删除，可使用–plugin-load或–plugin-load-add选项在服务器启动时加载插件或者在运行时使用INSTALL PLUGIN语句加载插件来替代该工具。</li></ol><hr><h2 id="2-新特性-1-：窗口函数"><a href="#2-新特性-1-：窗口函数" class="headerlink" title="2. 新特性 1 ：窗口函数"></a>2. 新特性 1 ：窗口函数</h2><hr><h3 id="2-1-使用窗口函数前后对比"><a href="#2-1-使用窗口函数前后对比" class="headerlink" title="2. 1 使用窗口函数前后对比"></a>2. 1 使用窗口函数前后对比</h3><p>假设我现在有这样一个数据表，它显示了某购物网站在每个城市每个区的销售额：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE sales(    id INT PRIMARY KEY AUTO_INCREMENT,    city VARCHAR( 15 ),    county VARCHAR( 15 ),    sales_value DECIMAL);INSERT INTO sales(city,county,sales_value)VALUES(&#39;北京&#39;,&#39;海淀&#39;,10.00),(&#39;北京&#39;,&#39;朝阳&#39;,20.00),(&#39;上海&#39;,&#39;黄埔&#39;,30.00),(&#39;上海&#39;,&#39;长宁&#39;,10.00);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查询：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM sales;+----+------+--------+-------------+| id | city | county | sales_value |+----+------+--------+-------------+| 1 | 北京 | 海淀 | 10 || 2 | 北京 | 朝阳 | 20 || 3 | 上海 | 黄埔 | 30 || 4 | 上海 | 长宁 | 10 |+----+------+--------+-------------+4 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>需求：</strong> 现在计算这个网站在每个城市的销售总额、在全国的销售总额、每个区的销售额占所在城市销售额中的比率，以及占总销售额中的比率。</p><p>如果用分组和聚合函数，就需要分好几步来计算。</p><p>第一步，计算总销售金额，并存入临时表 a：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TEMPORARY TABLE a -- 创建临时表SELECT SUM(sales_value) AS sales_value -- 计算总计金额FROM sales;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看一下临时表 a ：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM a;+-------------+| sales_value |+-------------+| 70 |+-------------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二步，计算每个城市的销售总额并存入临时表 b：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TEMPORARY TABLE b  -- 创建临时表SELECT city,SUM(sales_value) AS sales_value  -- 计算城市销售合计FROM salesGROUP BY city;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>查看临时表 b ：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM b;+------+-------------+| city | sales_value |+------+-------------+| 北京 | 30 || 上海 | 40 |+------+-------------+2 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第三步，计算各区的销售占所在城市的总计金额的比例，和占全部销售总计金额的比例。我们可以通过下面的连接查询获得需要的结果：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT s.city AS 城市,s.county AS 区,s.sales_value AS 区销售额,    -&gt; b.sales_value AS 市销售额,s.sales_value&#x2F;b.sales_value AS 市比率,    -&gt; a.sales_value AS 总销售额,s.sales_value&#x2F;a.sales_value AS 总比率    -&gt; FROM sales s    -&gt; JOIN b ON (s.city&#x3D;b.city) -- 连接市统计结果临时表    -&gt; JOIN a -- 连接总计金额临时表    -&gt; ORDER BY s.city,s.county;+------+------+----------+----------+--------+----------+--------+| 城市 | 区 | 区销售额 | 市销售额 | 市比率 | 总销售额 | 总比率 |+------+------+----------+----------+--------+----------+--------+| 上海 | 长宁 | 10 | 40 | 0.2500 | 70 | 0.1429 || 上海 | 黄埔 | 30 | 40 | 0.7500 | 70 | 0.4286 || 北京 | 朝阳 | 20 | 30 | 0.6667 | 70 | 0.2857 || 北京 | 海淀 | 10 | 30 | 0.3333 | 70 | 0.1429 |+------+------+----------+----------+--------+----------+--------+4 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果显示：市销售金额、市销售占比、总销售金额、总销售占比都计算出来了。</p><p>同样的查询，如果用窗口函数，就简单多了。我们可以用下面的代码来实现：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT city AS 城市,county AS 区,sales_value AS 区销售额,    -&gt; SUM(sales_value) OVER(PARTITION BY city) AS 市销售额,  -- 计算市销售额    -&gt; sales_value&#x2F;SUM(sales_value) OVER(PARTITION BY city) AS 市比率,    -&gt; SUM(sales_value) OVER() AS 总销售额, -- 计算总销售额    -&gt; sales_value&#x2F;SUM(sales_value) OVER() AS 总比率    -&gt; FROM sales    -&gt; ORDER BY city,county;+------+------+----------+----------+--------+----------+--------+| 城市 | 区 | 区销售额 | 市销售额 | 市比率 | 总销售额 | 总比率 |+------+------+----------+----------+--------+----------+--------+| 上海 | 长宁 | 10 | 40 | 0.2500 | 70 | 0.1429 || 上海 | 黄埔 | 30 | 40 | 0.7500 | 70 | 0.4286 || 北京 | 朝阳 | 20 | 30 | 0.6667 | 70 | 0.2857 || 北京 | 海淀 | 10 | 30 | 0.3333 | 70 | 0.1429 |+------+------+----------+-----------+--------+----------+--------+4 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果显示，我们得到了与上面那种查询同样的结果。</p><p>使用窗口函数，只用了一步就完成了查询。而且，由于没有用到临时表，执行的效率也更高了。很显然， <strong>在这种需要用到分组统计的结果对每一条记录进行计算的场景下，使用窗口函数更好</strong> 。</p><h3 id="2-2-窗口函数分类"><a href="#2-2-窗口函数分类" class="headerlink" title="2. 2 窗口函数分类"></a>2. 2 窗口函数分类</h3><p>MySQL从 8. 0 版本开始支持窗口函数。窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。</p><p>窗口函数可以分为<code>静态窗口函数</code>和<code>动态窗口函数</code>。</p><ul><li>静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同；</li><li>动态窗口函数的窗口大小会随着记录的不同而变化。</li></ul><p>MySQL官方网站窗口函数的网址为 <a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_row-number">https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_row-number</a> 。</p><p>窗口函数总体上可以分为序号函数、分布函数、前后函数、首尾函数和其他函数，如下表：</p><p><img src="C:/Users/86188/pic/test/1650772535712.png" alt="1650772535712"></p><h3 id="2-3-语法结构"><a href="#2-3-语法结构" class="headerlink" title="2. 3 语法结构"></a>2. 3 语法结构</h3><p>窗口函数的语法结构是：</p><pre class="line-numbers language-none"><code class="language-none">函数 OVER（[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者是：</p><pre class="line-numbers language-none"><code class="language-none">函数 OVER 窗口名 ... WINDOW 窗口名 AS （[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>OVER 关键字指定函数窗口的范围。<ul><li>如果省略后面括号中的内容，则窗口会包含满足WHERE条件的所有记录，窗口函数会基于所有满足WHERE条件的记录进行计算。</li><li>如果OVER关键字后面的括号不为空，则可以使用如下语法设置窗口。</li></ul></li><li>窗口名：为窗口设置一个别名，用来标识窗口。</li><li>PARTITION BY子句：指定窗口函数按照哪些字段进行分组。分组后，窗口函数可以在每个分组中分别执行。</li><li>ORDER BY子句：指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号。</li><li>FRAME子句：为分区中的某个子集定义规则，可以用来作为滑动窗口使用。</li></ul><h3 id="2-4-分类讲解"><a href="#2-4-分类讲解" class="headerlink" title="2. 4 分类讲解"></a>2. 4 分类讲解</h3><p>创建表：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE goods(    id INT PRIMARY KEY AUTO_INCREMENT,    category_id INT,    category VARCHAR( 15 ),    NAME VARCHAR( 30 ),    price DECIMAL( 10 , 2 ),    stock INT,    upper_time DATETIME);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加数据：</p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO goods(category_id,category,NAME,price,stock,upper_time)VALUES( 1 , &#39;女装&#x2F;女士精品&#39;, &#39;T恤&#39;, 39.90, 1000 , &#39;2020-11-10 00:00:00&#39;),( 1 , &#39;女装&#x2F;女士精品&#39;, &#39;连衣裙&#39;, 79.90, 2500 , &#39;2020-11-10 00:00:00&#39;),( 1 , &#39;女装&#x2F;女士精品&#39;, &#39;卫衣&#39;, 89.90, 1500 , &#39;2020-11-10 00:00:00&#39;),( 1 , &#39;女装&#x2F;女士精品&#39;, &#39;牛仔裤&#39;, 89.90, 3500 , &#39;2020-11-10 00:00:00&#39;),( 1 , &#39;女装&#x2F;女士精品&#39;, &#39;百褶裙&#39;, 29.90, 500 , &#39;2020-11-10 00:00:00&#39;),( 1 , &#39;女装&#x2F;女士精品&#39;, &#39;呢绒外套&#39;, 399.90, 1200 , &#39;2020-11-10 00:00:00&#39;),( 2 , &#39;户外运动&#39;, &#39;自行车&#39;, 399.90, 1000 , &#39;2020-11-10 00:00:00&#39;),( 2 , &#39;户外运动&#39;, &#39;山地自行车&#39;, 1399.90, 2500 , &#39;2020-11-10 00:00:00&#39;),( 2 , &#39;户外运动&#39;, &#39;登山杖&#39;, 59.90, 1500 , &#39;2020-11-10 00:00:00&#39;),( 2 , &#39;户外运动&#39;, &#39;骑行装备&#39;, 399.90, 3500 , &#39;2020-11-10 00:00:00&#39;),( 2 , &#39;户外运动&#39;, &#39;运动外套&#39;, 799.90, 500 , &#39;2020-11-10 00:00:00&#39;),( 2 , &#39;户外运动&#39;, &#39;滑板&#39;, 499.90, 1200 , &#39;2020-11-10 00:00:00&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面针对goods表中的数据来验证每个窗口函数的功能。</p><h4 id="2-4-1序号函数"><a href="#2-4-1序号函数" class="headerlink" title="2. 4. 1序号函数"></a>2. 4. 1序号函数</h4><ol><li><p><strong>ROW_NUMBER()函数</strong><br>ROW_NUMBER()函数能够对数据中的序号进行顺序显示。<br>举例：查询 goods 数据表中每个商品分类下价格降序排列的各个商品信息。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT ROW_NUMBER() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,    -&gt; id, category_id, category, NAME, price, stock    -&gt; FROM goods;+---------+----+-------------+-------------+------------+---------+-------+| row_num | id | category_id | category | NAME | price | stock |+---------+----+-------------+-------------+------------+---------+-------+| 1 | 6 | 1 | 女装&#x2F;女士精品 | 呢绒外套 |  399.90 | 1200 || 2 | 3 | 1 | 女装&#x2F;女士精品 | 卫衣 | 89.90 | 1500 || 3 | 4 | 1 | 女装&#x2F;女士精品 | 牛仔裤 | 89.90 | 3500 || 4 | 2 | 1 | 女装&#x2F;女士精品 | 连衣裙 | 79.90 | 2500 || 5 | 1 | 1 | 女装&#x2F;女士精品 | T恤 | 39.90 | 1000 || 6 | 5 | 1 | 女装&#x2F;女士精品 | 百褶裙 | 29.90 | 500 || 1 | 8 | 2 | 户外运动 | 山地自行车 | 1399.90 | 2500 || 2 | 11 | 2 | 户外运动 | 运动外套 |  799.90 | 500 || 3 | 12 | 2 | 户外运动 | 滑板 |  499.90 | 1200 || 4 | 7 | 2 | 户外运动 | 自行车 |  399.90 | 1000 || 5 | 10 | 2 | 户外运动 | 骑行装备 |  399.90 | 3500 || 6 | 9 | 2 | 户外运动 | 登山杖 | 59.90 | 1500 |+---------+----+-------------+-------------+------------+---------+-------+12 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：查询 goods 数据表中每个商品分类下价格最高的 3 种商品信息。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT *    -&gt; FROM (    -&gt;  SELECT ROW_NUMBER() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,    -&gt; id, category_id, category, NAME, price, stock    -&gt;  FROM goods) t    -&gt; WHERE row_num &lt;&#x3D; 3 ;+---------+----+-------------+-------------+------------+---------+-------+| row_num | id | category_id | category | NAME | price | stock |+---------+----+-------------+-------------+------------+---------+-------+| 1 | 6 | 1 | 女装&#x2F;女士精品 | 呢绒外套 |  399.90 | 1200 || 2 | 3 | 1 | 女装&#x2F;女士精品 | 卫衣 | 89.90 | 1500 || 3 | 4 | 1 | 女装&#x2F;女士精品 | 牛仔裤 | 89.90 | 3500 || 1 | 8 | 2 | 户外运动 | 山地自行车 | 1399.90 | 2500 || 2 | 11 | 2 | 户外运动 | 运动外套 |  799.90 | 500 || 3 | 12 | 2 | 户外运动 | 滑板 |  499.90 | 1200 |+---------+----+-------------+------------+------------+----------+-------+6 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在名称为“女装&#x2F;女士精品”的商品类别中，有两款商品的价格为 89. 90 元，分别是卫衣和牛仔裤。两款商品的序号都应该为 2 ，而不是一个为 2 ，另一个为 3 。此时，可以使用RANK()函数和DENSE_RANK()函数解决。</p></li><li><p><strong>RANK()函数</strong><br>使用RANK()函数能够对序号进行并列排序，并且会跳过重复的序号，比如序号为 1 、 1 、 3 。举例：使用RANK()函数获取 goods 数据表中各类别的价格从高到低排序的各商品信息。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,    -&gt; id, category_id, category, NAME, price, stock    -&gt; FROM goods;+---------+----+-------------+---------------+------------+---------+-------+| row_num | id | category_id | category | NAME | price | stock |+---------+----+-------------+---------------+------------+---------+-------+| 1 | 6 | 1 | 女装&#x2F;女士精品 | 呢绒外套 | 399.90 | 1200 || 2 | 3 | 1 | 女装&#x2F;女士精品 | 卫衣 | 89.90 | 1500 || 2 | 4 | 1 | 女装&#x2F;女士精品 | 牛仔裤 | 89.90 | 3500 || 4 | 2 | 1 | 女装&#x2F;女士精品 | 连衣裙 | 79.90 | 2500 || 5 | 1 | 1 | 女装&#x2F;女士精品 | T恤 | 39.90 | 1000 || 6 | 5 | 1 | 女装&#x2F;女士精品 | 百褶裙 | 29.90 | 500 || 1 | 8 | 2 | 户外运动 | 山地自行车 | 1399.90 | 2500 || 2 | 11 | 2 | 户外运动 | 运动外套 | 799.90 | 500 || 3 | 12 | 2 | 户外运动 | 滑板 | 499.90 | 1200 || 4 | 7 | 2 | 户外运动 | 自行车 | 399.90 | 1000 || 4 | 10 | 2 | 户外运动 | 骑行装备 | 399.90 | 3500 || 6 | 9 | 2 | 户外运动 | 登山杖 | 59.90 | 1500 |+---------+----+-------------+---------------+------------+---------+-------+12 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：使用RANK()函数获取 goods 数据表中类别为“女装&#x2F;女士精品”的价格最高的 4 款商品信息。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT *    -&gt; FROM(    -&gt;  SELECT RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,    -&gt; id, category_id, category, NAME, price, stock    -&gt;  FROM goods) t    -&gt; WHERE category_id &#x3D; 1 AND row_num &lt;&#x3D; 4 ;+---------+----+-------------+---------------+----------+--------+-------+| row_num | id | category_id | category | NAME | price | stock |+---------+----+-------------+---------------+----------+--------+-------+| 1 | 6 | 1 | 女装&#x2F;女士精品 | 呢绒外套 | 399.90 | 1200 || 2 | 3 | 1 | 女装&#x2F;女士精品 | 卫衣 |  89.90 | 1500 || 2 | 4 | 1 | 女装&#x2F;女士精品 | 牛仔裤 |  89.90 | 3500 || 4 | 2 | 1 | 女装&#x2F;女士精品 | 连衣裙 |  79.90 | 2500 |+---------+----+-------------+---------------+----------+--------+-------+4 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，使用RANK()函数得出的序号为 1 、 2 、 2 、 4 ，相同价格的商品序号相同，后面的商品序号是不连续的，跳过了重复的序号。</p></li><li><p><strong>DENSE_RANK()函数</strong><br>DENSE_RANK()函数对序号进行并列排序，并且不会跳过重复的序号，比如序号为1 、1 、2。举例：使用DENSE_RANK()函数获取 goods 数据表中各类别的价格从高到低排序的各商品信息。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT DENSE_RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,    -&gt; id, category_id, category, NAME, price, stock    -&gt; FROM goods;+---------+----+-------------+-------------+------------+---------+-------+| row_num | id | category_id | category | NAME | price | stock |+---------+----+-------------+-------------+------------+---------+-------+| 1 | 6 | 1 | 女装&#x2F;女士精品 | 呢绒外套 | 399.90 | 1200 || 2 | 3 | 1 | 女装&#x2F;女士精品 | 卫衣 | 89.90 | 1500 || 2 | 4 | 1 | 女装&#x2F;女士精品 | 牛仔裤 | 89.90 | 3500 || 3 | 2 | 1 | 女装&#x2F;女士精品 | 连衣裙 | 79.90 | 2500 || 4 | 1 | 1 | 女装&#x2F;女士精品 | T恤 | 39.90 | 1000 || 5 | 5 | 1 | 女装&#x2F;女士精品 | 百褶裙 | 29.90 | 500 || 1 | 8 | 2 | 户外运动 | 山地自行车 | 1399.90 | 2500 || 2 | 11 | 2 | 户外运动 | 运动外套 | 799.90 | 500 || 3 | 12 | 2 | 户外运动 | 滑板 | 499.90 | 1200 || 4 | 7 | 2 | 户外运动 | 自行车 | 399.90 | 1000 || 4 | 10 | 2 | 户外运动 | 骑行装备 | 399.90 | 3500 || 5 | 9 | 2 | 户外运动 | 登山杖 | 59.90 | 1500 |+---------+----+-------------+-------------+------------+---------+-------+12 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：使用DENSE_RANK()函数获取 goods 数据表中类别为“女装&#x2F;女士精品”的价格最高的 4 款商品信息。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT *    -&gt; FROM(    -&gt;  SELECT DENSE_RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,    -&gt; id, category_id, category, NAME, price, stock    -&gt;  FROM goods) t    -&gt; WHERE category_id &#x3D; 1 AND row_num &lt;&#x3D; 3 ;+---------+----+-------------+---------------+----------+--------+-------+| row_num | id | category_id | category | NAME | price | stock |+---------+----+-------------+---------------+----------+--------+-------+| 1 | 6 | 1 | 女装&#x2F;女士精品 | 呢绒外套 | 399.90 | 1200 || 2 | 3 | 1 | 女装&#x2F;女士精品 | 卫衣 |  89.90 | 1500 || 2 | 4 | 1 | 女装&#x2F;女士精品 | 牛仔裤 |  89.90 | 3500 || 3 | 2 | 1 | 女装&#x2F;女士精品 | 连衣裙 |  79.90 | 2500 |+---------+----+-------------+---------------+----------+--------+-------+4 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，使用DENSE_RANK()函数得出的行号为 1 、 2 、 2 、 3 ，相同价格的商品序号相同，后面的商品序号是连续的，并且没有跳过重复的序号。</p></li></ol><h4 id="2-4-2-分布函数"><a href="#2-4-2-分布函数" class="headerlink" title="2. 4. 2 分布函数"></a>2. 4. 2 分布函数</h4><ol><li><p><strong>PERCENT_RANK()函数</strong><br>PERCENT_RANK()函数是等级值百分比函数。按照如下方式进行计算。</p><pre class="line-numbers language-none"><code class="language-none">(rank - 1 ) &#x2F; (rows - 1 )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，rank的值为使用RANK()函数产生的序号，rows的值为当前窗口的总记录数。<br>举例：计算 goods 数据表中名称为“女装&#x2F;女士精品”的类别下的商品的PERCENT_RANK值。</p><pre class="line-numbers language-none"><code class="language-none">#写法一：SELECT RANK() OVER (PARTITION BY category_id ORDER BY price DESC) AS r,PERCENT_RANK() OVER (PARTITION BY category_id ORDER BY price DESC) AS pr,id, category_id, category, NAME, price, stockFROM goodsWHERE category_id &#x3D; 1 ;#写法二：mysql&gt; SELECT RANK() OVER w AS r,    -&gt; PERCENT_RANK() OVER w AS pr,    -&gt; id, category_id, category, NAME, price, stock    -&gt; FROM goods    -&gt; WHERE category_id &#x3D; 1 WINDOW w AS (PARTITION BY category_id ORDER BY price DESC);+---+-----+----+-------------+---------------+----------+--------+-------+| r | pr | id | category_id | category | NAME | price | stock |+---+-----+----+-------------+---------------+----------+--------+-------+| 1 | 0 | 6 | 1 | 女装&#x2F;女士精品 | 呢绒外套 | 399.90 | 1200 || 2 | 0.2 | 3 | 1 | 女装&#x2F;女士精品 | 卫衣 |  89.90 | 1500 || 2 | 0.2 | 4 | 1 | 女装&#x2F;女士精品 | 牛仔裤 |  89.90 | 3500 || 4 | 0.6 | 2 | 1 | 女装&#x2F;女士精品 | 连衣裙 |  79.90 | 2500 || 5 | 0.8 | 1 | 1 | 女装&#x2F;女士精品 | T恤 |  39.90 | 1000 || 6 | 1 | 5 | 1 | 女装&#x2F;女士精品 | 百褶裙 |  29.90 | 500 |+---+-----+----+-------------+---------------+----------+--------+-------+6 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>CUME_DIST()函数</strong><br>CUME_DIST()函数主要用于查询小于或等于某个值的比例。<br>举例：查询goods数据表中小于或等于当前价格的比例。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT CUME_DIST() OVER(PARTITION BY category_id ORDER BY price ASC) AS cd,    -&gt; id, category, NAME, price    -&gt; FROM goods;+---------------------+----+---------------+------------+---------+| cd | id | category | NAME | price |+---------------------+----+---------------+------------+---------+| 0.16666666666666666 | 5 | 女装&#x2F;女士精品 | 百褶裙 | 29.90 ||  0.3333333333333333 | 1 | 女装&#x2F;女士精品 | T恤 | 39.90 || 0.5 | 2 | 女装&#x2F;女士精品 | 连衣裙 | 79.90 ||  0.8333333333333334 | 3 | 女装&#x2F;女士精品 | 卫衣 | 89.90 ||  0.8333333333333334 | 4 | 女装&#x2F;女士精品 | 牛仔裤 | 89.90 || 1 | 6 | 女装&#x2F;女士精品 | 呢绒外套 |  399.90 || 0.16666666666666666 | 9 | 户外运动 | 登山杖 | 59.90 || 0.5 | 7 | 户外运动 | 自行车 |  399.90 || 0.5 | 10 | 户外运动 | 骑行装备 |  399.90 ||  0.6666666666666666 | 12 | 户外运动 | 滑板 |  499.90 ||  0.8333333333333334 | 11 | 户外运动 | 运动外套 |  799.90 || 1 | 8 | 户外运动 | 山地自行车 | 1399.90 |+---------------------+----+---------------+------------+---------+12 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="2-4-3-前后函数"><a href="#2-4-3-前后函数" class="headerlink" title="2. 4. 3 前后函数"></a>2. 4. 3 前后函数</h4><ol><li><p><strong>LAG(expr,n)函数</strong><br>LAG(expr,n)函数返回当前行的前n行的expr的值。<br>举例：查询goods数据表中前一个商品价格与当前商品价格的差值。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT id, category, NAME, price, pre_price, price - pre_price AS diff_price    -&gt; FROM (    -&gt;  SELECT id, category, NAME, price,LAG(price, 1 ) OVER w AS pre_price    -&gt;  FROM goods    -&gt; WINDOW w AS (PARTITION BY category_id ORDER BY price)) t;+----+---------------+------------+---------+-----------+------------+| id | category | NAME | price | pre_price | diff_price |+----+---------------+------------+---------+-----------+------------+| 5 | 女装&#x2F;女士精品 | 百褶裙 | 29.90 |  NULL | NULL || 1 | 女装&#x2F;女士精品 | T恤 | 39.90 | 29.90 |  10.00 || 2 | 女装&#x2F;女士精品 | 连衣裙 | 79.90 | 39.90 |  40.00 || 3 | 女装&#x2F;女士精品 | 卫衣 | 89.90 | 79.90 |  10.00 || 4 | 女装&#x2F;女士精品 | 牛仔裤 | 89.90 | 89.90 | 0.00 || 6 | 女装&#x2F;女士精品 | 呢绒外套 |  399.90 | 89.90 | 310.00 || 9 | 户外运动 | 登山杖 | 59.90 |  NULL | NULL || 7 | 户外运动 | 自行车 |  399.90 | 59.90 | 340.00 || 10 | 户外运动 | 骑行装备 |  399.90 |  399.90 | 0.00 || 12 | 户外运动 | 滑板 |  499.90 |  399.90 | 100.00 || 11 | 户外运动 | 运动外套 |  799.90 |  499.90 | 300.00 || 8 | 户外运动 | 山地自行车 | 1399.90 |  799.90 | 600.00 |+----+---------------+------------+---------+-----------+------------+12 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>LEAD(expr,n)函数</strong><br>LEAD(expr,n)函数返回当前行的后n行的expr的值。<br>举例：查询goods数据表中后一个商品价格与当前商品价格的差值。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT id, category, NAME, behind_price, price,behind_price - price AS diff_price    -&gt; FROM(    -&gt;  SELECT id, category, NAME, price,LEAD(price, 1 ) OVER w AS behind_price    -&gt;  FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price)) t;+----+---------------+------------+--------------+---------+------------+| id | category | NAME | behind_price | price | diff_price |+----+---------------+------------+--------------+---------+------------+| 5 | 女装&#x2F;女士精品 | 百褶裙 |  39.90 | 29.90 |  10.00 || 1 | 女装&#x2F;女士精品 | T恤 |  79.90 | 39.90 |  40.00 || 2 | 女装&#x2F;女士精品 | 连衣裙 |  89.90 | 79.90 |  10.00 || 3 | 女装&#x2F;女士精品 | 卫衣 |  89.90 | 89.90 | 0.00 || 4 | 女装&#x2F;女士精品 | 牛仔裤 | 399.90 | 89.90 | 310.00 || 6 | 女装&#x2F;女士精品 | 呢绒外套 | NULL |  399.90 | NULL || 9 | 户外运动 | 登山杖 | 399.90 | 59.90 | 340.00 || 7 | 户外运动 | 自行车 | 399.90 |  399.90 | 0.00 || 10 | 户外运动 | 骑行装备 | 499.90 |  399.90 | 100.00 || 12 | 户外运动 | 滑板 | 799.90 |  499.90 | 300.00 || 11 | 户外运动 | 运动外套 |  1399.90 |  799.90 | 600.00 || 8 | 户外运动 | 山地自行车 | NULL | 1399.90 | NULL |+----+---------------+------------+--------------+---------+------------+12 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="2-4-4-首尾函数"><a href="#2-4-4-首尾函数" class="headerlink" title="2. 4. 4 首尾函数"></a>2. 4. 4 首尾函数</h4><ol><li><p><strong>FIRST_VALUE(expr)函数</strong><br>FIRST_VALUE(expr)函数返回第一个expr的值。<br>举例：按照价格排序，查询第 1 个商品的价格信息。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT id, category, NAME, price, stock,FIRST_VALUE(price) OVER w AS first_price    -&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);+----+---------------+------------+---------+-------+-------------+| id | category | NAME | price | stock | first_price |+----+---------------+------------+---------+-------+-------------+| 5 | 女装&#x2F;女士精品 | 百褶裙 | 29.90 | 500 | 29.90 || 1 | 女装&#x2F;女士精品 | T恤 | 39.90 | 1000 | 29.90 || 2 | 女装&#x2F;女士精品 | 连衣裙 | 79.90 | 2500 | 29.90 || 3 | 女装&#x2F;女士精品 | 卫衣 | 89.90 | 1500 | 29.90 || 4 | 女装&#x2F;女士精品 | 牛仔裤 | 89.90 | 3500 | 29.90 || 6 | 女装&#x2F;女士精品 | 呢绒外套 |  399.90 | 1200 | 29.90 || 9 | 户外运动 | 登山杖 | 59.90 | 1500 | 59.90 || 7 | 户外运动 | 自行车 |  399.90 | 1000 | 59.90 || 10 | 户外运动 | 骑行装备 |  399.90 | 3500 | 59.90 || 12 | 户外运动 | 滑板 |  499.90 | 1200 | 59.90 || 11 | 户外运动 | 运动外套 |  799.90 | 500 | 59.90 || 8 | 户外运动 | 山地自行车 | 1399.90 | 2500 | 59.90 |+----+---------------+------------+---------+-------+-------------+12 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>LAST_VALUE(expr)函数</strong><br>LAST_VALUE(expr)函数返回最后一个expr的值。<br>举例：按照价格排序，查询最后一个商品的价格信息。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT id, category, NAME, price, stock,LAST_VALUE(price) OVER w AS last_price    -&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);+----+---------------+------------+---------+-------+------------+| id | category | NAME | price | stock | last_price |+----+---------------+------------+---------+-------+------------+| 5 | 女装&#x2F;女士精品 | 百褶裙 | 29.90 | 500 |  29.90 || 1 | 女装&#x2F;女士精品 | T恤 | 39.90 | 1000 |  39.90 || 2 | 女装&#x2F;女士精品 | 连衣裙 | 79.90 | 2500 |  79.90 || 3 | 女装&#x2F;女士精品 | 卫衣 | 89.90 | 1500 |  89.90 || 4 | 女装&#x2F;女士精品 | 牛仔裤 | 89.90 | 3500 |  89.90 || 6 | 女装&#x2F;女士精品 | 呢绒外套 |  399.90 | 1200 | 399.90 || 9 | 户外运动 | 登山杖 | 59.90 | 1500 |  59.90 || 7 | 户外运动 | 自行车 |  399.90 | 1000 | 399.90 || 10 | 户外运动 | 骑行装备 |  399.90 | 3500 | 399.90 || 12 | 户外运动 | 滑板 |  499.90 | 1200 | 499.90 || 11 | 户外运动 | 运动外套 |  799.90 | 500 | 799.90 || 8 | 户外运动 | 山地自行车 | 1399.90 | 2500 |  1399.90 |+----+---------------+------------+---------+-------+------------+12 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="2-4-5-其他函数"><a href="#2-4-5-其他函数" class="headerlink" title="2. 4. 5 其他函数"></a>2. 4. 5 其他函数</h4><ol><li><p><strong>NTH_VALUE(expr,n)函数</strong><br>NTH_VALUE(expr,n)函数返回第n个expr的值。<br>举例：查询goods数据表中排名第 2 和第 3 的价格信息。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT id, category, NAME, price,NTH_VALUE(price, 2 ) OVER w AS second_price,    -&gt; NTH_VALUE(price, 3 ) OVER w AS third_price    -&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);+----+---------------+------------+---------+--------------+-------------+| id | category | NAME | price | second_price | third_price |+----+---------------+------------+---------+--------------+-------------+| 5 | 女装&#x2F;女士精品 | 百褶裙 | 29.90 | NULL |  NULL || 1 | 女装&#x2F;女士精品 | T恤 | 39.90 |  39.90 |  NULL || 2 | 女装&#x2F;女士精品 | 连衣裙 | 79.90 |  39.90 | 79.90 || 3 | 女装&#x2F;女士精品 | 卫衣 | 89.90 |  39.90 | 79.90 || 4 | 女装&#x2F;女士精品 | 牛仔裤 | 89.90 |  39.90 | 79.90 || 6 | 女装&#x2F;女士精品 | 呢绒外套 |  399.90 |  39.90 | 79.90 || 9 | 户外运动 | 登山杖 | 59.90 | NULL |  NULL || 7 | 户外运动 | 自行车 |  399.90 | 399.90 |  399.90 || 10 | 户外运动 | 骑行装备 |  399.90 | 399.90 |  399.90 || 12 | 户外运动 | 滑板 |  499.90 | 399.90 |  399.90 || 11 | 户外运动 | 运动外套 |  799.90 | 399.90 |  399.90 || 8 | 户外运动 | 山地自行车 | 1399.90 | 399.90 |  399.90 |+----+---------------+------------+---------+--------------+-------------+12 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>NTILE(n)函数</strong><br>NTILE(n)函数将分区中的有序数据分为n个桶，记录桶编号。<br>举例：将goods表中的商品按照价格分为 3 组。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT NTILE( 3 ) OVER w AS nt,id, category, NAME, price    -&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);+----+----+---------------+------------+---------+| nt | id | category | NAME | price |+----+----+---------------+------------+---------+| 1 | 5 | 女装&#x2F;女士精品 | 百褶裙 | 29.90 || 1 | 1 | 女装&#x2F;女士精品 | T恤 | 39.90 || 2 | 2 | 女装&#x2F;女士精品 | 连衣裙 | 79.90 || 2 | 3 | 女装&#x2F;女士精品 | 卫衣 | 89.90 || 3 | 4 | 女装&#x2F;女士精品 | 牛仔裤 | 89.90 || 3 | 6 | 女装&#x2F;女士精品 | 呢绒外套 |  399.90 || 1 | 9 | 户外运动 | 登山杖 | 59.90 || 1 | 7 | 户外运动 | 自行车 |  399.90 || 2 | 10 | 户外运动 | 骑行装备 |  399.90 || 2 | 12 | 户外运动 | 滑板 |  499.90 || 3 | 11 | 户外运动 | 运动外套 |  799.90 || 3 | 8 | 户外运动 | 山地自行车 | 1399.90 |+----+----+---------------+------------+---------+12 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="2-5-小-结"><a href="#2-5-小-结" class="headerlink" title="2. 5 小 结"></a>2. 5 小 结</h3><p>窗口函数的特点是可以分组，而且可以在分组内排序。另外，窗口函数不会因为分组而减少原表中的行数，这对我们在原表数据的基础上进行统计和排序非常有用。</p><hr><h2 id="3-新特性-2-：公用表表达式"><a href="#3-新特性-2-：公用表表达式" class="headerlink" title="3. 新特性 2 ：公用表表达式"></a>3. 新特性 2 ：公用表表达式</h2><hr><p>公用表表达式（或通用表表达式）简称为CTE（Common Table Expressions）。CTE是一个命名的临时结果集，作用范围是当前语句。CTE可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的，CTE可以引用其他CTE，但子查询不能引用其他子查询。所以，可以考虑代替子查询。</p><p>依据语法结构和执行方式的不同，公用表表达式分为<code>普通公用表表达式</code>和<code>递归公用表表达式</code> 2 种。</p><h3 id="3-1-普通公用表表达式"><a href="#3-1-普通公用表表达式" class="headerlink" title="3. 1 普通公用表表达式"></a>3. 1 普通公用表表达式</h3><p>普通公用表表达式的语法结构是：</p><pre class="line-numbers language-none"><code class="language-none">WITH CTE名称AS （子查询）SELECT|DELETE|UPDATE 语句;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>普通公用表表达式类似于子查询，不过，跟子查询不同的是，它可以被多次引用，而且可以被其他的普通公用表表达式所引用。</p><p>举例：查询员工所在的部门的详细信息。</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM departments    -&gt; WHERE department_id IN (    -&gt;  SELECT DISTINCT department_id    -&gt;  FROM employees    -&gt; );+---------------+------------------+------------+-------------+| department_id | department_name | manager_id | location_id |+---------------+------------------+------------+-------------+| 10 | Administration | 200 | 1700 || 20 | Marketing | 201 | 1800 || 30 | Purchasing | 114 | 1700 || 40 | Human Resources | 203 | 2400 || 50 | Shipping | 121 | 1500 || 60 | IT | 103 | 1400 || 70 | Public Relations | 204 | 2700 || 80 | Sales | 145 | 2500 || 90 | Executive | 100 | 1700 || 100 | Finance | 108 | 1700 || 110 | Accounting | 205 | 1700 |+---------------+------------------+------------+-------------+11 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个查询也可以用普通公用表表达式的方式完成：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; WITH emp_dept_id    -&gt; AS (SELECT DISTINCT department_id FROM employees)    -&gt; SELECT *    -&gt; FROM departments d JOIN emp_dept_id e    -&gt; ON d.department_id &#x3D; e.department_id;+---------------+------------------+------------+-------------+---------------+| department_id | department_name | manager_id | location_id | department_id |+---------------+------------------+------------+-------------+---------------+| 90 | Executive | 100 | 1700 | 90 || 60 | IT | 103 | 1400 | 60 || 100 | Finance | 108 | 1700 | 100 || 30 | Purchasing | 114 | 1700 | 30 || 50 | Shipping | 121 | 1500 | 50 || 80 | Sales | 145 | 2500 | 80 || 10 | Administration | 200 | 1700 | 10 || 20 | Marketing | 201 | 1800 | 20 || 40 | Human Resources | 203 | 2400 | 40 || 70 | Public Relations | 204 | 2700 | 70 || 110 | Accounting | 205 | 1700 | 110 |+---------------+------------------+------------+-------------+---------------+11 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例子说明，公用表表达式可以起到子查询的作用。以后如果遇到需要使用子查询的场景，你可以在查询之前，先定义公用表表达式，然后在查询中用它来代替子查询。而且，跟子查询相比，公用表表达式有一个优点，就是定义过公用表表达式之后的查询，可以像一个表一样多次引用公用表表达式，而子查询则不能。</p><h3 id="3-2-递归公用表表达式"><a href="#3-2-递归公用表表达式" class="headerlink" title="3. 2 递归公用表表达式"></a>3. 2 递归公用表表达式</h3><p>递归公用表表达式也是一种公用表表达式，只不过，除了普通公用表表达式的特点以外，它还有自己的特点，就是 <strong>可以调用自己</strong> 。它的语法结构是：</p><pre class="line-numbers language-none"><code class="language-none">WITH RECURSIVECTE名称 AS （子查询）SELECT|DELETE|UPDATE 语句;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>递归公用表表达式由 2 部分组成，分别是种子查询和递归查询，中间通过关键字 UNION [ALL]进行连接。这里的 <strong>种子查询，意思就是获得递归的初始值</strong> 。这个查询只会运行一次，以创建初始数据集，之后递归查询会一直执行，直到没有任何新的查询数据产生，递归返回。</p><p><strong>案例：</strong> 针对于我们常用的employees表，包含employee_id，last_name和manager_id三个字段。如果a是b的管理者，那么，我们可以把b叫做a的下属，如果同时b又是c的管理者，那么c就是b的下属，是a的下下属。</p><p>下面我们尝试用查询语句列出所有具有下下属身份的人员信息。</p><p>如果用我们之前学过的知识来解决，会比较复杂，至少要进行 4 次查询才能搞定：</p><ul><li>第一步，先找出初代管理者，就是不以任何别人为管理者的人，把结果存入临时表；</li><li>第二步，找出所有以初代管理者为管理者的人，得到一个下属集，把结果存入临时表；</li><li>第三步，找出所有以下属为管理者的人，得到一个下下属集，把结果存入临时表。</li><li>第四步，找出所有以下下属为管理者的人，得到一个结果集。</li></ul><p>如果第四步的结果集为空，则计算结束，第三步的结果集就是我们需要的下下属集了，否则就必须继续进行第四步，一直到结果集为空为止。比如上面的这个数据表，就需要到第五步，才能得到空结果集。而且，最后还要进行第六步：把第三步和第四步的结果集合并，这样才能最终获得我们需要的结果集。</p><p>如果用递归公用表表达式，就非常简单了。我介绍下具体的思路。</p><ul><li>用递归公用表表达式中的种子查询，找出初代管理者。字段 n 表示代次，初始值为 1 ，表示是第一代管理者。</li><li>用递归公用表表达式中的递归查询，查出以这个递归公用表表达式中的人为管理者的人，并且代次的值加 1 。直到没有人以这个递归公用表表达式中的人为管理者了，递归返回。</li><li>在最后的查询中，选出所有代次大于等于 3 的人，他们肯定是第三代及以上代次的下属了，也就是下下属了。这样就得到了我们需要的结果集。</li></ul><p>这里看似也是 3 步，实际上是一个查询的 3 个部分，只需要执行一次就可以了。而且也不需要用临时表保存中间结果，比刚刚的方法简单多了。</p><p><strong>代码实现：</strong></p><pre class="line-numbers language-none"><code class="language-none">WITH RECURSIVE cteAS(SELECT employee_id,last_name,manager_id, 1 AS n FROM employees WHERE employee_id &#x3D; 100 -- 种子查询，找到第一代领导UNION ALLSELECT a.employee_id,a.last_name,a.manager_id,n+ 1 FROM employees AS a JOIN cteON (a.manager_id &#x3D; cte.employee_id) -- 递归查询，找出以递归公用表表达式的人为领导的人)SELECT employee_id,last_name FROM cte WHERE n &gt;&#x3D; 3 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总之，递归公用表表达式对于查询一个有共同的根节点的树形结构数据，非常有用。它可以不受层级的限制，轻松查出所有节点的数据。如果用其他的查询方式，就比较复杂了。</p><h3 id="3-3-小-结"><a href="#3-3-小-结" class="headerlink" title="3. 3 小 结"></a>3. 3 小 结</h3><p>公用表表达式的作用是可以替代子查询，而且可以被多次引用。递归公用表表达式对查询有一个共同根节点的树形结构数据非常高效，可以轻松搞定其他查询方式难以处理的查询。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下MySQL的安装与使用</title>
      <link href="/2022/07/17/gao-ji-pian-di-01-zhang-linux-xia-mysql-de-an-zhuang-yu-shi-yong/"/>
      <url>/2022/07/17/gao-ji-pian-di-01-zhang-linux-xia-mysql-de-an-zhuang-yu-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="高级篇-第01章-Linux下MySQL的安装与使用"><a href="#高级篇-第01章-Linux下MySQL的安装与使用" class="headerlink" title="高级篇_第01章_Linux下MySQL的安装与使用"></a>高级篇_第01章_Linux下MySQL的安装与使用</h1><h2 id="1-安装前说明"><a href="#1-安装前说明" class="headerlink" title="1. 安装前说明"></a><strong>1.</strong> <strong>安装前说明</strong></h2><hr><h3 id="1-1-查看是否安装过MySQL"><a href="#1-1-查看是否安装过MySQL" class="headerlink" title="1.1 查看是否安装过MySQL"></a><strong>1.1</strong> <strong>查看是否安装过MySQL</strong></h3><ul><li>如果你是用rpm安装, 检查一下RPM PACKAGE：</li></ul><pre class="line-numbers language-none"><code class="language-none">rpm -qa | grep -i mysql # -i 忽略大小写<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>检查mysql service：</li></ul><pre class="line-numbers language-none"><code class="language-none">systemctl status mysqld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-MySQL的卸载"><a href="#1-2-MySQL的卸载" class="headerlink" title="1.2 MySQL的卸载"></a><strong>1.2 MySQL的卸载</strong></h3><p><strong>1.</strong> <strong>关闭</strong> <strong>mysql</strong> <strong>服务</strong></p><pre class="line-numbers language-none"><code class="language-none">systemctl stop mysqld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2.</strong> <strong>查看当前</strong> <strong>mysql</strong> <strong>安装状况</strong></p><pre class="line-numbers language-none"><code class="language-none">rpm -qa | grep -i mysql# 或yum list installed | grep mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>3.</strong> <strong>卸载上述命令查询出的已安装程序</strong></p><pre class="line-numbers language-none"><code class="language-none">yum remove mysql-xxx mysql-xxx mysql-xxx mysql-xxxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>务必卸载干净，反复执行<code>rpm -qa | grep -i mysql</code>确认是否有卸载残留</p><p><strong>4.</strong> <strong>删除</strong> <strong>mysql</strong> <strong>相关文件</strong></p><ul><li>查找相关文件</li></ul><pre class="line-numbers language-none"><code class="language-none">find &#x2F; -name mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>删除上述命令查找出的相关文件</li></ul><pre class="line-numbers language-none"><code class="language-none">rm -rf xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>5.删除 my.cnf</strong></p><pre class="line-numbers language-none"><code class="language-none">rm -rf &#x2F;etc&#x2F;my.cnf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-MySQL的Linux版安装"><a href="#2-MySQL的Linux版安装" class="headerlink" title="2. MySQL的Linux版安装"></a><strong>2. MySQL的Linux版安装</strong></h2><hr><h3 id="2-1-CentOS7下检查MySQL依赖"><a href="#2-1-CentOS7下检查MySQL依赖" class="headerlink" title="2.1 CentOS7下检查MySQL依赖"></a><strong>2.1 CentOS7下检查MySQL依赖</strong></h3><p><strong>1.</strong> <strong>检查&#x2F;tmp临时目录权限（必不可少）</strong></p><p>由于mysql安装过程中，会通过mysql用户在&#x2F;tmp目录下新建tmp_db文件，所以请给&#x2F;tmp较大的权限。执行 ：</p><pre class="line-numbers language-none"><code class="language-none">chmod -R 777 &#x2F;tmp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2.</strong> <strong>安装前，检查依赖</strong></p><pre class="line-numbers language-none"><code class="language-none">rpm -qa|grep libaiorpm -qa|grep net-tools<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-2-CentOS7下MySQL安装过程"><a href="#2-2-CentOS7下MySQL安装过程" class="headerlink" title="2.2 CentOS7下MySQL安装过程"></a><strong>2.2 CentOS7下MySQL安装过程</strong></h3><p><strong>1.</strong> <strong>将安装程序拷贝到&#x2F;opt目录下</strong></p><p>在mysql的安装文件目录下执行：（必须按照顺序执行）</p><pre class="line-numbers language-none"><code class="language-none">rpm -ivh mysql-community-common-8.0.25-1.el7.x86_64.rpm rpm -ivh mysql-community-client-plugins-8.0.25-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-8.0.25-1.el7.x86_64.rpm rpm -ivh mysql-community-client-8.0.25-1.el7.x86_64.rpm rpm -ivh mysql-community-server-8.0.25-1.el7.x86_64.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>rpm</code>是Redhat Package Manage缩写，通过RPM的管理，用户可以把源代码包装成以rpm为扩展名的文件形式，易于安装。</li><li><code>-i</code>, –install 安装软件包</li><li><code>-v</code>, –verbose 提供更多的详细信息输出</li><li><code>-h</code>, –hash 软件包安装的时候列出哈希标记 (和 -v 一起使用效果更好)，展示进度条</li></ul><blockquote><p>若存在mariadb-libs问题，则执行<strong>yum remove mysql-libs</strong>即可</p></blockquote><h3 id="2-3-查看MySQL版本"><a href="#2-3-查看MySQL版本" class="headerlink" title="2.3 查看MySQL版本"></a><strong>2.3</strong> <strong>查看MySQL版本</strong></h3><pre class="line-numbers language-none"><code class="language-none">mysql --version #或mysqladmin --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-4-服务的初始化"><a href="#2-4-服务的初始化" class="headerlink" title="2.4 服务的初始化"></a><strong>2.4</strong> <strong>服务的初始化</strong></h3><p>为了保证数据库目录与文件的所有者为 mysql 登录用户，如果你是以 root 身份运行 mysql 服务，需要执行下面的命令初始化：</p><pre class="line-numbers language-none"><code class="language-none">mysqld --initialize --user&#x3D;mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明： –initialize 选项默认以“安全”模式来初始化，则会为 root 用户生成一个密码并将<code>该密码标记为过期</code>，登录后你需要设置一个新的密码。生成的<code>临时密码</code>会往日志中记录一份。</p><p>查看密码：</p><pre class="line-numbers language-none"><code class="language-none">cat &#x2F;var&#x2F;log&#x2F;mysqld.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>root@localhost: 后面就是初始化的密码</p><h3 id="2-5-启动MySQL，查看状态"><a href="#2-5-启动MySQL，查看状态" class="headerlink" title="2.5 启动MySQL，查看状态"></a><strong>2.5</strong> <strong>启动MySQL，查看状态</strong></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#加不加.service后缀都可以 </span>启动：systemctl start mysqld.service 关闭：systemctl stop mysqld.service 重启：systemctl restart mysqld.service 查看状态：systemctl status mysqld.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-查看MySQL服务是否自启动"><a href="#2-6-查看MySQL服务是否自启动" class="headerlink" title="2.6 查看MySQL服务是否自启动"></a><strong>2.6</strong> <strong>查看MySQL服务是否自启动</strong></h3><pre class="line-numbers language-none"><code class="language-none">systemctl list-unit-files|grep mysqld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>如不是enabled可以运行如下命令设置自启动</li></ul><pre class="line-numbers language-none"><code class="language-none">systemctl enable mysqld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>如果希望不进行自启动，运行如下命令设置</li></ul><pre class="line-numbers language-none"><code class="language-none">systemctl disable mysqld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-MySQL登录"><a href="#3-MySQL登录" class="headerlink" title="3. MySQL登录"></a><strong>3. MySQL登录</strong></h2><hr><h3 id="3-1-首次登录"><a href="#3-1-首次登录" class="headerlink" title="3.1 首次登录"></a><strong>3.1</strong> <strong>首次登录</strong></h3><p>通过<code>mysql -hlocalhost -P3306 -uroot -p</code>进行登录，在Enter password：录入初始化密码</p><h3 id="3-2-修改密码"><a href="#3-2-修改密码" class="headerlink" title="3.2 修改密码"></a><strong>3.2</strong> <strong>修改密码</strong></h3><pre class="line-numbers language-none"><code class="language-none">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new_password&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-3-设置远程登录"><a href="#3-3-设置远程登录" class="headerlink" title="3.3 设置远程登录"></a><strong>3.3</strong> <strong>设置远程登录</strong></h3><p><strong>1.</strong> <strong>确认网络</strong></p><p>1.在远程机器上使用ping ip地址<code>保证网络畅通</code></p><p>2.在远程机器上使用telnet命令<code>保证端口号开放</code>访问</p><p><strong>2.</strong> <strong>关闭防火墙或开放端口</strong></p><p><strong>方式一：关闭防火墙</strong></p><ul><li>CentOS6 ：</li></ul><pre class="line-numbers language-none"><code class="language-none">service iptables stop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>CentOS7：</li></ul><pre class="line-numbers language-none"><code class="language-none">#开启防火墙systemctl start firewalld.service#查看防火墙状态systemctl status firewalld.service#关闭防火墙systemctl stop firewalld.service#设置开机启用防火墙 systemctl enable firewalld.service #设置开机禁用防火墙 systemctl disable firewalld.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方式二：开放端口</strong></p><ul><li>查看开放的端口号</li></ul><pre class="line-numbers language-none"><code class="language-none">firewall-cmd --list-all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>设置开放的端口号</li></ul><pre class="line-numbers language-none"><code class="language-none">firewall-cmd --add-service&#x3D;http --permanentfirewall-cmd --add-port&#x3D;3306&#x2F;tcp --permanent<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>重启防火墙</li></ul><pre class="line-numbers language-none"><code class="language-none">firewall-cmd --reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-Linux下修改配置"><a href="#4-Linux下修改配置" class="headerlink" title="4. Linux下修改配置"></a><strong>4. Linux下修改配置</strong></h2><hr><ul><li>修改允许远程登陆</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> mysql<span class="token punctuation">;</span><span class="token keyword">select</span> Host<span class="token punctuation">,</span><span class="token keyword">User</span> <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token keyword">update</span> <span class="token keyword">user</span> <span class="token keyword">set</span> host <span class="token operator">=</span> <span class="token string">'%'</span> <span class="token keyword">where</span> <span class="token keyword">user</span> <span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">;</span>flush <span class="token keyword">privileges</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>%</code>是个 通配符 ，如果Host&#x3D;192.168.1.%，那么就表示只要是IP地址前缀为“192.168.1.”的客户端都可以连接。如果<code>Host=%</code>，表示所有IP都有连接权限。</p><p>注意：在生产环境下不能为了省事将host设置为%，这样做会存在安全问题，具体的设置可以根据生产环境的IP进行设置。</p></blockquote><p>配置新连接报错：错误号码 2058，分析是 mysql 密码加密方法变了。</p><p><strong>解决方法一：</strong>升级远程连接工具版本</p><p><strong>解决方法二：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">USER</span> <span class="token string">'root'</span><span class="token variable">@'%'</span> IDENTIFIED <span class="token keyword">WITH</span> mysql_native_password <span class="token keyword">BY</span> <span class="token string">'abc123'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-字符集的相关操作"><a href="#5-字符集的相关操作" class="headerlink" title="5. 字符集的相关操作"></a><strong>5.</strong> <strong>字符集的相关操作</strong></h2><hr><h3 id="5-1-各级别的字符集"><a href="#5-1-各级别的字符集" class="headerlink" title="5.1 各级别的字符集"></a><strong>5.1</strong> <strong>各级别的字符集</strong></h3><pre class="line-numbers language-none"><code class="language-none">show variables like &#39;character%&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>character_set_server：服务器级别的字符集</li><li>character_set_database：当前数据库的字符集</li><li>character_set_client：服务器解码请求时使用的字符集</li><li>character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection</li><li>character_set_results：服务器向客户端返回数据时使用的字符集</li></ul><p><strong>小结</strong></p><ul><li>如果<code>创建或修改列</code>时没有显式的指定字符集和比较规则，则该列<code>默认用表的</code>字符集和比较规则</li><li>如果<code>创建表时</code>没有显式的指定字符集和比较规则，则该表<code>默认用数据库的</code>字符集和比较规则</li><li>如果<code>创建数据库时</code>没有显式的指定字符集和比较规则，则该数据库<code>默认用服务器的</code>字符集和比较规则</li></ul><h3 id="5-2-请求到响应过程中字符集的变化"><a href="#5-2-请求到响应过程中字符集的变化" class="headerlink" title="5.2 请求到响应过程中字符集的变化"></a><strong>5.2</strong> <strong>请求到响应过程中字符集的变化</strong></h3><pre class="line-numbers language-none"><code class="language-none">graph TBA(客户端) --&gt; |&quot;使用操作系统的字符集编码请求字符串&quot;| B(从character_set_client转换为character_set_connection)B --&gt; C(从character_set_connection转换为具体的列使用的字符集)C --&gt; D(将查询结果从具体的列上使用的字符集转换为character_set_results)D --&gt; |&quot;使用操作系统的字符集解码响应的字符串&quot;| A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-docker安装MySQL"><a href="#6-docker安装MySQL" class="headerlink" title="6.docker安装MySQL"></a>6.docker安装MySQL</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># docker 中下载 mysql</span>docker pull mysql<span class="token comment">#启动</span>docker run <span class="token comment">--name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=Lzslov123! -d mysql</span><span class="token comment">#进入容器</span>docker <span class="token keyword">exec</span> <span class="token operator">-</span>it mysql bash<span class="token comment">#登录mysql</span>mysql <span class="token operator">-</span>u root <span class="token operator">-</span>p<span class="token keyword">ALTER</span> <span class="token keyword">USER</span> <span class="token string">'root'</span><span class="token variable">@'localhost'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'Lzslov123!'</span><span class="token punctuation">;</span><span class="token comment">#添加远程登录用户</span><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'liaozesong'</span><span class="token variable">@'%'</span> IDENTIFIED <span class="token keyword">WITH</span> mysql_native_password <span class="token keyword">BY</span> <span class="token string">'Lzslov123!'</span><span class="token punctuation">;</span><span class="token keyword">GRANT</span> <span class="token keyword">ALL</span> <span class="token keyword">PRIVILEGES</span> <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">'liaozesong'</span><span class="token variable">@'%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据知识点汇总</title>
      <link href="/2022/07/14/da-shu-ju-zhi-shi-dian/"/>
      <url>/2022/07/14/da-shu-ju-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h3><table><thead><tr><th>序号</th><th>命令</th><th>命令解释</th></tr></thead><tbody><tr><td>1</td><td>top &#x2F; free</td><td>查看内存</td></tr><tr><td>2</td><td>df -h</td><td>查看磁盘存储情况</td></tr><tr><td>3</td><td>iotop</td><td>查看磁盘IO读写(yum install iotop安装）</td></tr><tr><td>4</td><td>iotop -o</td><td>直接查看比较高的磁盘读写程序</td></tr><tr><td>5</td><td>netstat -tunlp | grep 端口号</td><td>查看端口占用情况</td></tr><tr><td>6</td><td>uptime</td><td>查看报告系统运行时长及平均负载</td></tr><tr><td>7</td><td>ps -ef</td><td>查看进程</td></tr></tbody></table><h4 id="Shell常用工具"><a href="#Shell常用工具" class="headerlink" title="Shell常用工具"></a>Shell常用工具</h4><p>awk{print $1}；sed；cut；sort；xargs -n</p><p>单引号不取变量值，反引号执行命令，双引号嵌套单引号取变量值</p><hr><h3 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h3><table><thead><tr><th></th><th>hadoop2.x</th><th>Hadoop3.x</th></tr></thead><tbody><tr><td>访问HDFS端口</td><td>50070</td><td>9870</td></tr><tr><td>访问MR执行情况端口</td><td>8088</td><td>8088</td></tr><tr><td>历史服务器</td><td>19888</td><td>19888</td></tr><tr><td>客户端访问集群端口</td><td>9000</td><td>8020</td></tr></tbody></table><h4 id="HDFS读流程"><a href="#HDFS读流程" class="headerlink" title="HDFS读流程"></a>HDFS读流程</h4><ol><li>客户端向NameNode发送请求</li><li>NN返回目标文件的元数据</li><li>客户端向DataNode请求读取数据</li><li>读到数据后关闭FSDataInputStream</li></ol><h4 id="HDFS写流程"><a href="#HDFS写流程" class="headerlink" title="HDFS写流程"></a>HDFS写流程</h4><ol><li>客户端向NN请求上传</li><li>NN判断是否可以上传(权限 &#x2F; 文件if exists)并响应</li><li>Cli请求上传第一个块，请返回DN</li><li>NN根据节点选择，返回DN</li><li>Cli与对应DN建立传输通道</li><li>应答成功后传输数据</li><li>完成后关闭FSDataOutputStream</li></ol><h4 id="HDFS小文件处理"><a href="#HDFS小文件处理" class="headerlink" title="HDFS小文件处理"></a>HDFS小文件处理</h4><p>影响：<br>​1、存储：一个文件占用一个文件块,文件元数据存储在nn内会影响NameNode的寿命<br>​2、计算：一个小文件启用一个MapTask,默认1G</p><p>解决：<br>​1、采用har归档方式<br>​2、文件切片，采用CombineTextInputFormat把多个文件合并到一起统一切片<br>​3、开启JVM重用</p><h4 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a>NameNode</h4><ul><li>内存是动态分配的，最小1G,每增加100万个block，增加1G内存</li><li>NN会维护一个心跳以确定DN的存在</li></ul><h4 id="纠删码原理"><a href="#纠删码原理" class="headerlink" title="纠删码原理"></a>纠删码原理</h4><p>每3个数据单元，生成2个校验单元，这5个单元中，只要有任意的3个单元存在(不管是数据单元还是校验单元，只要总数&#x3D;3)，就可以得到原始数据。</p><h4 id="MapReduce运行流程"><a href="#MapReduce运行流程" class="headerlink" title="MapReduce运行流程"></a>MapReduce运行流程</h4><p>Cli提交job -&gt;Yarn RM -&gt; TextInputFormat -&gt; kv -&gt; Mapper -&gt; 环形缓冲区 -&gt; Partitioner -&gt; 排序 -&gt; Merge归并 -&gt;Reducer -&gt;Merge </p><h4 id="shuffle及优化"><a href="#shuffle及优化" class="headerlink" title="shuffle及优化"></a>shuffle及优化</h4><ol><li>map后，reduce前(排序-&gt;分区内有序，归约-&gt;combiner，分组)</li><li>不影响业务逻辑下采用Combiner预聚合</li><li>减少溢写次数，修改环形缓冲区大小</li><li>自定义分区，减少数据倾斜</li><li>采用压缩，减少IO</li></ol><h4 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h4><ul><li>Application:Mr申请 -&gt; RM返回路径 -&gt; Mr提交资源 -&gt; 运行AM -&gt; NodeManager -&gt;  运行 -&gt; 注销YarnChild </li><li>Yarn的调度器:FIFO &#x2F; 容量(资源紧张) &#x2F; 公平(并发度)</li></ul><h4 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h4><ol><li>提前在map将key聚合combine,减少传输</li><li>两阶段聚合(局部聚合+整体聚合：如果key分布在不同mapper:二次mr，第一次将key随机散列到不同reducer进行处理达到负载均衡目的。第二次再根据去掉key的随机前缀，按原key进行reduce处理。)</li><li>实现自定义分区</li><li>增加Reducer，提升并行度</li></ol><hr><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>ls &#x2F; get &#x2F; creatae &#x2F; delete</p><h4 id="CAP法则"><a href="#CAP法则" class="headerlink" title="CAP法则"></a>CAP法则</h4><p>一个分布式系统不可能同时满足以下三种：</p><ul><li>一致性(C Consistency)：数据在多个副本之间能够保持数据一致的特性；</li><li>可用性 (A Available)：系统提供的服务一直处于可用的状态；</li><li>分区容错性(P Partition Tolerance)：分布式系统在遇到任何网络分区故障时，仍然需要能够保证对外提供满足一致性和可用性的服务</li></ul><p>ZooKeeper保证的CP</p><ol><li>不能保证每次服务请求的可用性(极端情况消费者程序要重新请求)</li><li>进行Leader选举时集群不可用</li></ol><h4 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h4><p>半数机制：2n+1，安装奇数台</p><p>10 &#x2F; 20 &#x2F; 100台服务器–3 &#x2F; 5 &#x2F; 11台安装zookeeper</p><h5 id="第一次选举"><a href="#第一次选举" class="headerlink" title="第一次选举"></a>第一次选举</h5><ol><li>服务器启动发起选举</li><li>首先给自己来一票</li><li>如果服务器状态为LOOKING则交换选票，否则保持</li><li>myid小的改票为下一台</li><li>如果下一台服务器的票数超过半数，立即当选Leader</li><li>后来服务器发动选举，如果有Leader则服从</li></ol><h5 id="非第一次选举"><a href="#非第一次选举" class="headerlink" title="非第一次选举"></a>非第一次选举</h5><p>服务器无法与Leader保持连接：</p><ul><li>服务器试图选举，被告知存在Leader，需要建立连接并状态同步</li></ul><p>集群中不存在Leader：</p><ul><li>EPOCH(任期代号)&gt;事务id大&gt;服务器id</li></ul><h4 id="Follower和Leader状态同步"><a href="#Follower和Leader状态同步" class="headerlink" title="Follower和Leader状态同步"></a>Follower和Leader状态同步</h4><p>当Follower或Leader挂掉会进行状态同步,L和F通过心跳监测机制来感知彼此的情况。</p><p>同步策略：差异化同步(DIFF)、回滚同步(TRUNC)、全量同步(SNAP)</p><ul><li>当Follower挂掉：事务id小于Leader的事务id则差异化，大于则回滚</li><li>当Leader挂掉：以新Leader为主，保证让 followers 同步已提交的提议，丢弃未提交的提议</li></ul><hr><h3 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h3><p>海量日志采集、聚合和传输的系统</p><p><img src="/../pic/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86%E7%82%B9/1657890222278.png" alt="Flume"></p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>1.event:基本传输单元-&gt; header|body</p><p>2.taildir source:</p><ul><li>断点续传、多目录；</li><li>不支持递归文件夹读取文件–需要自定义。</li></ul><p>3.channel:</p><ul><li>file channel :数据存储磁盘，可靠性高传输效率低；(可以配置dataDirs指向多个路径，增大吞吐量)–安全</li><li>Memory channel: 数据存储于内存，速度快可靠性差；–速度</li><li>Kafka channel：数据存储在Kafka，基于磁盘，可靠性高速度快，省去了sink阶段；–面向Kafka</li></ul><p>4.HDFS sink:拉取event，送到hdfs</p><p>5.Agent：source、channel、sink组成</p><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>ETL拦截器、时间戳拦截器、自定义拦截器(注意实现Interceptor.Builder)</p><p>拦截器可以不用，但是需要在下一级进行处理。</p><h4 id="Channel选择器"><a href="#Channel选择器" class="headerlink" title="Channel选择器"></a>Channel选择器</h4><ul><li>Replicating：默认选择器(复制)</li><li>Multiplexing：选择性发往指定通道(多路复用)</li></ul><h4 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h4><ul><li>LoadBalancingSinkProcessor 可以实现负载均衡的功能；</li><li>FailoverSinkProcessor 可以错误恢复的功能</li></ul><h4 id="Flume监控器"><a href="#Flume监控器" class="headerlink" title="Flume监控器"></a>Flume监控器</h4><p>采用Ganglia，如果监控到尝试提交的次数远远大于最终成功的次数，说明Flume运行较差，可以增加内存。</p><h4 id="Flume的事务机制"><a href="#Flume的事务机制" class="headerlink" title="Flume的事务机制"></a>Flume的事务机制</h4><ul><li>使用两个独立的事务分别负责从Source 到 Channel(put)，以及从 Channel 到 Sink(take) 的事件传递;</li><li>数据可能重复(sink发出数据没响应会继续发送)、但不会丢失(事务机制，Memory Channel可能丢)；</li></ul><hr><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>生产者、Broker、消费者、Zookeeper(Broker id、ids等)</p><p><img src="/../pic/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86%E7%82%B9/1657890269522.png" alt="Kafka"></p><h4 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h4><ul><li>机器数量&#x3D;2 *(峰值生产速度 * 副本数  &#x2F;  100)+ 1</li><li>副本数：2 &#x2F; 3 -&gt; 提高可靠增加IO</li><li>日志保存(7天 ，建议3天</li><li>硬盘大小&#x3D;数据量 * 副本 * 天数  &#x2F;  70%</li><li>分区数&#x3D;期望吞吐量 &#x2F; min(producer,consumer吞吐量)</li><li>Topic数量&#x3D;日志类型数量</li><li>内存：默认1g</li></ul><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>面向一个topic</p><ul><li><p>发送方式：同步、异步、带回调函数异步</p></li><li><p>分区分配策略：producer可以指定分区，将数据存储在（key的hash值 % 分区数）号分区中</p></li><li><p>提高吞吐：批次大小(batch.size:16k-&gt;32k) &#x2F; 等待时间(linger.ms:0-&gt;5-100ms) &#x2F; 压缩(compression.type) &#x2F; 缓冲区大小(32m-&gt;64m)</p></li><li><p>数据可靠：</p><p>Ack:</p><ol><li>Ack&#x3D;0:生产者发送消息增加offset，继续生产；数据可能丢失</li><li>Ack&#x3D;1:Leader应答增加offset；</li><li>Ack&#x3D;-1:Leader和ISR队列所有Follwer应答增加offset；数据可能重复</li></ol><p>幂等性(enable.idempotence) :生产者发送的消息Broker端只持久化一条（单分区单会话）</p><p>精确一次&#x3D;  幂等性 +  至少一次( ( ack&#x3D;-1 +  分区副本数&gt;&#x3D;2 + ISR 最小副本数量&gt;&#x3D;2) )+无限重试</p></li><li><p>数据重复：开启事务（ 必须指定transactional.id）或在下一级（分组、开窗）</p></li></ul><h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><p>与zookeeper交互保证集群运行，版本0.9之后offset保存在topic中。</p><h5 id="服役新节点"><a href="#服役新节点" class="headerlink" title="服役新节点"></a>服役新节点</h5><ol><li>创建一个要均衡的主题</li><li>生成一个负载均衡的计划</li><li>创建副本存储计划</li><li>执行副本存储计划</li><li>验证副本存储计划</li></ol><h5 id="退役旧节点"><a href="#退役旧节点" class="headerlink" title="退役旧节点"></a>退役旧节点</h5><ul><li>生成执行计划，同服役</li></ul><p>Flower挂：踢出isr,其他不影响，上线后读取log里面副本中最小的offset（HW)，直到&gt;&#x3D;HW</p><p>Leader挂：从isr选新，其余follower从新Leader同步</p><h5 id="offset提交"><a href="#offset提交" class="headerlink" title="offset提交"></a>offset提交</h5><p>自动（可能重复消费） &#x2F; 手动（可能漏消费）；</p><p>为避免可以将消费过程与提交offset过程做原子绑定，要求下游支持事务。</p><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><ul><li><p>拉取数据</p></li><li><p>Consumer Group （CG ）：消费者组，由多个 consumer组成,面向一个topic。</p><p>1.消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费，一个消费者可以消费多个分区（组内只有自己消费此分区）；</p><p>2.消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者</p></li><li><p>再平衡及Range(将TopicAndPartition按照hashCode排序，轮询发给每个消费线程)</p></li><li><p>保证数据有序：开启幂等性-&gt;缓存数量小于5个，会在服务端重新排序 ;关闭幂等性-&gt;缓存数量设为1（因幂等性，所以单分区有序）</p></li><li><p>副本同步队列：zookeeper会维持一个isr队列，Leader挂掉会顺延isr中下一个服务，当心跳超过45s或者处理消息超过5分钟就会认为服务不可用并剔除出isr。</p></li><li><p>数据可靠：手动提交offset</p></li><li><p>可以按照时间消费数据：需要将offset转换为时间戳KafkaUtil.fetchOffsetsWithTimestamp</p></li></ul><h4 id="数据积压"><a href="#数据积压" class="headerlink" title="数据积压"></a>数据积压</h4><p>消费能力不足：增加topic分区数，提升消费者数量，消费者数 &#x3D; 分区数；</p><p>下游处理不及时（生产速度&gt;拉取速度）：提高每批次拉取的数量；</p><h4 id="如何实现高效读写"><a href="#如何实现高效读写" class="headerlink" title="如何实现高效读写"></a>如何实现高效读写</h4><ol><li>本身是分布式集群，同时采用分区技术，并发度高；</li><li>顺序写磁盘：生产者生产数据是追加到log文件的末端；</li><li>读数据采用稀疏索引，可以快速定位</li><li>零复制技术</li></ol><h4 id="单条日志大小"><a href="#单条日志大小" class="headerlink" title="单条日志大小"></a>单条日志大小</h4><p>如果遇到一条消息大于1M,默认情况下可能procuder无法推送或consumer无法消费；</p><p>需要配置server.properties中的replica.fetch.max.bytes（可复制的消息的最大字节数）和message.max.bytes（kafka 会接收单个消息size的最大限制）。需注意接收必须小于等于复制</p><h4 id="过期数据清除"><a href="#过期数据清除" class="headerlink" title="过期数据清除"></a>过期数据清除</h4><p>log.cleanup.policy&#x3D;delete（删除） &#x2F;  compact（压缩）</p><h4 id="数据顺序"><a href="#数据顺序" class="headerlink" title="数据顺序"></a>数据顺序</h4><p>单分区内有序；多分区，分区与分区间无序；</p><p>生产者可以指定key以将数据发送到同一个分区；</p><hr><h3 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h3><p>可以将结构化数据映射成一张数据表,并提供类SQL的查询功能，本质是将SQL语句转化成MapReduce程序；</p><p>Hive元数据默认存储在derby数据库，不支持多客户端访问，所以将元数据存储在MySQL，支持多客户端访问。</p><p><img src="/../pic/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86%E7%82%B9/1657890300277.png" alt="1657890300277"></p><h4 id="与数据库比较"><a href="#与数据库比较" class="headerlink" title="与数据库比较"></a>与数据库比较</h4><ul><li>类似的查询语句；</li><li>数据存储在HDFS；</li><li>数据更新不建议改写；</li><li>执行延迟较高，需要将hql转换为Map Reduce跑job</li><li>数据规模很大；</li></ul><h4 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token punctuation">[</span>EXTERNAL<span class="token punctuation">]</span> <span class="token keyword">TABLE</span> <span class="token punctuation">[</span><span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span><span class="token punctuation">]</span> table_name <span class="token operator">/</span> <span class="token operator">*</span>创建<span class="token punctuation">[</span>外部<span class="token punctuation">]</span>表<span class="token operator">*</span> <span class="token operator">/</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>col_name data_type <span class="token punctuation">[</span><span class="token keyword">COMMENT</span> col_comment<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">COMMENT</span> table_comment<span class="token punctuation">]</span><span class="token punctuation">[</span>PARTITIONED <span class="token keyword">BY</span> <span class="token punctuation">(</span>col_name data_type <span class="token punctuation">[</span><span class="token keyword">COMMENT</span> col_comment<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token operator">*</span>分区<span class="token operator">*</span> <span class="token operator">/</span> <span class="token punctuation">[</span><span class="token keyword">CLUSTERED</span> <span class="token keyword">BY</span> <span class="token punctuation">(</span>col_name<span class="token punctuation">,</span> col_name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token operator">*</span>分桶表<span class="token operator">*</span> <span class="token operator">/</span> <span class="token punctuation">[</span>SORTED <span class="token keyword">BY</span> <span class="token punctuation">(</span>col_name <span class="token punctuation">[</span><span class="token keyword">ASC</span><span class="token operator">|</span><span class="token keyword">DESC</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">INTO</span> num_buckets BUCKETS<span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token operator">*</span>桶内排序<span class="token operator">*</span> <span class="token operator">/</span> <span class="token punctuation">[</span><span class="token keyword">ROW</span> FORMAT row_format<span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token operator">*</span>格式化表<span class="token operator">*</span> <span class="token operator">/</span> <span class="token punctuation">[</span>STORED <span class="token keyword">AS</span> file_format<span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token operator">*</span>指定存储文件类型<span class="token operator">*</span> <span class="token operator">/</span> <span class="token punctuation">[</span>LOCATION hdfs_path<span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token operator">*</span>指定表在HDFS的路径<span class="token operator">*</span> <span class="token operator">/</span> <span class="token punctuation">[</span>TBLPROPERTIES <span class="token punctuation">(</span>property_name<span class="token operator">=</span>property_value<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token operator">*</span><span class="token operator">*</span> <span class="token operator">/</span> <span class="token punctuation">[</span><span class="token keyword">AS</span> select_statement<span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token operator">*</span>根据查询结果创建表<span class="token operator">*</span> <span class="token operator">/</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"> <span class="token operator">/</span> <span class="token operator">*</span>格式化表种类<span class="token operator">*</span> <span class="token operator">/</span> DELIMITED <span class="token punctuation">[</span><span class="token keyword">FIELDS</span> <span class="token keyword">TERMINATED</span> <span class="token keyword">BY</span> <span class="token keyword">char</span><span class="token punctuation">]</span>  <span class="token operator">/</span> <span class="token operator">*</span>指定分隔符<span class="token operator">*</span> <span class="token operator">/</span> <span class="token punctuation">[</span>COLLECTION ITEMS <span class="token keyword">TERMINATED</span> <span class="token keyword">BY</span> <span class="token keyword">char</span><span class="token punctuation">]</span><span class="token punctuation">[</span>MAP <span class="token keyword">KEYS</span> <span class="token keyword">TERMINATED</span> <span class="token keyword">BY</span> <span class="token keyword">char</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">LINES</span> <span class="token keyword">TERMINATED</span> <span class="token keyword">BY</span> <span class="token keyword">char</span><span class="token punctuation">]</span><span class="token operator">|</span>SERDE serde_name<span class="token punctuation">[</span><span class="token keyword">WITH</span> SERDEPROPERTIES <span class="token punctuation">(</span>property_name<span class="token operator">=</span>property_value<span class="token punctuation">,</span> property_name<span class="token operator">=</span>property_value<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="内部-管理-表和外部表external"><a href="#内部-管理-表和外部表external" class="headerlink" title="内部(管理)表和外部表external"></a>内部(管理)表和外部表external</h4><p>元数据：指向原始数据的路径；原始数据：数据的存储位置</p><table><thead><tr><th></th><th>内部表</th><th>外部表</th></tr></thead><tbody><tr><td>创建</td><td>移动原始数据</td><td>路径记录到元数据</td></tr><tr><td>删除</td><td>元 &#x2F; 原始数据都删</td><td>只删除元数据</td></tr></tbody></table><h4 id="四个By"><a href="#四个By" class="headerlink" title="四个By"></a>四个By</h4><ul><li>Order By：全局排序，只有一个Reducer；</li><li>Sort By：分区内有序；</li><li>Distrbute By：根据指定字段进行分区，将数据划分到不同reduce中，结合sort by使用,distrbute by 在前（例如按学院编号分区，学生学号排序）；</li><li>Cluster By：当Distribute by和Sorts by字段相同时，可以使用Cluster by方式，只能升序；</li></ul><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li>nvl(val,def_val):返回非空值否则null；</li><li>coalesce(v1,v2,…):返回第一个非空值否则null；</li><li>CASE WHEN THEN ELSE END ：多分支；</li><li>grouping_set:多维分析；</li><li>cast(col as type):格式转换;</li></ul><h5 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h5><ul><li>unix_timestamp:返回当前或指定时间的时间戳；</li><li>year &#x2F; month &#x2F; day &#x2F; hour &#x2F; minute &#x2F; second &#x2F; week:年月日时分秒周；</li><li>datediff：两个日期相差的天数；</li><li>date_add：日期加减天数；</li><li>add_months：日期加减月；</li><li>next_day(date,week): 下周几的日期；</li><li>last_day:当月最后一天；</li><li>date_format(): 格式化日期；</li></ul><h5 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h5><ul><li>round： 四舍五入；</li><li>ceil：  向上取整；</li><li>floor： 向下取整；</li><li>rand:随机数；</li></ul><h5 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h5><ul><li>upper： 转大写；</li><li>lower： 转小写；</li><li>length： 长度；</li><li>trim：  前后去空格；</li><li>reverse：反转；</li><li>concat:字符串连接；</li><li>concat_ws:带分隔符字符串连接（只接受string or array<string>）；</li><li>substr:字符串截取；</li><li>get_json_object(string json_string, string path)：解析json函数；</li><li>regexp_replace：使用正则表达式匹配目标字符串，匹配成功后替换；</li></ul><h5 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h5><ul><li>size： 集合中元素的个数；</li><li>spilt:按照指定字符切割返回字符串数组；</li><li>map_keys &#x2F; map_values： 返回map中的key &#x2F; value；</li><li>array_contains: 判断array中是否包含某个元素；</li><li>collect_set(col) &#x2F; collect_list() : 返回去重 &#x2F; 不去重后的汇总array (接受基本数据类型)；</li><li>explode：将array或map炸裂成多行（如果想要与原字段关联需要用到lateral view侧表）；</li><li>LATERAL VIEW udtf(expression) tableAlias AS columnAlias:udtf函数与原字段关联所需，在from表后；</li></ul><h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><ul><li><a href="https://blog.csdn.net/hello_java_lcl/article/details/106690120">更多</a></li><li><a href="https://cwiki.apache.org/confluence/display/Hive//LanguageManual">官网</a></li></ul><h4 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h4><h5 id="rank排名函数"><a href="#rank排名函数" class="headerlink" title="rank排名函数"></a>rank排名函数</h5><ul><li>RANK() 排序相同时会重复，总数不会变(113)；</li><li>DENSE_RANK() 排序相同时会重复，总数会减少(112)；</li><li>ROW_NUMBER() 会根据顺序计算(123)；</li></ul><h5 id="over-窗口大小"><a href="#over-窗口大小" class="headerlink" title="over()窗口大小"></a>over()窗口大小</h5><ul><li>current row:当前行；</li><li>n preceding &#x2F; following：往前 &#x2F; 后几行；</li><li>unbounded:起点，unbounded preceding：从前面起点，unbounded following：到后面终点；</li><li>LAG &#x2F; LEAD(col,n):往前 &#x2F; 后第n行数据；</li><li>ntile(n):将数据分成n块；</li></ul><h5 id="例"><a href="#例" class="headerlink" title="例"></a>例</h5><p>rank() over(partition by col1,col2 order by col1 desc,col3 asc rows between … and …)</p><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><ul><li>UDF：一进一出；</li><li>UDAF：聚集函数，多进一出（max,rank）；</li><li>UDTF： 一进多出;<ol><li>udtf -&gt; 重写3个方法：a. initialize（自定义输出的列名和类型）b. process（将结果返回forward(result)）c. close ;</li><li>上传jar包到hive的classpath下</li><li>创建函数</li><li>使用函数</li></ol></li></ul><h4 id="DML数据操作"><a href="#DML数据操作" class="headerlink" title="DML数据操作"></a>DML数据操作</h4><h5 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h5><ul><li>load data [local] inpath ‘数据的 path’ [overwrite] into table tab_name [partition (partcol1&#x3D;val1,…)]; -&gt;装载数据</li><li>insert [overwrite|into] table tab_name partition(partcol1&#x3D;val1) &lt;查询语句&gt;；-&gt;通过查询插入数据</li><li>create table if not exists tab_name as select；-&gt;建表时加载数据</li><li>location ‘Path’ ;-&gt;建表时指定数据路径</li><li>import table tab_name from ‘Path’; -&gt;export导出后，Import导入</li></ul><h5 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h5><ul><li>insert overwrite [local] directory ‘Path’ &lt;查询语句&gt; ；-&gt;insert导出</li><li>Hadoop中原始数据导出到本地</li><li>hive -f &#x2F; -e 执行语句或者脚本 &gt; file ；-&gt; Linux追加到文件</li><li>export table tab_name to ‘Path’; -&gt;两个 Hadoop 平台集群之间 Hive 表迁移</li><li>Sqoop 导出</li></ul><h4 id="hive优化"><a href="#hive优化" class="headerlink" title="hive优化"></a>hive优化</h4><h5 id="explain查看执行计划"><a href="#explain查看执行计划" class="headerlink" title="explain查看执行计划"></a>explain查看执行计划</h5><p>EXPLAIN [EXTENDED…] query-sql 查看sql[详细]执行计划</p><p>show partitions|functions name 查看分区表|函数情况</p><h5 id="建表（分区-x2F-桶-存储格式-压缩）"><a href="#建表（分区-x2F-桶-存储格式-压缩）" class="headerlink" title="建表（分区 &#x2F; 桶,存储格式,压缩）"></a>建表（分区 &#x2F; 桶,存储格式,压缩）</h5><ol><li><p>分区表</p><p>对应HDFS上的独立文件夹，分区就是分目录；</p><p>分区字段不能是表中存在的数据，可以看作时表的伪列；</p><p>查询时通过where查询指定分区，效率无敌！；</p><ol><li><p>创建</p><p>建表时加入partitioned by (col string)；</p><p>分区表加载数据时，必须指定分区；</p></li><li><p>二级分区</p><p>分区字段增加一个</p></li><li><p>动态分区</p><p>对分区表insert数据时，数据库会根据分区字段将数据插入对应分区。</p><p>配置：开启动态分区功能、设置为非严格模式、在每个 &#x2F; 所有MR节点可以创建多少动态分区、MR Job中，最大可以创建多少个HDFS文件。例：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">table</span> tab_name <span class="token keyword">partition</span><span class="token punctuation">(</span>loc<span class="token punctuation">)</span> <span class="token keyword">select</span> col1<span class="token punctuation">,</span> loc <span class="token keyword">from</span> dept<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol></li><li><p>分桶表</p><p>分区针对的是数据的存储路径，分桶针对的是数据文件。</p><ol><li><p>创建</p><p>建表时加入 clustered by(id) into 4 buckets；</p><p>reduce个数设置-1或大于等于分桶数，</p></li><li><p>抽样查询</p><p><code>TABLESAMPLE(BUCKET x OUT OF y)</code> ：x&lt;&#x3D;y</p></li></ol></li><li><p>文件格式</p><ol><li><p>列式存储和行式存储</p><p>行存储更适合查询一整行数据的情况；</p><p>列存储是个查询只需要少数字段情况，由于每个字段数据类型相同，所以更适合压缩；</p></li><li><p>TextFile格式</p><p>默认格式，数据不做压缩耗费资源；行式存储</p></li><li><p>Orc格式</p><p>列式存储</p></li><li><p>Parquet格式</p><p>以二进制方式存储，文件包括数据和元数据；列式存储</p></li></ol></li><li><p>压缩格式</p><table><thead><tr><th>压缩格式</th><th>切片</th></tr></thead><tbody><tr><td>DEFLATE</td><td>否</td></tr><tr><td>Gzip</td><td>否</td></tr><tr><td>bzip2</td><td>是</td></tr><tr><td>LZO</td><td>是</td></tr><tr><td>Snappy</td><td>否</td></tr></tbody></table></li></ol><h5 id="语法优化"><a href="#语法优化" class="headerlink" title="语法优化"></a>语法优化</h5><ul><li><p>多重插入</p><p>如果导入数据时遇到多条sql模式相同并且从同一个表扫描，可以使用多重插入，一次读取，多次插入。</p></li><li><p>行列过滤</p><p>行处理：使用外连接时将副表的过滤条件写到on(副表的查询)中，否则会先全表关联，在进行过滤。</p><p>列处理:只拿需要的列，少用select *，只读取需要的分区。</p></li><li><p>in &#x2F; exists语句</p><p>在sql中多用exists，在hive中用left semi join 实现会更好。</p></li><li><p>小表、大表join(MapJOIN)</p><p>默认开启；</p><p>MAPJION会把小表全部读入内存中，在map阶段直接拿另外一个表的数据和内存中表数据做匹配，由于在map是进行了join操作，省去了reduce运行的效率也会高很多</p></li><li><p>大表、大表Join</p><p>a.空key过滤：如果join条件中有key为异常数据，则条件过滤；</p><p>b.空key转换：可以表中 key 为空的字段赋一个随机的值</p><p>c.SMB：分桶表join</p></li><li><p>笛卡尔积</p><p>join不加on条件或者无效，会使用1个reduce完成笛卡尔积，设置为严格模式，不允许出现笛卡尔积</p></li><li><p>Count(distinct) </p><p>此操作需要一个reduce task完成，可以用group by + count 替换</p></li><li><p>union(去重) union all (不去重)</p></li></ul><h5 id="job优化"><a href="#job优化" class="headerlink" title="job优化"></a>job优化</h5><ol><li><p>map优化</p><p>MapTask数&#x3D;文件数，尽量减少小文件；</p><p>a. 小文件进行合并：在Map前合并小文件(CombineHiveInputFormat)、在输出合并小文件（merge）；</p><p>b. 复杂文件增加Map数：当input的文件都很大，任务逻辑复杂，可以增加Map数(使每个map处理的数据量减少，减小max可以增加map数，增大max可以减少map数)；</p><p>c. 开启map端聚合combiner（不影响最终业务逻辑）；</p></li><li><p>reduce优化</p><p>一个reduce会生成一个文件，启动和初始化也会消耗时间；</p><p>处理大数据量利用合适的Reduce数；使单个Reduce任务处理数据量大小要合适；</p></li><li><p>整体优化</p><p>a.Fetch抓取：在某些情况不会使用MR计算；</p><p>b.小数据集使用本地模式( set hive.exec.mode.local.auto&#x3D;true;)；</p><p>c.数据量大使用并行执行(set hive.exec.parallel&#x3D;true;)；</p><p>d.严格模式(hive.strict.checks)：分区表使用分区过滤、order by 指定limit、笛卡尔积</p><p>e.小文件过多JVM重用</p><p>f.压缩</p></li></ol><h4 id="数据倾斜-1"><a href="#数据倾斜-1" class="headerlink" title="数据倾斜"></a>数据倾斜</h4><p>少数任务相比下执行很慢。</p><h5 id="单表"><a href="#单表" class="headerlink" title="单表"></a>单表</h5><ol><li>Group by -&gt; 进行负载均衡(set hive.groupby.skewindata &#x3D; true;)、map端进行聚合(hive.map.aggr)</li><li>多个相同key导致 -&gt;增加Reduce数量、自定义分区器、加随机数或过滤</li></ol><h5 id="Join数据倾斜优化"><a href="#Join数据倾斜优化" class="headerlink" title="Join数据倾斜优化"></a>Join数据倾斜优化</h5><ol><li>MapJoin,将小表读入内存；</li><li>使用参数：如果join的键对应的记录数超过(hive.skewjoin.key)则进行分拆</li></ol><h4 id="hive分隔符和空值"><a href="#hive分隔符和空值" class="headerlink" title="hive分隔符和空值"></a>hive分隔符和空值</h4><p>在建表时通过<code>FIELDS TERMINATED BY</code> 指定分割符；</p><p>null实际在HDFS中默认存储为’\N’；可以自定义底层用什么表示null；判断使用a is null 或者 a&#x3D;’\N’；处理使用nvl,case,coalcsce；</p><h4 id="引擎对比"><a href="#引擎对比" class="headerlink" title="引擎对比"></a>引擎对比</h4><p>Mr引擎：多job串联，基于磁盘，落盘的地方比较多;</p><p>Spark引擎：Shuffle过程中落盘,兼顾了可靠性和效率;</p><p>Tez引擎：完全基于内存，将多个有依赖的作业转换为一个作业，只需写一次HDFS。</p><hr><h3 id="Sqoop"><a href="#Sqoop" class="headerlink" title="Sqoop"></a>Sqoop</h3><h4 id="sqoop参数"><a href="#sqoop参数" class="headerlink" title="sqoop参数"></a>sqoop参数</h4><pre class="line-numbers language-sqoop" data-language="sqoop"><code class="language-sqoop">&#x2F;opt&#x2F;module&#x2F;sqoop&#x2F;bin&#x2F;sqoop import \--connect \--username \--password \--target-dir \--delete-target-dir \--num-mappers \--fields-terminated-by   \--query   &quot;$2&quot; &#39; and $CONDITIONS;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="导入导出null存储一致性"><a href="#导入导出null存储一致性" class="headerlink" title="导入导出null存储一致性"></a>导入导出null存储一致性</h4><p>hive中null底层表示为’\N’ ，mysql中表示为Null，为保持导入 &#x2F; 出一致：</p><p>导入-&gt;–null-string和–null-non-string</p><p>导出-&gt;–input-null-string和–input-null-non-string</p><h4 id="数据导出一致性"><a href="#数据导出一致性" class="headerlink" title="数据导出一致性"></a>数据导出一致性</h4><p>指导出部分成功数据导致数据出错，使用–staging-table 充当用于暂存导出数据的辅助表以解决</p><h4 id="导出Parquet"><a href="#导出Parquet" class="headerlink" title="导出Parquet"></a>导出Parquet</h4><p>如果是列式存储则不能直接导出。</p><ol><li>创建临时表保存parquet</li><li>将临时表导出</li></ol><hr><h3 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h3><hr><h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><ul><li>变量和数据类型以及隐式转换（var 变量val 常量）</li><li>流程控制（if-else、for、while）以及模式匹配（switch case  样例类）</li><li>函数式编程(高阶函数、匿名函数、函数柯里化、函数参数以及函数至简原则、闭包)</li><li>面向对象(特质-&gt;第一个用extends后面用with；apply)</li><li>集合（List，Array，Map及函数）</li><li>异常及泛型</li></ul><p><img src="/../pic/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86%E7%82%B9/1657890327787.png" alt="Scala隐式转换"></p><hr><h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><p>解决海量数据的分析计算；先申请资源，在进行计算；</p><h4 id="运行框架"><a href="#运行框架" class="headerlink" title="运行框架"></a>运行框架</h4><p><img src="/../pic/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86%E7%82%B9/1657890365501.png" alt="Spark"></p><ol><li>构建Application环境，申请资源；</li><li>启动Executor,与Cluster Manager维持心跳；</li><li>Spark Context构建DAG，将 DAG 图分解成多个 Stage,任务调度器将task分发；</li><li>Executor执行任务；</li></ol><h5 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h5><ul><li>将用户程序转化为作业（job）</li><li>在 Executor 之间调度任务(task)</li><li>跟踪Executor 的执行情况</li><li>通过UI 展示查询运行情况</li><li>算子以外的代码都是在Driver 端执行</li></ul><h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h5><ul><li>运行在工作节点（Worker）中的一个JVM 进程，是整个集群中的专门用于计算的节点；</li><li>RDD 直接缓存 Executor 进程内；</li><li>算子里面的代码都是在Executor 端执行</li></ul><h5 id="Master-amp-Worker"><a href="#Master-amp-Worker" class="headerlink" title="Master &amp; Worker"></a>Master &amp; Worker</h5><p>独立部署环境中</p><ul><li>Master是一个进程，负责资源的调度和分配，并进行集群的监控等；</li><li>Worker 运行在集群中的一台服务器上，由 Master 分配资源对数据进行并行的处理和计算；</li></ul><h5 id="ApplicationMaster"><a href="#ApplicationMaster" class="headerlink" title="ApplicationMaster"></a>ApplicationMaster</h5><p>用于向资源调度器申请Container容器，资源与计算的解耦；</p><h4 id="Spark运行模式"><a href="#Spark运行模式" class="headerlink" title="Spark运行模式"></a>Spark运行模式</h4><ul><li>Local：运行在一台机器上。 测试用。</li><li>Standalone：是Spark自身的一个调度系统。 </li><li>Yarn：采用Hadoop的资源调度器</li></ul><h4 id="Spark常用端口号"><a href="#Spark常用端口号" class="headerlink" title="Spark常用端口号"></a>Spark常用端口号</h4><ul><li>4040:spark-shell 任务端口</li><li>7077：内部通讯端口</li><li>8080：任务执行的端口</li><li>18080：历史服务器</li></ul><h4 id="RDD五大属性"><a href="#RDD五大属性" class="headerlink" title="RDD五大属性"></a>RDD五大属性</h4><p>rdd主要是将逻辑封装，生成task发送到executor执行计算</p><ol><li><p>分区列表</p><p>rdd是被分区的，每个分区都会被一个计算任务(Task)处理，用于执行任务时并行计算；</p></li><li><p>每个分区都有计算函数</p><p>使用分区函数对每个分区计算；</p></li><li><p>基于其他rdd的列表</p><p>rdd之间的依赖关系(血缘)：宽依赖(有shuffle)和窄依赖(每个上游rdd最多被下游的一个分区使用-&gt;独生子女)；</p></li><li><p>key-value数据类型的分区器</p><p>当数据为 KV 时，可以通过(Hash分区 &#x2F; Range分区 &#x2F; 用户自定义分区)指定分区；</p></li><li><p>首选位置</p><p>计算数据时，可以根据计算节点的状态选择不同的节点位置进行计算；</p></li></ol><h4 id="RDD转换算子"><a href="#RDD转换算子" class="headerlink" title="RDD转换算子"></a>RDD转换算子</h4><p>value: map &#x2F; mapPartitions &#x2F; mapPartitionsWithIndex &#x2F; flatMap &#x2F; glom &#x2F; groupBy &#x2F; filter &#x2F; sample &#x2F; distinct &#x2F; coalesce &#x2F; repartition &#x2F; sortBy</p><p>双value：intersection &#x2F; union &#x2F; subtract &#x2F; zip</p><p>key-value: partitionBy &#x2F; reduceByKey &#x2F; groupByKey &#x2F; aggregateByKey &#x2F; foldByKey &#x2F; combineByKey &#x2F; sortByKey &#x2F; join &#x2F; leftOuterJoin &#x2F; cogroup</p><h4 id="RDD行动算子"><a href="#RDD行动算子" class="headerlink" title="RDD行动算子"></a>RDD行动算子</h4><p>reduce &#x2F; collect &#x2F; count &#x2F; first &#x2F; take &#x2F; takeOrdered &#x2F; aggregate &#x2F; fold &#x2F; countByKey &#x2F; foreach &#x2F; save相关</p><p>当spark与数据库操作时，由于数据算子内的操作都是在executor端做的，所以需要有闭包的问题，可以使用foreachPartition代替foreach，在前者中获取数据库连接，那样只需要在一个分区内连接一次了。</p><h4 id="RDD-序列化"><a href="#RDD-序列化" class="headerlink" title="RDD 序列化"></a>RDD 序列化</h4><p>在函数式编程中算子内会用到算子外的数据，形成闭包的效果，由于算子里面的代码都是在Executor端执行的，所以要将数据发送到Executor中，所以需要序列化。</p><p>Kryo 序列化框架：</p><pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token comment">// 替换默认的序列化机制</span><span class="token punctuation">.</span>set<span class="token punctuation">(</span><span class="token string">"spark.serializer"</span><span class="token punctuation">,</span><span class="token string">"org.apache.spark.serializer.KryoSerializer"</span><span class="token punctuation">)</span><span class="token comment">// 注册需要使用 kryo 序列化的自定义类</span><span class="token punctuation">.</span>registerKryoClasses<span class="token punctuation">(</span>Array<span class="token punctuation">(</span>classOf<span class="token punctuation">[</span>Searcher<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>序列化需要继承Serializable 接口</p><h4 id="RDD-持久化"><a href="#RDD-持久化" class="headerlink" title="RDD 持久化"></a>RDD 持久化</h4><ul><li><p>cache:将数据存储在磁盘、内存等，不切断血缘依赖；</p></li><li><p>checkpoint：将数据存储在HDFS等高可用的文件系统，切断血缘关系；</p><pre class="line-numbers language-scala" data-language="scala"><code class="language-scala">rdd<span class="token punctuation">.</span>cache<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//rdd默MEMORY_ONLY</span>df<span class="token punctuation">.</span>cache<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//dataframe默MEMORY_AND_DISK</span><span class="token comment">// 设置检查点路径</span>sc<span class="token punctuation">.</span>setCheckpointDir<span class="token punctuation">(</span><span class="token string">"./checkpoint1"</span><span class="token punctuation">)</span>rdd<span class="token punctuation">.</span>checkpoint<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>建议对checkpoint()的RDD 使用Cache 缓存</p></li></ul><h4 id="累加器"><a href="#累加器" class="headerlink" title="累加器"></a>累加器</h4><p>将Executor 端变量信息聚合到Driver 端。</p><h5 id="系统累加器"><a href="#系统累加器" class="headerlink" title="系统累加器"></a>系统累加器</h5><ol><li>声明<code>sc.longAccumulator(&quot;name&quot;)</code></li><li>使用<code>acc.add()</code></li><li>取值 <code>acc.value</code></li></ol><h5 id="自定义累加器"><a href="#自定义累加器" class="headerlink" title="自定义累加器"></a>自定义累加器</h5><ol><li>继承 AccumulatorV2，并设定泛型</li><li>重写累加器的抽象方法</li></ol><h4 id="广播变量"><a href="#广播变量" class="headerlink" title="广播变量"></a>广播变量</h4><p>向所有工作节点发送一个较大的只读值。</p><ol><li>声明：<code>sc.broadcast(较大的对象)</code></li><li>使用：<code>broadcast.value</code></li></ol><h4 id="任务的划分"><a href="#任务的划分" class="headerlink" title="任务的划分"></a>任务的划分</h4><ul><li>Application：初始化一个SparkContext即生成一个Application；</li><li>Job：一个Action算子就会生成一个Job；</li><li>Stage：Stage等于宽依赖的个数加1；</li><li>Task：一个Stage阶段中，最后一个RDD的分区个数就是Task的个数。</li></ul><h4 id="RDD、DataFrame、DataSet三者的转换"><a href="#RDD、DataFrame、DataSet三者的转换" class="headerlink" title="RDD、DataFrame、DataSet三者的转换"></a>RDD、DataFrame、DataSet三者的转换</h4><p><img src="/../pic/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86%E7%82%B9/1657890061950.png" alt="RDD-DataFrame-DataSet"></p><ul><li>DataFrame每一行的类型固定为Row，通过解析可以获取各个字段值；</li><li>DataSet每一行的类型是不一定的，通过getAS方法或者模式匹配拿出特定字段；</li></ul><h4 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h4><h5 id="参数调整"><a href="#参数调整" class="headerlink" title="参数调整"></a>参数调整</h5><ul><li>auto.offset.reset -&gt; earliest 从最初始偏移量开始消费数据；</li><li>spark.streaming.kafka.maxRatePerPartition 从kafka分区每秒拉取的条数(延迟)；</li><li>spark.streaming.backpressure.enabled 背压机制，根据延迟动态消费Kafka数据；</li><li>spark.streaming.stopGracefullyOnShutdown 在JVM关闭时正常StreamingContext;</li><li>默认分区数与对接Kafka topic 分区个数一致；</li><li>一个stage耗时由最慢task决定；</li></ul><h5 id="Kafka数据源"><a href="#Kafka数据源" class="headerlink" title="Kafka数据源"></a>Kafka数据源</h5><p>Receiver：需要一个专门executor接收数据然后发到计算executor中，接收数据的Executor和计算的Executor 速度会有所不同，可能会导致内存溢出；</p><p>Direct：使用Kafka的api，Spark Streaming自己就负责追踪消费的offset，并保存在checkpoint中。可以保证数据消费一次且仅消费一次。</p><h5 id="无状态-x2F-有状态转换"><a href="#无状态-x2F-有状态转换" class="headerlink" title="无状态&#x2F;有状态转换"></a>无状态&#x2F;有状态转换</h5><ul><li><p>transform</p><p>将DStream转换为rdd操作；</p></li><li><p>UpdateStateByKey</p><p>需要对检查点目录进行配置，会使用检查点来保存状态；</p></li><li><p>WindowOperations</p><p>在原来SparkStreaming计算批次上封装，增加窗口时长以及滑动步长：必须为采集周期大小的整数倍；</p></li></ul><h4 id="Spark-数据倾斜"><a href="#Spark-数据倾斜" class="headerlink" title="Spark 数据倾斜"></a>Spark 数据倾斜</h4><ul><li><p>表现</p><p>部分任务极慢，任务卡在某个阶段不能结束，任务突然失败</p></li><li><p>原因</p><p>数据激增，Key分布不均，建表连接性差；</p></li><li><p>思路</p><p>数据预处理，异常值过滤；</p><p>数据激增可以单独对这部分数据做两次MR先打散在聚合；</p><p>优化代码逻辑，优化sql(每个行动算子都会增加job,每次shuffle都会增加一个阶段)、调参(Hadoop切片、预聚合、合并，hive中MapJoin等)；</p></li><li><p>定位数据倾斜</p><ol><li>通过web UI或者日志查看task运行情况，定位是哪个stage出现问题；</li><li>代码中在spark或sparkSQL中出现shuffle语言，那么就可以分出前后两个stage，定位出现问题的stage，优化代码逻辑。</li></ol></li><li><p>方法</p><ul><li>hive中ETL处理数据(在hive中预先将key聚合，spark对预处理的hive表操作) -&gt;提升性能但是在hive ETL中还是会倾斜；</li><li>过滤掉少数导致倾斜的key(filter&#x2F;where) -&gt; 适用于倾斜的key少并且对计算本身影响不大的情况;</li><li>提高shuffle操作的并行度(在执行shuffle算子的时候传入参数设置spark.sql.shuffle.partitions，代表了并行度，默认200)-&gt;适用于相同key数据不多情况；</li><li>两阶段聚合（局部聚合+全局聚合）先将key打上随机数前缀后聚合，然后将前缀去掉全局聚合 -&gt; 适用于聚合类的shuffle操作；</li><li>将reduce join转为map join(将较小的rdd直接collect拉到内存，然后对其创建广播变量，遍历较大的rdd与变量合并) -&gt; 适用于大表和小表join的情况；</li><li>将倾斜key打散加前缀join后union合并（采样倾斜key过滤出作为新rdd并加上n以内的随机前缀,将需要join的另一个rdd也过滤出倾斜key膨胀并加上前缀，之后两个rdd进行join；另外两个正常rdd照常join后union合并得到最终join结果）(将另一个rdd膨胀是为了与倾斜key的随机前缀连接上) -&gt; 少量Key倾斜；</li><li>使用随机前缀和扩容RDD进行join（同上但对整个rdd扩容）-&gt; 缓解数据倾斜，对内存资源要求高；</li></ul><p>将多种方案结合：a-&gt;b-&gt;c-&gt;(d&#x2F;e&#x2F;f&#x2F;g)</p></li></ul><hr><p>Flink</p><hr><h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><hr><h3 id="手写HQL"><a href="#手写HQL" class="headerlink" title="手写HQL"></a>手写HQL</h3><h4 id="用户行为路径"><a href="#用户行为路径" class="headerlink" title="用户行为路径"></a>用户行为路径</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>统计每次跳转的次数使用桑基图展示。</p><ul><li>用户访问路径的可视化通常使用桑基图。如下图所示，该图可真实还原用户的访问路径，包括页面跳转和页面访问次序。</li><li>桑基图需要我们提供每种页面跳转的次数，每个跳转由source&#x2F;target表示，source指跳转起始页面，target表示跳转终到页面。</li><li>注意：<ul><li>source不允许为空，但target可为空</li><li>桑基图所展示的流程不允许存在环</li></ul></li></ul><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>对source，target分组即可，为了不存在环，将每个用户的访问加前缀以确定步骤。</p><h5 id="语句实现"><a href="#语句实现" class="headerlink" title="语句实现"></a>语句实现</h5><h4 id="用户变动统计"><a href="#用户变动统计" class="headerlink" title="用户变动统计"></a>用户变动统计</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>统计截至本日流失用户和回流用户的人数</p><ul><li>流失用户：末次活跃时间为7日前的用户</li><li>回流用户：末次活跃时间为今日，上次活跃时间在8日前的用户</li></ul><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>流失用户数量为截至今日用户最后登录时间为七天前；</p><p>回流用户数量为截至今日为用户最后登录时间且昨天最后登录时间为八天前；</p><h5 id="语句实现-1"><a href="#语句实现-1" class="headerlink" title="语句实现"></a>语句实现</h5><h4 id="连续问题"><a href="#连续问题" class="headerlink" title="连续问题"></a>连续问题</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>统计连续3天及以上减少碳排放量在100以上的用户</p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><ol><li>按照用户和时间分组求每个用户每天减少碳排量的数量并过滤排放量在100以上；</li><li>按照时间求每个用户的rank；</li><li>将时间减去排名如果相同则时间连续(等差数列)；</li><li>按照用户和时间(等差列)分组求数量大于等于3的记录；</li></ol><h5 id="语句实现-2"><a href="#语句实现-2" class="headerlink" title="语句实现"></a>语句实现</h5><h4 id="分组问题"><a href="#分组问题" class="headerlink" title="分组问题"></a>分组问题</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p>用户连续访问记录时间间隔如果小于60秒，则分为同一组，输出用户的组号。</p><h5 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h5><ol><li>计算上次访问时间与本次访问时间差如果小于60秒，则计数为0，否则为1；</li><li>求和开窗计算用户的计数；</li></ol><h5 id="语句实现-3"><a href="#语句实现-3" class="headerlink" title="语句实现"></a>语句实现</h5><h4 id="间隔连续问题"><a href="#间隔连续问题" class="headerlink" title="间隔连续问题"></a>间隔连续问题</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>计算每个用户最大的连续登录天数，可以间隔一天。解释：如果一个用户在1,3,5,6登录游戏，则视为连续6天登录。</p><h5 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h5><ol><li>计算上次登录时间与本次登录时间相差天数diff_time；</li><li>如果diff_time&lt;2则为连续登录(分为同一组)，否则重新计数(登录时间超过两天)；</li><li>统计用户在同一组的连续登陆天数(最大时间-最小时间+1)；</li><li>取连续登录天数的最大值；</li></ol><h5 id="语句实现-4"><a href="#语句实现-4" class="headerlink" title="语句实现"></a>语句实现</h5><h4 id="打折日期交叉问题"><a href="#打折日期交叉问题" class="headerlink" title="打折日期交叉问题"></a>打折日期交叉问题</h4><h5 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h5><p> 计算每个品牌总的打折销售天数，注意其中的交叉日期，比如vivo品牌，第一次活动时间为2021-06-05到2021-06-15，第二次活动时间为2021-06-09到2021-06-21其中9号到15号为重复天数，只统计一次，即vivo总打折天数为2021-06-05到2021-06-21共计17天。</p><h5 id="思路分析-5"><a href="#思路分析-5" class="headerlink" title="思路分析"></a>思路分析</h5><ol><li>由于有时间重复，如果某品牌上一个活动的结束日期比下一个活动开始时间大（时间重复），则将下一个活动的开始时间设置为上一个活动结束日期加一（将两个活动时间连接起来）否则没有时间重复问题；</li><li>计算每次活动天数：结束日期-开始日期+1(如果为负数则说明上一个活动时间包括了本次时间，不用加入统计)；</li><li>按照品牌求和活动天数；</li></ol><h5 id="语句实现-5"><a href="#语句实现-5" class="headerlink" title="语句实现"></a>语句实现</h5><h4 id="同时在线问题"><a href="#同时在线问题" class="headerlink" title="同时在线问题"></a>同时在线问题</h4><h5 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h5><p>计算出平台最高峰同时在线的主播人数。</p><h5 id="思路分析-6"><a href="#思路分析-6" class="headerlink" title="思路分析"></a>思路分析</h5><ol><li>可以将开始时间认为人数+1，结束时间人数-1；</li><li>按照时间排序，求截至当前时间的人数cnt_s；</li><li>求最大的cnt_s即为所求；</li></ol><h5 id="语句实现-6"><a href="#语句实现-6" class="headerlink" title="语句实现"></a>语句实现</h5><hr><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>索引是一个单独的、存储在磁盘上的数据库结构，包含对数据表里所有记录的引用指针。使用索引可以快速找到在某个或多个列中有一特定值的行。</p><h4 id="索引失效常见情况"><a href="#索引失效常见情况" class="headerlink" title="索引失效常见情况"></a>索引失效常见情况</h4><ul><li>没有符合最左前缀原则；1、2、3</li><li>字段进行了隐私数据类型转换；4、5、6</li><li>走索引没有全表扫描快；7</li></ul><ol><li>sql语句中有or关键字；</li><li>复合索引未用左列字段;</li><li>like以%开头;</li><li>需要类型转换;</li><li>where中索引列有运算;</li><li>where中索引列使用了函数;</li><li>如果mysql觉得全表扫描更快时（数据少）;</li></ol><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><ul><li><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5></li><li><h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h5></li><li><h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h5></li><li><h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h5></li></ul><h4 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h4><h4 id="Binlog解析工具"><a href="#Binlog解析工具" class="headerlink" title="Binlog解析工具"></a>Binlog解析工具</h4><p>Maxwell是一个能实时读取<a href="https://cloud.tencent.com/product/cdb?from=10680">MySQL</a>二进制日志binlog，并生成 JSON 格式的消息，作为生产者发送给 Kafka，Kinesis、RabbitMQ、Redis、Google Cloud Pub&#x2F;Sub、文件或其它平台的应用程序。</p><hr><h3 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h3><p>面向<strong>分析</strong>的存储系统。</p><h4 id="与数据库区别："><a href="#与数据库区别：" class="headerlink" title="与数据库区别："></a>与数据库区别：</h4><p>数据库是面向事务的设计，数仓是面向<strong>主题</strong>的设计。</p><ul><li>存储：数据库存储在线交易数据，数仓存储一般都是历史数据；</li><li>设计：数据库一般采用符合范式的规则来设计，数仓为了便于查询加入了宽表，虽然增加了冗余但提高了速度；</li><li>目的：数据库为了捕获数据而设计，数仓为了分析数据而设计，他的两个基本元素是维度表和事实表。</li></ul><h4 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h4><h5 id="关系建模"><a href="#关系建模" class="headerlink" title="关系建模"></a>关系建模</h5><p>将数据抽象为两个概念–实体和关系，并用规范化的方式表示出来，关系模型遵守第三范式(表中不允许存在非主属性的传递函数依赖)，数据一致性得到保证。</p><h5 id="维度建模"><a href="#维度建模" class="headerlink" title="维度建模"></a>维度建模</h5><p>以数据分析作为出发点，不遵循第三范式，故存在一定冗余，维度模型面向业务，将业务用事实表和维度表呈现出来。</p><p><strong>维度表</strong>对事实的描述信息，对应世界中的一个对象或者概念，比如日期、地区、用户等；</p><p><strong>事实表</strong>每行数据代表一个业务事件，比如下单、支付、购物车等；</p><h4 id="数仓分层"><a href="#数仓分层" class="headerlink" title="数仓分层"></a>数仓分层</h4><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><ul><li>清晰数据结构：让每个数据层都有自己的作用和职责，在使用和维护时能更快的定位和理解；</li><li>复杂问题简化：将复杂问题拆解成多个步骤完成，每层只解决单一的问题；</li><li>统一数据口径：通过数据分层提供统一的数据出口，统一输出口径；</li><li>减少重复开发：规范数据分层，开发一些通用的中间层，减少重复计算；</li></ul><h5 id="原始数据层ODS"><a href="#原始数据层ODS" class="headerlink" title="原始数据层ODS"></a>原始数据层ODS</h5><p>数据源的数据经过抽取、洗净、传输(ETL)进入本层。</p><ul><li>保持数据原貌不做修改，起到备份数据的作用；</li><li>数据采用压缩，减少磁盘存储；</li><li>创建分区表，防止全表扫描；</li></ul><h5 id="明细数据层DWD"><a href="#明细数据层DWD" class="headerlink" title="明细数据层DWD"></a>明细数据层DWD</h5><ul><li>主要对ODS层的数据做一些清洗和规范化的操作，比如说去除空值、脏数据，脱敏等；</li><li>为了提高数据明细层的易用性，该层通常会采用一些维度退化的方法；</li><li>一般dwd层采用最小粒度以便后续统计细粒度的指标；</li><li>一行数据代表一次业务行为；</li></ul><h5 id="服务数据层DWS"><a href="#服务数据层DWS" class="headerlink" title="服务数据层DWS"></a>服务数据层DWS</h5><p>在DWD层对数据做一些轻微的聚合操作，生成一些列的中间结果表，提升公共指标的复用性，减少重复加工的工作，主要存放主题对象当天的汇总行为。</p><h5 id="数据主题层DWT"><a href="#数据主题层DWT" class="headerlink" title="数据主题层DWT"></a>数据主题层DWT</h5><p>在DWM的基础上，整合汇总成分析某个主题域的宽表，存放所有主题的累计行为。</p><h5 id="DIM层"><a href="#DIM层" class="headerlink" title="DIM层"></a>DIM层</h5><ol><li>选择业务过程；</li><li>声明粒度；</li><li>确定维度；</li><li>确定事实；</li></ol><h5 id="数据应用层ADS"><a href="#数据应用层ADS" class="headerlink" title="数据应用层ADS"></a>数据应用层ADS</h5><p>对主题进行指标分析，提供数据产品和数据分析使用的数据，做可视化展示；</p><h4 id="处理过的业务"><a href="#处理过的业务" class="headerlink" title="处理过的业务"></a>处理过的业务</h4><p>大量sql写到Kafka怎么办</p><p>结构化思维：确定目标，资源分析，制定计划。</p><p>薪资是能力的体现</p><p><img src="/../pic/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86%E7%82%B9/1657890398331.png" alt="1657890398331"></p>]]></content>
      
      
      <categories>
          
          <category> big-data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> big-data </tag>
            
            <tag> hadoop </tag>
            
            <tag> zookeeper </tag>
            
            <tag> flume </tag>
            
            <tag> kafka </tag>
            
            <tag> sqoop </tag>
            
            <tag> hive </tag>
            
            <tag> spark </tag>
            
            <tag> MySQL </tag>
            
            <tag> 离线数仓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kettle使用(1)-更换界面logo和文字</title>
      <link href="/2022/07/10/kettle-1-geng-huan-tu-biao-wen-zi/"/>
      <url>/2022/07/10/kettle-1-geng-huan-tu-biao-wen-zi/</url>
      
        <content type="html"><![CDATA[<h1 id="kettle使用-1-更换界面logo和文字"><a href="#kettle使用-1-更换界面logo和文字" class="headerlink" title="kettle使用(1)-更换界面logo和文字"></a>kettle使用(1)-更换界面logo和文字</h1><p>kettle主要用于ETL，因为操作简单、门槛低被很多企业使用，今天来说一下不修改源码如何更改kettle的logo和其中的文字(包括标题)。</p><p>本文中 <code>kettle安装目录</code> 指代为 <code>%kettle%</code> 。</p><p><strong>在 <code>%kettle%\data-integration\lib\</code> 中找到 <code>kettle-ui-swt-9.3.0.0-428.jar</code> ，使用压缩软件查看。</strong></p><h2 id="修改图标"><a href="#修改图标" class="headerlink" title="修改图标"></a>修改图标</h2><p>替换：自己的图标名称与替换的<strong>名称和扩展名</strong>相同。</p><ul><li>更改logo图标：在<code>ui\images\</code> 找到 <code>spoon.png</code>和 <code>spoon.ico</code> ，将自己的图标按照源文件的像素大小替换(为了更加契合)即可。</li><li>更改tab的图标：在<code>ui\images\</code> 找到 <code>kettle_logo_small.png</code> 和 <code>kettle_logo_small.svg</code> ，注意 <code>svg</code> 格式的文件需要进行格式转换才能得到，在网页中搜索 <code>svg格式转换</code> 转换后替换文件即可。</li><li>启动界面图片：<code>\ui\images\kettle_splash.png</code></li><li>启动界面版本信息：<code>\ui\org\pentaho\di\ui\core\dialog\messages\messages_en_US.properties</code>中的<code>SplashDialog.Version</code><br>启动界面license：<code>\ui\org\pentaho\di\ui\core\dialog\license\license.txt</code></li></ul><p>理论上来说，你在这里找到的图标都可以进行修改替换成自己想要的图片。</p><h2 id="修改文字"><a href="#修改文字" class="headerlink" title="修改文字"></a>修改文字</h2><p>kettle界面中的文字在文件中使用<code>字节码</code>保存的，所以我们在其中搜索和修改都是用<code>字节码</code>格式来进行的，在网页搜索<code>字节码在线转换</code>即可。</p><p>编辑 <code>org\pentaho\di\ui\spoon\messages</code> 下<code>messages_zh_CN.properties</code> ，搜索你要替换的文字，将文字替换即可。标题搜索<code>Spoon.Application.Name</code> 替换内容即可。</p><p>举个例子，现在我将 <code>右键转换弹出的新建</code> 两字替换为 <code>再来一个嘛</code> ：</p><p><img src="/../pic/kettle-1%E6%9B%B4%E6%8D%A2%E5%9B%BE%E6%A0%87%E6%96%87%E5%AD%97/1657431509657.png" alt="1657431509657"></p><ol><li><p>将 <code>新建</code> 转换为<code>ASCII</code>格式 <code>\u65b0\u5efa</code>:</p><p><img src="/../pic/kettle-1%E6%9B%B4%E6%8D%A2%E5%9B%BE%E6%A0%87%E6%96%87%E5%AD%97/1657431563581.png" alt="1657431563581"></p></li><li><p>在<code>messages_zh_CN.properties</code> 中搜索转换后的文字：</p><p><img src="/../pic/kettle-1%E6%9B%B4%E6%8D%A2%E5%9B%BE%E6%A0%87%E6%96%87%E5%AD%97/1657431582300.png" alt="1657431582300"></p><p>注意可能搜索结果不唯一，选择查找结果只有你搜索的内容。</p></li><li><p>将 <code>再来一个嘛</code> 转换为ASCII 格式 <code>\u518d\u6765\u4e00\u4e2a\u561b</code> 后替换：</p><p><img src="/../pic/kettle-1%E6%9B%B4%E6%8D%A2%E5%9B%BE%E6%A0%87%E6%96%87%E5%AD%97/1657431601344.png" alt="1657431601344"></p><p><img src="/../pic/kettle-1%E6%9B%B4%E6%8D%A2%E5%9B%BE%E6%A0%87%E6%96%87%E5%AD%97/1657431620281.png" alt="1657431620281"></p></li><li><p>保存退出查看效果：</p><p><img src="/../pic/kettle-1%E6%9B%B4%E6%8D%A2%E5%9B%BE%E6%A0%87%E6%96%87%E5%AD%97/1657431643972.png" alt="1657431643972"></p></li></ol><p>理论上来说，你在这里找到的文字都可以进行修改替换成自己想要的文字；理论上来说，文字相关的文件都在messages文件夹下。</p><p>更多示例：<a href="http://www.kettle.org.cn/category/demo">kettle示例 – Kettle中文网</a></p>]]></content>
      
      
      <categories>
          
          <category> kettle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kettle </tag>
            
            <tag> ETL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kettle使用(2)-使用sql脚本和Java脚本</title>
      <link href="/2022/07/10/kettle-2-shi-yong-sql-he-java-jiao-ben/"/>
      <url>/2022/07/10/kettle-2-shi-yong-sql-he-java-jiao-ben/</url>
      
        <content type="html"><![CDATA[<h1 id="kettle使用-2-使用SQL和JAVA脚本"><a href="#kettle使用-2-使用SQL和JAVA脚本" class="headerlink" title="kettle使用(2)-使用SQL和JAVA脚本"></a>kettle使用(2)-使用SQL和JAVA脚本</h1><h2 id="kettle中执行SQL脚本"><a href="#kettle中执行SQL脚本" class="headerlink" title="kettle中执行SQL脚本"></a>kettle中执行SQL脚本</h2><ul><li>在转换中需要勾选 <em><strong>执行每一行* *变量替换</strong></em>；</li><li>SQL中如果字段是字符类型的需要加引号**’?’**;</li><li>SQL中的变量用**?<strong>&#x2F;</strong>${var}**(测试有问题)代替;</li><li><strong>?<strong>为变量时：在</strong>作为参数的字段</strong>中顺序填入变量(需要一一对应)，定义参数需要将文件作为输入，里面的字段值就是参数；</li><li>${var}为变量时：在<strong>转换属性</strong>的<strong>命名参数</strong>中设置变量；</li></ul><h2 id="kettle中执行Java脚本"><a href="#kettle中执行Java脚本" class="headerlink" title="kettle中执行Java脚本"></a>kettle中执行Java脚本</h2><p>添加变量：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Type</span> <span class="token keyword">var</span> <span class="token operator">=</span> <span class="token string">"randtext"</span><span class="token punctuation">;</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Fields<span class="token punctuation">.</span>Out</span><span class="token punctuation">,</span><span class="token string">"var"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span><span class="token keyword">var</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//并在底部'字段'中声明变量var对应类型Type</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>获取输入的字段：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Type</span> <span class="token keyword">var</span> <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Fields<span class="token punctuation">.</span>In</span><span class="token punctuation">,</span> <span class="token string">"a_fieldname"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//表中字段名为a_fieldname的字段</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出字段：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Fields<span class="token punctuation">.</span>Out</span><span class="token punctuation">,</span> <span class="token string">"output_fieldname"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token keyword">var</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="kettle中设置定时"><a href="#kettle中设置定时" class="headerlink" title="kettle中设置定时"></a>kettle中设置定时</h2><p>在作业的<strong>start</strong>组件设置</p><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>会在目标数据库生成对应表文件，右上角connect连接就可以了。</p><p>报错：</p><pre class="line-numbers language-none"><code class="language-none">You don&#39;t seem to be getting a connection to the server. Please check the path you&#39;re using and make sure the server is up and running. <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解决方法：1.是否缺失jar包；2.相关服务是否开启；3.如果没有对应的R_的表，查看对应用户在资源库是否又建表权限，正确赋权后，删掉原来的数据库连接，重新配置repository即可；4.新建数据库重新配置</p>]]></content>
      
      
      <categories>
          
          <category> kettle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kettle </tag>
            
            <tag> ETL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/08/hello-world/"/>
      <url>/2022/07/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle expdp/impdp总结</title>
      <link href="/2022/07/08/oracle-expdp-impdp-zong-jie/"/>
      <url>/2022/07/08/oracle-expdp-impdp-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Oracle-expdp-x2F-impdp总结"><a href="#Oracle-expdp-x2F-impdp总结" class="headerlink" title="Oracle expdp&#x2F;impdp总结"></a>Oracle expdp&#x2F;impdp总结</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>数据泵（expdp，impdp）是Oracle 10g时引入的新技术，兼容了之前的数据导出导入工具（exp，imp）大部分功能，并进一步完善，提供了很多新功能以满足复杂的业务需求。区别于传统的exp，imp工具，数据泵相关命令需在数据库<strong>服务端</strong>执行。</p><p>数据泵属于逻辑迁移，可跨操作系统版本，跨数据库版本。高版本兼容低版本，高版本向低版本导数据，导出时需添加低版本的版本号。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>本篇适用于常用的导出导入命令，如果你只想将本库的数据导出到文件然后将文件导入到库，本篇可以作为参考。</p><p>本例将密码为<strong>test</strong>的用户<strong>C##TEST</strong>中的<strong>testcar</strong>表按照<strong>条件</strong>导出到指定目录，并导入后<strong>更名</strong>为<strong>newtestcar</strong>。</p><ol><li><p>在操作系统创建文件目录用来保存导出的dump文件(Windows系统直接图形化建立路径即可)；</p><pre class="line-numbers language-plsql" data-language="plsql"><code class="language-plsql">mkdir <span class="token operator">-</span>p d<span class="token operator">:</span>\test\dump<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>将目录指定为数据库的目录路径对象；</p><pre class="line-numbers language-plsql" data-language="plsql"><code class="language-plsql"><span class="token keyword">create</span> <span class="token keyword">directory</span> dptest02 <span class="token keyword">as</span> <span class="token string">'d:\test\dump'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>为用户赋予读写目录对象的权限；</p><pre class="line-numbers language-plsql" data-language="plsql"><code class="language-plsql"><span class="token keyword">grant</span> <span class="token keyword">read</span><span class="token punctuation">,</span><span class="token keyword">write</span> <span class="token keyword">on</span> <span class="token keyword">directory</span> dptest02 <span class="token keyword">to</span> <span class="token keyword">C</span>##TEST<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>导出；</p><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic">expdp C##TEST<span class="token operator">/</span>test@orcl directory<span class="token operator">=</span>dptest02 tables<span class="token operator">=</span>testcar query<span class="token operator">=</span>\"where car_buy_time between to_date<span class="token punctuation">(</span>'<span class="token number">2018</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span>'<span class="token punctuation">,</span>'yyyy<span class="token operator">-</span>mm<span class="token operator">-</span>dd HH24<span class="token punctuation">:</span>mi<span class="token punctuation">:</span>ss'<span class="token punctuation">)</span> <span class="token operator">and</span> to_date<span class="token punctuation">(</span>'<span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">31</span> <span class="token number">23</span><span class="token punctuation">:</span><span class="token number">59</span><span class="token punctuation">:</span><span class="token number">59</span>'<span class="token punctuation">,</span>'yyyy<span class="token operator">-</span>mm<span class="token operator">-</span>dd HH24<span class="token punctuation">:</span>mi<span class="token punctuation">:</span>ss'<span class="token punctuation">)</span>\" dumpfile<span class="token operator">=</span>testcar%U.dmp parallel<span class="token operator">=</span><span class="token number">10</span> job_name<span class="token operator">=</span>jobtest01<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>导入；</p><pre class="line-numbers language-basic" data-language="basic"><code class="language-basic">impdp C##TEST<span class="token operator">/</span>test directory<span class="token operator">=</span>dp_test01 dumpfile<span class="token operator">=</span>testcar%U.dmp remap_table<span class="token operator">=</span>C##TEST.testcar<span class="token punctuation">:</span>newtestcar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>总文件113G ,条件导出expdp按照条件导出49G用时25分，impdp导入用时26分，并行10个进程，共231938000行；</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="1、目标新库上的操作"><a href="#1、目标新库上的操作" class="headerlink" title="1、目标新库上的操作"></a>1、目标新库上的操作</h3><p>（1）创建临时表空间</p><pre class="line-numbers language-plsql" data-language="plsql"><code class="language-plsql"><span class="token keyword">create</span> temporary tablespace 用户临时表空间名称 tempfile <span class="token string">'/u01/tablespaces/user_temp.dbf'</span> <span class="token keyword">size</span> <span class="token number">50</span>m autoextend <span class="token keyword">on</span> next <span class="token number">50</span>m maxsize <span class="token number">20480</span>m extent management <span class="token keyword">local</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>备注：根据实际情况调整表空间大小等参数以及规划临时表空间、回滚表空间等相关规划。</p><p>（2）创建数据表空间</p><pre class="line-numbers language-plsql" data-language="plsql"><code class="language-plsql"><span class="token keyword">create</span> tablespace 用户表空间名称 datafile <span class="token string">'/u01/tablespaces/user_data.dbf'</span> <span class="token keyword">size</span> <span class="token number">50</span>m autoextend <span class="token keyword">on</span> next <span class="token number">50</span>m maxsize <span class="token number">20480</span>m extent management <span class="token keyword">local</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）建立用户，并指定默认表空间</p><pre class="line-numbers language-none"><code class="language-none">create user 用户名称 identified by 密码 default tablespace 用户表空间名称 temporary tablespace 用户临时表空间名称;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（4）给用户授予权限</p><pre class="line-numbers language-none"><code class="language-none">grant connect,resource to 用户名1;grant create database link to 用户名;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意：赋权给多个用户的情况下，各个用户名称间用,分隔即可。</p><p>（5）登录需要创建dblink的用户，创建dblink</p><pre class="line-numbers language-plsql" data-language="plsql"><code class="language-plsql"><span class="token keyword">CREATE</span> DATABASE LINK DBLink名称 <span class="token keyword">CONNECT</span> <span class="token keyword">TO</span> 用户 <span class="token keyword">IDENTIFIED</span> <span class="token keyword">BY</span> 密码 <span class="token keyword">USING</span> <span class="token string">'(DESCRIPTION =(ADDRESS_LIST =(ADDRESS =(PROTOCOL = TCP)(HOST = XXX.XXX.XXX.XXX)(PORT = 1521)))(CONNECT_DATA =(SERVICE_NAME = 实例名)))'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：创建DBLINK默认是用户级别的，对当前用户有效。只有当需要对所有用户有效时，再建立公有的DBlink对象（pulic参数）。</p><h3 id="2、创建数据备份目录（源库和目标库）"><a href="#2、创建数据备份目录（源库和目标库）" class="headerlink" title="2、创建数据备份目录（源库和目标库）"></a>2、创建数据备份目录（源库和目标库）</h3><p>备份目录需要使用操作系统用户创建一个真实的目录，然后登录oracle dba用户，创建逻辑目录，指向该路径并使用户有对其读写权限。这样oracle才能识别这个备份目录。</p><p>（1）在操作系统上建立真实的目录</p><pre class="line-numbers language-none"><code class="language-none">$ mkdir -p d:\test\dump<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）登录oracle管理员用户</p><pre class="line-numbers language-qlsql" data-language="qlsql"><code class="language-qlsql">SQL&gt; conn &#x2F;as sysdba<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（3）创建逻辑目录</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SQL</span><span class="token operator">></span> <span class="token keyword">create</span> directory dp_name <span class="token keyword">as</span> <span class="token string">'d:\test\dump'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看目录是否已经创建成功：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SQL</span><span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> dba_directories<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5、用sys管理员给指定用户赋予在该目录的操作权限</p><pre class="line-numbers language-plsql" data-language="plsql"><code class="language-plsql"><span class="token keyword">SQL</span><span class="token operator">></span> <span class="token keyword">grant</span> <span class="token keyword">read</span><span class="token punctuation">,</span><span class="token keyword">write</span> <span class="token keyword">on</span> <span class="token keyword">directory</span> dp_name <span class="token keyword">to</span> 用户<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h2><ul><li>expdp导出</li></ul><pre class="line-numbers language-none"><code class="language-none">1)导出表expdp  tables&#x3D;dbmon.lihaibo_exp dumpfile&#x3D;sms.dmp DIRECTORY&#x3D;dump_dir;2)并发导出parallel，指定job名我们需要特别注意一点，parallel 一定要与 dumpfile&#x3D;...%U.dmp结合 使用，或者有多个表需要同时导出。单表，或者其他诸如network_link方式，指定parallel,也无法开启并发进程expdp scott&#x2F;tiger@orcl directory&#x3D;dpdata1 dumpfile&#x3D;scott3%U.dmp parallel&#x3D;4 job_name&#x3D;scott33)全表expdp scott&#x2F;tiger@orcl TABLES&#x3D;emp,dept dumpfile&#x3D;expdp.dmp DIRECTORY&#x3D;dpdata1;4)导出表，并指定表中的内容expdp scott&#x2F;tiger@orcl directory&#x3D;dpdata1 dumpfile&#x3D;expdp.dmp Tables&#x3D;emp query&#x3D;&quot;WHERE deptno&#x3D;20&quot;;5)导出表空间expdp system&#x2F;manager DIRECTORY&#x3D;dpdata1 DUMPFILE&#x3D;tablespace.dmp TABLESPACES&#x3D;temp,example;6)导出全库expdp system&#x2F;manager DIRECTORY&#x3D;dpdata1 DUMPFILE&#x3D;full.dmp FULL&#x3D;y;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>impdp导入</li></ul><pre class="line-numbers language-none"><code class="language-none">1) 全用户导入impdp scott&#x2F;tiger DIRECTORY&#x3D;dpdata1 DUMPFILE&#x3D;expdp.dmp SCHEMAS&#x3D;scott;2) 用户对象迁移impdp system&#x2F;manager DIRECTORY&#x3D;dump_dir DUMPFILE&#x3D;expdp.dmp TABLES&#x3D;scott.dept REMAP_SCHEMA&#x3D;scott:system; （SCOTT为原用户，system为目标用户）3) 导入指定表空间impdp system&#x2F;manager DIRECTORY&#x3D;dump_dir DUMPFILE&#x3D;tablespace.dmp TABLESPACES&#x3D;example;4) 全库导入impdb system&#x2F;manager DIRECTORY&#x3D;dump_dir DUMPFILE&#x3D;full.dmp FULL&#x3D;y;5) 表已存在的处理impdp system&#x2F;manager DIRECTORY&#x3D;dump_dir DUMPFILE&#x3D;expdp.dmp SCHEMAS&#x3D;system TABLE_EXISTS_ACTION&#x3D;append;6) 表空间迁移impdp system&#x2F;manager directory&#x3D;dump_dir dumpfile&#x3D;remap_tablespace.dmp logfile&#x3D;remap_tablespace.log remap_tablespace&#x3D;A:B (A为原表空间名，B为指定的目标表空间名)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="expdp-x2F-impdp参数说明"><a href="#expdp-x2F-impdp参数说明" class="headerlink" title="expdp&#x2F;impdp参数说明"></a>expdp&#x2F;impdp参数说明</h2><ul><li><p>帮助：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">impdp -helpexpdp help&#x3D;y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote></li><li><p>ATTACH</p></li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    当我们使用ctrl+C 退出交互式命令时，可使用attach参数重新进入到交互模式语法    ATTACH&#x3D;[schema_name.]job_name    Schema_name用户名,job_name任务名示例    Expdp scott&#x2F;tiger ATTACH&#x3D;scott.export_job<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>CONTENT</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    限制了导出的内容，包括三个级别：全部／数据／元数据（结构）语法   CONTENT&#x3D;&#123;ALL | DATA_ONLY | METADATA_ONLY&#125;   ALL           -- 导出所有数据，包括元数据及数据   DATA_ONLY     -- 只导出数据   METADATA_ONLY -- 只包含元数据，就是创建语句示例   Expdp scott&#x2F;tiger DIRECTORY&#x3D;dump DUMPFILE&#x3D;a.dump CONTENT&#x3D;METADATA_ONLY<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><strong>DIRECTORY</strong></li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用此路径可以理解为实际绝对路径在oracle数据库里的别名，是导出文件的存储位置    路径的创建： create directory &amp;DIRECTORY_NAME AS &#39;&amp;PATH&#39;;    查看已存在路径： select  * from dba_directories;语法    directory&#x3D;[directory_name]示例    Expdp scott&#x2F;tiger DIRECTORY&#x3D;dump_dir DUMPFILE&#x3D;lhb.dump<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><strong>DUMPFILE</strong></li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    此参数用户命名导出文件，默认是 expdat.dmp. 文件的存储位置如果在文件名前没有指定directory,则会默认存储到directory参数指定的路径下。语法    DUMPFILE&#x3D;[dump_dir:]file_name示例    Expdp scott&#x2F;tiger DIRECTORY&#x3D;dump_dir DUMPFILE&#x3D;dump_dir1:a.dmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>ESTIMATE</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">在使用Expdp进行导出时，Expdp需要计算导出数据大小容量，Oracle可以通过两种方式进行容量估算，一种是通过数据块(blocks)数量、一种是通过统计信息中记录的内容(statistics)估算.语法结构：    EXTIMATE&#x3D;&#123;BLOCKS | STATISTICS&#125;示例：    Expdp scott&#x2F;tiger TABLES&#x3D;emp ESTIMATE&#x3D;STATISTICS DIRECTORY&#x3D;dump_dir DUMPFILE&#x3D;halberd.dump    Expdp scott&#x2F;tiger TABLES&#x3D;emp ESTIMATE&#x3D;BLOCKS DIRECTORY&#x3D;dump_dir DUMPFILE&#x3D;halberd.dump<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>EXTIMATE_ONLY</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    此参数用于统计导出的数据量大小及统计过程耗时长短。语法    EXTIMATE_ONLY&#x3D;&#123;Y | N&#125;示例    Expdp scott&#x2F;tiger ESTIMATE_ONLY&#x3D;y NOLOGFILE&#x3D;y directory&#x3D;dump_dir schemas&#x3D;halberd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>EXCLUDE</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    此参数用于排除不需要导出的内容，如我们进行全库导出，但是不需要导出用户scott，此时需要在exlude后先指定排除类型为schema,再指定具体的schema。具体使用方法见include参数. EXCLUDE与include的使用方法是一样的语法    EXCLUDE&#x3D;object_type[:name_clause] [,object_type[:name_clause] ]    name_clause        &quot;&#x3D;&#39;object_name&#39;&quot;        &quot;in (&#39;object_name&#39;[,&#39;object_name&#39;,....])&quot;        &quot;in (select_clause) &quot;    Object_type对象类型，如：table,view,procedure,schema等    name_clause指定名称的语句,如果不具体指定是哪个对象，则此类所有对象都不导出, select 语句中表名不要加用户名。用户名，通过schemas 指定。示例    expdp scott&#x2F;tiger DIRECTORY&#x3D;dump_dir DUMPFILE&#x3D;halberd.dup EXCLUDE&#x3D;VIEW    expdp scott&#x2F;tiger DIRECTORY&#x3D;dump_dir DUMPFILE&#x3D;halberd.dup EXCLUDE&#x3D;TABLE:\&quot; IN\(\&#39;TEMP\&#39;,\&#39;GRADE\&#39;\)\&quot;    EXCLUDE&#x3D;TABLE:&quot;&#x3D;&#39;APPLICATION_AUDIT&#39;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>FILESIZE</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    用于指定单个导出的数据文件的最大值，与％U一起使用。比如，我们需要导出100G的数据，文件全部存储到一个文件内，在文件传输时，会耗费大量的时间，此时我们就可以使用这个参数，限制每个文件的大小，在传输导出文件时，就可以多个文件同时传送，大大的节省了文件传输时间。提高了工作的效率。语法  FILESIZE&#x3D;integer[B | K | M | G]示例   Expdp scott&#x2F;tiger DIRECTORY&#x3D;dump_dir DUMPFILE&#x3D;halberd%U.dup FILESIZE&#x3D;20g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>FLASHBACK_SCN／FLASHBACK_TIME</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    基于undo 及scn号(时间点)进行的数据导出。使用此参数设置会进行flashback query的功能，查询到对应指定的SCN时的数据，然后进行导出。只要UNDO不被覆盖，无论数据库是否重启，都可以进行导出. flashback_time参数与flashback_scn的原理是一样的。在导出的数据里保持数据的一致性是很有必要的。这个。。我想，没谁傻忽忽的把这两个参数一起使用吧？所以我就不提醒你两个参数不可以同时使用了。语法   FLASHBACK_SCN&#x3D;scn_value   FLASHBACK_TIME 有多种设定值的格式：   flashback_time&#x3D;to_timestamp (localtimestamp)   flashback_time&#x3D;to_timestamp_tz (systimestamp)   flashback_time&#x3D;&quot;TO_TIMESTAMP (&quot;&quot;25-08-2003 14:35:00&quot;&quot;， &quot;&quot;DD-MM-YYYY HH24:MI:SS&quot;&quot;)&quot;  使用此格式可能会遇到ORA-39150错误。示例   Expdp scott&#x2F;tiger DIRECTORY&#x3D;dump_dir DUMPFILE&#x3D;halberd.dmp FLASHBACK_SCN&#x3D; 12345567789   Expdp scott&#x2F;tiger DIRECTORY&#x3D;dump_dir DUMPFILE&#x3D;halberd.dmp FLASHBACK_TIME&#x3D; to_timestamp (localtimestamp)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>FULL</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用   指定导出内容为全库导出。这里需要特别注意的是,expdp 不能导出sys用户对象。即使是全库导出也不包含sys用户。语法   FULL&#x3D;&#123;Y | N&#125;示例   expdp \&#39;\&#x2F; as sysdba\&#39; directory&#x3D;dump_dir full&#x3D;y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><strong><span id = "include">INCLUDE</span></strong></li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    限制范围，指定自己想要的内容，比如要导出某个用户的某张表。语法    INCLUDE &#x3D; object_type[:name_clause],object_type[:name_clause]示例    impdp dbmon&#x2F;dbmon_123 directory&#x3D;dump_dir network_link&#x3D;zjzwb2 SCHEMAS&#x3D;AICBS remap_schema&#x3D;aicbs:aicbsb include&#x3D;table:\&quot;IN\(SELECT TABLE_NAME FROM dbmon.TABLES_TOBE_MASKED\)\&quot;  LOGFILE&#x3D;zjzwb.log transform&#x3D;segment_attributes:n    PARFILE中设置:        INCLUDE&#x3D;table:&quot;in(select table_name from dba_tables where owner&#x3D;&#39;AA&#39;)&quot;        INCLUDE&#x3D;TABLE:&quot;IN(&#39;TEST1&#39;,&#39;TEST2&#39;)&quot;    SHELL环境设置:        INCLUDE&#x3D;TABLE:\&quot;IN\(SELECT TABLE_NAME FROM DBA_TABLES WHERE OWNER&#x3D;\&#39;AA\&#39;\)\&quot;        INCLUDE&#x3D;TABLE:\&quot;IN\(\&#39;TEST1\&#39;,\&#39;TEST2\&#39;\)\&quot;说明    当导入命令在目标端发起时，select 子句所涉及的表要在源端，并且dblink 所使用的用户有访问的权限。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>JOB_NAME</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    指定任务名，如果不指定的话，系统会默认自动命名：SYS_EXPORT_mode_nn语法    JOB_NAME&#x3D;&amp;JOB_NAME其他    查看有哪些expdp&#x2F;impdp job，可以通过dba_datapump_jobs查看，其实你通过v$session.action也可以查看到    大多与attach参数一起使用，重新进行expdp交互命令时使用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><strong>LOGFILE</strong></li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用： 指定导出日志名称。默认是：expdp.log语法    LOGFILE&#x3D;[DIRECTORY:]file_name   , 如果参数值里没有指定路径，会默认使用directory参数值所指向的路径。    directory ： 存储路径,    file_name :日志文件名示例    expdp scott&#x2F;tiger DIRECTORY&#x3D;dump_dir DUMPFILE&#x3D;halberd.dmp logfile&#x3D;halberd.log    impdp scott&#x2F;tiger DIRECTORY&#x3D;dump_dir DUMPFILE&#x3D;halberd.dmp logfile&#x3D;halberd.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><strong>NETWORK_LINK</strong></li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    此参数只有在导入（impdp）时使用，可通过本地数据库里的db_link连接到其他数据库A，将数据库A的数据直接导入到本地数据库。中间可节省导出数据文件，传送数据文件的过程。很方便。但是要特别注意，不同版本之间可能会存在问题，比如源库为10g,目标库为11g。使用network_link参数会报错。至于 12C 与低版本之间是否有问题尚未尝试。语法    network_link&#x3D;[db_link]示例    impdp scott&#x2F;tiger DIRECTORY&#x3D;dump_dir DUMPFILE&#x3D;halberd.dmp NETWORK_LINK&#x3D;to_tjj SCHEMAS&#x3D;halberd logfile&#x3D;halberd.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>NOLOGFILE</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    不写导入导出日志，这个笔者是灰常灰常滴不建议设置为“Y”滴。语法    nologfile&#x3D;[y|n]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>PARALLEL</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    指定导出／导入时使用多少个并发，默认是1,如果是单个表则在dumpfile中使用...%U.dmp语法    parallel&#x3D;[digit]示例    expdp \&#39;\&#x2F; as sysdba\&#39; directory&#x3D;dump_dir schemas&#x3D;halberd dumpfile&#x3D;halberd%U.dmp parallel&#x3D;8 logfile&#x3D;halberd.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>PARFILE</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    参数文件，这个参数文件里，存储着一些参数的设置。比如上面说过的，parallel,network_link,等。导出时，可以使用此参数，expdp&#x2F;impdp会自动读取文件中的参数设置，进行操作。语法    PARFILE&#x3D;[directory_path] file_name示例   expdp \&#39;\&#x2F; as sysdba\&#39; parfile&#x3D;halberd.par   cat halberd.par   directory&#x3D;dump_dir                             logfile&#x3D;test.log                               schemas&#x3D;test                                   query&#x3D;&quot;where create_date &gt; last_day(add_months(sysdate,-1)) and create_date &lt;&#x3D; last_day(sysdate)&quot;    transform&#x3D;segment_attributes:n                    network_link&#x3D;to_aibcrm   table_exists_action&#x3D;append                       impdp \&#39;\&#x2F; as sysdba\&#39; parfile&#x3D;test.par<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><strong>QUERY</strong></li></ul><blockquote><pre class="line-numbers language-plsql" data-language="plsql"><code class="language-plsql">作用    此参数指定在导入导出时的限制条件，和<span class="token keyword">SQL</span>语句中的 <span class="token string">"where"</span> 语句是一样儿一样儿滴语法    QUERY<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">[</span>schema<span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>table_name<span class="token operator">:</span><span class="token punctuation">]</span> query_clause<span class="token punctuation">,</span> <span class="token punctuation">[</span>schema<span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>table_name<span class="token operator">:</span><span class="token punctuation">]</span> query_clause<span class="token punctuation">,</span>……<span class="token punctuation">)</span>    CONTENT<span class="token operator">=</span>METADATA_ONLY<span class="token punctuation">,</span> EXTIMATE_ONLY＝Y<span class="token punctuation">,</span>TRANSPORT_TABLESPACES<span class="token punctuation">.</span>示例   Expdp scott<span class="token operator">/</span>tiger <span class="token keyword">directory</span><span class="token operator">=</span>dump dumpfiel<span class="token operator">=</span><span class="token keyword">a</span><span class="token punctuation">.</span>dmp Tables<span class="token operator">=</span>emp query<span class="token operator">=</span>\"<span class="token keyword">where</span> car_buy_time <span class="token keyword">between</span> to_date<span class="token punctuation">(</span><span class="token string">'2018-01-01 0:00:00'</span><span class="token punctuation">,</span><span class="token string">'yyyy-mm-dd HH24:mi:ss'</span><span class="token punctuation">)</span> <span class="token keyword">and</span> to_date<span class="token punctuation">(</span><span class="token string">'2019-12-31 23:59:59'</span><span class="token punctuation">,</span><span class="token string">'yyyy-mm-dd HH24:mi:ss'</span><span class="token punctuation">)</span>\"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><strong>SCHEMAS</strong></li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    指定导出／导入哪个用户语法    schemas&#x3D;schema_name[,schemaname,....]示例    expdp \&#39;\&#x2F; as sysdba\&#39; directory&#x3D;dump_dir schemas&#x3D;halberd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>REMAP_SCHEMA</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none"> 只在导入时使用作用    当把用户A的对象导入到用户（其实应该叫schema，将就看吧）B时，使用此参数，可实现要求格式    remap_schema&#x3D;schema1: schema2示例    impdp \&#39;\&#x2F; as sysdba\&#39; directory&#x3D;dump_dir dumpfile&#x3D;halberd.dmp logfile&#x3D;halberd.log remap_schema&#x3D;scott:halberd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><strong>TABLES</strong></li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    指定导出哪些表。格式    TABLES&#x3D;[schema.]table_name[:partition_name][,[schema.]table_name[:partition_name]]说明    Schema 表的所有者；table_name表名；partition_name分区名.可以同时导出不同用户的不同的表示例    expdp \&#39;\&#x2F; as sysdba\&#39; directory&#x3D;dump_dir tables&#x3D;emp.emp_no,emp.dept<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><strong>REMAP_TABLE</strong><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    只有在导入时使用，用于将导入的数据表更名。用法    REMAP_TABLE&#x3D;S.a:b说明   S:表所在模式；a: 数据所在的原表空间; b： 目标表空间示例    impdp \&#39;\&#x2F; as sysdba\&#39; directory&#x3D;dump_dir tables&#x3D;emp,dept  remap_table&#x3D;C##TEST.emp:newemp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote></li><li>TABLESPACES</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    指定导出／导入哪个表空间。语法    tablespaces&#x3D;tablespace_name[,tablespace_name,....]示例    expdp \&#39;\&#x2F; as sysdba\&#39; directory&#x3D;dump_dir tablespace&#x3D;user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>REMAP_TABLESPACE</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    只有在导入时使用，用于进行数据的表空间迁移。 把前一个表空间中的对象导入到冒号后面的表空间用法    remap_tablespace&#x3D;a:b说明   a: 数据所在的原表空间; b： 目标表空间示例   impdp \&#39;\&#x2F; as sysdba\&#39; directory&#x3D;dump_dir tables&#x3D;emp.dept remap_tablespace&#x3D;user:user1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>TRANSPORT_FULL_CHECK</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">检查需要进行传输的表空间与其他不需要传输的表空间之间的信赖关系，默认为N。当设置为“Y”时，会对表空间之间的信赖关系进行检查，如A（索引表空间）信赖于B（表数据表空间），那么传输A而不传输B，则会出错，相反则不会报错。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><ul><li>TRANSPORT_TABLESPACES</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用    列出需要进行数据传输的表空间格式     TRANSPORT_TABLESPACES＝tablespace1[,tablespace2,.............]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>TRANSFORM</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用  此参数只在导入时使用，是一个用于设定存储相关的参数,有时候也是相当方便的。假如数据对应的表空间都存在的话，就根本用不到这个参数，但是，假如数据存储的表空间不存在，使用此参数导入到用户默认表空间就可以了。更灵活的，可以使用remap_tablespace参数来指定。格式    transform&#x3D;transform_name:value[bject_type]    transform_name &#x3D; [OID | PCTSPACE | SEGMENT_ATTRIBUTES | STORAGE]:[Y|N]    segment attributes:段属性包括物理属性、存储属性、表空间和日志,Y 值按照导出时的存储属性导入，N时按照用户、表的默认属性导入    storage:默认为Y，只取对象的存储属性作为导入作业的一部分    oid:  owner_id,如果指定oid&#x3D;Y(默认)，则在导入过程中将分配一个新的oid给对象表，这个参数我们基本不用管。    pctspace:通过提供一个正数作为该转换的值，可以增加对象的分配尺寸，并且数据文件尺寸等于pctspace的值(按百分比)示例    transform&#x3D;segment_attributes:n --表示将用户所有对象创建到用户默认表空间，而不再考虑原来的存储属性。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><strong>VERSION</strong></li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">此参数主要在跨版本之间进行导数据时使用，更具体一点，是在从高版本数据库导入到低版本数据库时使用,从低版本导入到高版本，这个参数是不可用的。默认值是:compatible。此参数基本在导出时使用，导入时基本不可用。VERSION&#x3D;&#123;COMPATIBLE | LATEST | version_string&#125;COMPATIBLE       ： 以参数compatible的值为准，可以通过show parameter 查看compatible参数的值LATEST           ： 以数据库版本为准version_string   ： 指定版本。如： version&#x3D;10.2.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>SAMPLE</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">SAMPLE 抽样 给出导出表数据的百分比，参数值可以取.000001~100（不包括100）。不过导出过程不会和这里给出的百分比一样精确，是一个近似值。 格式： SAMPLE&#x3D;[[schema_name.]table_name:]sample_percent 示例： SAMPLE&#x3D;&quot;HR&quot;.&quot;EMPLOYEES&quot;:50<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><span id="table_exists_action">table_exists_action</span></li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">此参数只在导入时使用。作用：导入时，假如目标库中已存在对应的表，对于这种情况，提供三种不同的处理方式：append,truncate,skip,replace格式： table_exists_action&#x3D;［append | replace| skip |truncate］说明： append :   追加数据到表中       truncate:  将目标库中的同名表的数据truncate掉。       skip ：      遇到同名表，则跳过，不进行处理，注意：使用此参数值时，与该表相关的所有操作都会skip掉。       replace:    导入过程中，遇到同名表，则替换到目标库的那张表（先drop,再创建）。示例：  table_exists_action&#x3D;replace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>SQLFILE</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">只在导入时使用！作用： 使用此参数时，主要是将DMP文件中的metadata语句取出到一个单独的SQLfile中，而数据并不导入到数据库中格式： sqlfile&#x3D;&amp;file_name.sql示例： impdp \&#39;\&#x2F; as sysdba\&#39; directory&#x3D;dump_dir dumpfile&#x3D;halberd.dmp logfile&#x3D;halberd.log sqlfile&#x3D;halberd.sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><p>legacy mode </p><p>在11g中，才有这种模式。这种模式里兼容了以前版本中的部分参数，如：consistent,reuse_dumpfiles等（其实我现在也就知道这两个参数，哈哈，以后再遇到再补充）</p></li><li><p>consistent</p></li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">这个是保持数据一致性的一个参数。在11g中使用时，如果设置 consistent&#x3D;true,则会默认转换成 flashback_time参数，时间设置为命令开始执行的那个时间点。格式： consistent&#x3D;[true|false]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><ul><li>reuse_dumpfiles</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">作用：重用导出的dmp文件 。假如第一次我们导失败了，虽然导出失败，但是dmp文件 还 是会生成的。在修改导出命令，第二次执行时，就可以 加上这个参数。格式： reuse_dumpfile&#x3D;[true|false]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><ul><li>partition_options</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">1 NONE 不对分区做特殊处理。在系统上的分区表一样创建。2 DEPARTITION 每个分区表和子分区表作为一个独立的表创建，名字使用表和分区（子分区）名字的组合。3 MERGE 将所有分区合并到一个表 注意：如果导出时使用了TRANSPORTABLE参数，这里就不能使用NONE和MERGE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="交互式命令"><a href="#交互式命令" class="headerlink" title="交互式命令"></a><span id="jiaohu">交互式命令</span></h2><ol><li><p>连接到对应的job: </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">impdp username<span class="token operator">/</span>password attach<span class="token operator">=</span><span class="token operator">&amp;</span>job_nameexpdp username<span class="token operator">/</span>password attach<span class="token operator">=</span><span class="token operator">&amp;</span>job_name<span class="token comment">--jobname可以在运行任务时指定或者使用sql：</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> DBA_DATAPUMP_JOBS<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查看运行状态： status</p></li><li><p>停止导入导出： kill_job(直接kill 掉进程，不自动退出交互模式)</p></li><li><p>停止导入导出：stop_job（逐一停止job进程的运行，并退出交互模式）</p></li><li><p>修改并发值： parallel</p></li><li><p>退出交互模式： exit &#x2F; exit_client(退出到日志模式，对job无影响)</p></li></ol><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><h3 id="不生成文件直接导入目标数据库"><a href="#不生成文件直接导入目标数据库" class="headerlink" title="不生成文件直接导入目标数据库"></a>不生成文件直接导入目标数据库</h3><ul><li>创建public dblink；</li></ul><pre class="line-numbers language-plsql" data-language="plsql"><code class="language-plsql"><span class="token keyword">CREATE</span> <span class="token keyword">PUBLIC</span> DATABASE LINK <span class="token operator">&lt;</span>pub_link_test1<span class="token operator">></span><span class="token keyword">CONNECT</span> <span class="token keyword">TO</span> <span class="token operator">&lt;</span>username<span class="token operator">></span> <span class="token keyword">IDENTIFIED</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span><span class="token string">"密码"</span><span class="token operator">></span><span class="token keyword">USING</span><span class="token string">'(DESCRIPTION =    (ADDRESS_LIST =      (ADDRESS = (PROTOCOL = TCP)(HOST = &lt;localhost>)(PORT = 1521))    )    (CONNECT_DATA =    (SERVER = DEDICATED)      (SERVICE_NAME = ORCL)    ))'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对DIRECTORY对应目录有<code> </code> <code>READ</code> &#x2F; <code>WRITE</code> &#x2F; <code>UTL_FILE</code> 权限；</li></ul><pre class="line-numbers language-plsql" data-language="plsql"><code class="language-plsql"><span class="token keyword">CREATE</span> <span class="token keyword">DIRECTORY</span> <span class="token operator">&lt;</span>dp_name<span class="token operator">></span> <span class="token keyword">AS</span> <span class="token operator">&lt;</span><span class="token string">'E:\dptest\test1'</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">GRANT</span> <span class="token keyword">READ</span><span class="token punctuation">,</span><span class="token keyword">WRITE</span> <span class="token keyword">ON</span> <span class="token keyword">DIRECTORY</span> <span class="token operator">&lt;</span>dp_name<span class="token operator">></span> <span class="token keyword">TO</span> <span class="token operator">&lt;</span>username<span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">GRANT</span> <span class="token keyword">EXECUTE</span> <span class="token keyword">ON</span> SYS<span class="token punctuation">.</span>UTL_FILE <span class="token keyword">TO</span> <span class="token operator">&lt;</span>username<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>导入到数据库；</li></ul><pre class="line-numbers language-plsql" data-language="plsql"><code class="language-plsql">impdp <span class="token operator">&lt;</span>username<span class="token operator">></span><span class="token operator">/</span><span class="token operator">&lt;</span>password<span class="token operator">></span><span class="token variable">@orcl</span> <span class="token keyword">directory</span><span class="token operator">=</span><span class="token operator">&lt;</span>dp_name<span class="token operator">></span> tables<span class="token operator">=</span><span class="token operator">&lt;</span><span class="token keyword">C</span>##TEST<span class="token punctuation">.</span>testcar要导入的表<span class="token operator">></span> parallel<span class="token operator">=</span><span class="token number">10</span> network_link<span class="token operator">=</span><span class="token operator">&lt;</span>pub_link_test1<span class="token operator">></span> remap_table<span class="token operator">=</span><span class="token operator">&lt;</span><span class="token keyword">C</span>##TEST<span class="token punctuation">.</span>testcar<span class="token operator">:</span>testfullcar改名<span class="token operator">></span> LOGFILE<span class="token operator">=</span>impdp<span class="token punctuation">.</span>log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>个人测试分开导入导出共花费100min,直接导入数据库40min，速度直接提高2.5倍！</p><ul><li>注意：</li></ul><ol><li>在B服务器数据库创建到A服务器数据库的public db link；</li><li>在system下创建Directory，并赋予其读写权限，同时赋予SYS.UTL_FILE的执行权限；</li><li>执行脚本参数位置。</li></ol><h3 id="导入多张表"><a href="#导入多张表" class="headerlink" title="导入多张表"></a>导入多张表</h3><p>使用**<a href="#include">INCLUDE</a>**参数</p><h3 id="如果存在表将导入文件追加到文件尾-x2F-跳过-x2F-删除"><a href="#如果存在表将导入文件追加到文件尾-x2F-跳过-x2F-删除" class="headerlink" title="如果存在表将导入文件追加到文件尾&#x2F;跳过&#x2F;删除"></a>如果存在表将导入文件追加到文件尾&#x2F;跳过&#x2F;删除</h3><p>使用**<a href="#table_exists_action">table_exists_action</a>**参数：［append | replace| skip |truncate］</p><h3 id="查看进度"><a href="#查看进度" class="headerlink" title="查看进度"></a>查看进度</h3><p>在<a href="#jiaohu">交互式命令</a>里面status可以查看导入百分比等详细信息，导出没有显示百分比；</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h4 id="1、ORA-39112"><a href="#1、ORA-39112" class="headerlink" title="1、ORA-39112"></a>1、ORA-39112</h4><p>导出正常，导入数据时，只成功导入部分记录等数据，另外的部分提数ora 39112错误，经查是因为导出的用户数据中，有部分记录的表用的索引在另一表空间中，该空间还未创建，所以导致该失败。</p><p>解决方法：在导入时，添加参数：RANSFORM&#x3D;segment_attributes:n ，配合table_exists_action&#x3D;replace参数，重新导入即可。</p><p>RANSFORM&#x3D;segment_attributes:n 在导入时，会将数据导入默认的表空间中。</p><p> 补充，造成该问题的可能原因：</p><pre class="line-numbers language-none"><code class="language-none">1、在原来测试库中，目标schema和别的用户相互授权了，可是你导出的dmp中没有包含所有的用户，导入时对应用户没有创建。2、再就是，表空间问题，测试库中的用户下的某个表的索引没有在他的默认表空间里，这样你要在目标端（这里就是生产环境），创建好对应的表空间，就是说如果你在测试库把a用户的下的某个表的权限授给了b,那么你在把a用户用数据泵倒进生产库时，他会在生产库中检测有没有用户ｂ。也要做相同的操作。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2、ORA-39346"><a href="#2、ORA-39346" class="headerlink" title="2、ORA-39346"></a>2、ORA-39346</h4><p>导入过程中，遇到错误”  ORA-39346: data loss in character set conversion for object SCHEMA_EXPORT&#x2F;PROCEDURE&#x2F;PROCEDURE  “</p><p>oracle官方的描述如下：</p><ul><li><strong>Description:</strong> data loss in character set conversion for object string</li><li><strong>Cause:</strong> Oracle Data Pump import converted a metadata object from the export database character set into the target database character set prior to processing the object. Some characters could not be converted to the target database character set and so the default replacement character was used.</li><li><strong>Action:</strong> No specific user action is required. This type of data loss can occur if the target database character set is not a superset of the export databases character set.</li></ul><p> 翻译：不需要特定的用户操作。如果目标数据库字符集不是导出数据库字符集的超集，则可能发生此类数据丢失。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>expdp和impdp是服务端的工具程序，他们只能在Oracle服务端使用，不能在客户端使用。</li><li>impdp&#x2F;expdp组合使用，不可以与exp&#x2F;imp混用。</li><li>导数据之间的数据库字符集必须一致，否则可能出现乱码。</li><li>经过测试一次只能有一个job在运行</li></ul><h2 id="脚本（转自）"><a href="#脚本（转自）" class="headerlink" title="脚本（转自）"></a>脚本（<a href="https://www.cnblogs.com/chinas/p/8300955.html#_label5">转自</a>）</h2><span id="more"></span><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#!&#x2F;bin&#x2F;bash##############################################################################脚本功能：#脚本路径：#使用方法：脚本名称 操作类型参数#############################################################################export NLS_LANG&#x3D;american_america.AL32UTF8export ORACLE_HOME&#x3D;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;product&#x2F;12.1.0&#x2F;db_1export ORACLE_SID&#x3D;cyrtestdbexport PATH&#x3D;$PATH:$ORACLE_HOME&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;bin&#x2F;X11:&#x2F;usr&#x2F;local&#x2F;bin:.v_date&#x3D;&#96;date +%Y%m%d&#96;v_logfile&#x3D;&#96;echo $(basename  $0) | awk -F &quot;.&quot; &#39;&#123;print $1&quot;.log&quot;&#125;&#39;&#96;  #日志文件名称：脚本所在目录下，脚本名称.logv_usr_1&#x3D;&quot;&quot;            #Oracle用户名、密码v_pwd_1&#x3D;&quot;&quot;v_usr_2&#x3D;&quot;&quot;v_pwd_2&#x3D;&quot;&quot;            v_db_instance&#x3D;&quot;&quot;    #数据库实例名v_backup_dir&#x3D;&quot;&quot;        #Oracle备份目录(全局变量)v_oradir_name&#x3D;&quot;&quot;    #v_tmp_space1&#x3D;&quot;&quot;        #临时表空间、表空间、索引表空间v_tmp_space2&#x3D;&quot;&quot;v_space1&#x3D;&quot;&quot;v_space2&#x3D;&quot;&quot;v_idx_space1&#x3D;&quot;&quot;v_idx_space2&#x3D;&quot;&quot;v_max_size&#x3D;&quot;5120m&quot;    #表空间数据文件最大值v_dblink&#x3D;&quot;&quot;            #dblink名称#记录日志record_log()&#123;    echo -e &#96;date &#39;+%Y-%m-%d %H:%M:%S&#39;&#96; $1 | tee -a $&#123;v_logfile&#125;&#125;#用户数据导出exp_usrdata()&#123;    v_exp_usr&#x3D;$1    v_exp_pwd&#x3D;$2    v_oradir_name&#x3D;$3    cd $&#123;v_backup_dir&#125;    [[ -f $&#123;v_exp_usr&#125;&quot;_&quot;$&#123;v_date&#125;&quot;.dmp&quot; ]] &amp;&amp; rm -rf $&#123;v_exp_usr&#125;&quot;_&quot;$&#123;v_date&#125;&quot;.dmp&quot;    expdp $&#123;v_exp_usr&#125;&#x2F;$&#123;v_exp_pwd&#125; DIRECTORY&#x3D;$&#123;v_oradir_name&#125; DUMPFILE&#x3D;$&#123;v_exp_usr&#125;&quot;_&quot;$&#123;v_date&#125;&quot;.dmp&quot; SCHEMAS&#x3D;$&#123;v_exp_usr&#125; LOGFILE&#x3D;$&#123;v_exp_usr&#125;&quot;_&quot;$&#123;v_date&#125;&quot;.log&quot;&#125;#在目标库上创建数据库备份目录create_bankup_dir()&#123;    #创建操作系统物理路径    [[ -d $&#123;v_backup_dir&#125; ]] &amp;&amp; mkdir -p $&#123;v_backup_dir&#125;    sqlplus -S &#x2F; as sysdba &gt;&gt; $&#123;v_logfile&#125; &lt;&lt;EOF    set heading off feedback off verify off    spool tmp_space_flag.tmp    grant read,write on directory &#39;$&#123;v_oradir_name&#125;&#39; to &#39;$&#123;v_usr_1&#125;&#39;,&#39;$&#123;v_usr_2&#125;&#39;;    spool off    exit;EOF    ##如果当前表空间不存在，则创建，否则退出当前函数    if [[ &#96;grep $&#123;v_oradir_name&#125; tmp_space_flag.tmp | wc -l&#96; -eq 0 ]]; then        record_log &quot;创建备份目录&quot;$1&quot;开始&quot;        sqlplus -S &#x2F; as sysdba &gt;&gt; $&#123;v_logfile&#125; &lt;&lt;EOF        set heading off feedback off verify off        grant read,write on directory &#39;$&#123;v_oradir_name&#125;&#39; to &#39;$&#123;v_usr_1&#125;&#39;,&#39;$&#123;v_usr_2&#125;&#39;;        exit;EOF        record_log &quot;创建备份目录&quot;$1&quot;结束&quot;    else        record_log &quot;创建备份目录&quot;$1&quot;已存在&quot;        return    fi    ##注意清理临时标志文件    [[ -f .&#x2F;tmp_space_flag.tmp ]] &amp;&amp; rm -rf tmp_space_flag.tmp&#125;#创建表空间create_space()&#123;    v_space_name&#x3D;$1    #判断表空间类型（临时表空间或普通表空间）    if [[ &#96;grep TMP $1&#96; -eq 1 ]]; then        v_space_type&#x3D;&quot;temporary&quot;    else        v_space_type&#x3D;&quot;&quot;    fi     sqlplus -S &#x2F; as sysdba &gt;&gt; $&#123;v_logfile&#125; &lt;&lt;EOF    set heading off feedback off verify off    create &#39;$&#123;v_space_type&#125;&#39; tablespace &#39;$&#123;v_space_name&#125;&#39; tempfile &#39;$&#123;v_backup_dir&#125;&#x2F;$&#123;v_space_name&#125;.dbf&#39; size 50m autoextend on next 128k maxsize &#39;$&#123;v_max_size&#125;&#39; extent management local;     exit;EOF&#125;#判断表空间是否存在，若表空间不存在则创建deal_spaces()&#123;    v_space_name&#x3D;$1    sqlplus -S &#x2F; as sysdba &lt;&lt;EOF     set heading off feedback off verify off    spool tmp_space_flag.tmp    select tablespace_name from dba_tablespaces where tablespace_name&#x3D;&#39;$&#123;v_space_name&#125;&#39;;    spool off    exit;EOF    ##如果当前表空间不存在，则创建，否则退出当前函数    if [[ &#96;grep $&#123;v_space_name&#125; tmp_space_flag.tmp | wc -l&#96; -eq 0 ]]; then        record_log &quot;创建表空间&quot;$1&quot;开始&quot;        create_space $&#123;v_space_name&#125;        record_log &quot;创建表空间&quot;$1&quot;结束&quot;    else        record_log &quot;表空间&quot;$1&quot;已存在&quot;        return    fi    ##注意清理临时标志文件    [[ -f .&#x2F;tmp_space_flag.tmp ]] &amp;&amp; rm -rf tmp_space_flag.tmp&#125;#在目标库上创建用户并赋权create_usrs()&#123;    v_create_usr&#x3D;$1        #参数1：用户名    v_create_pwd&#x3D;$2        #参数2：密码    v_create_tmp_space&#x3D;$3         #参数3：临时表空间名称    v_create_space&#x3D;$4        #参数4：表空间名称    sqlplus -S &#x2F; as sysdba &gt;&gt; $&#123;v_logfile&#125; &lt;&lt;EOF    set heading off feedback off verify off    create user &#39;$&#123;v_create_usr&#125;&#39; identified by &#39;$&#123;v_create_pwd&#125;&#39; default tablespace &#39;$&#123;v_create_space&#125;&#39; temporary tablespace &#39;$&#123;v_create_tmp_space&#125;&#39;;    grant connect,resource to &#39;$&#123;v_create_usr&#125;&#39;;    grant exp_full_database to &#39;$&#123;v_create_usr&#125;&#39;;    grant imp_full_database to &#39;$&#123;v_create_usr&#125;&#39;;    grant unlimited tablespace to &#39;$&#123;v_create_usr&#125;&#39;;    exit;EOF&#125;#用户数据导入imp_usrdata()&#123;    v_imp_usr&#x3D;$1    v_imp_pwd&#x3D;$2    v_oradir_name&#x3D;$3    impdp $&#123;v_imp_usr&#125;&#x2F;$&#123;v_imp_pwd&#125; DIRECTORY&#x3D;$&#123;v_oradir_name&#125; DUMPFILE&#x3D;$&#123;v_imp_usr&#125;&quot;_&quot;$&#123;v_date&#125;&quot;.dmp&quot; SCHEMAS&#x3D;$&#123;v_imp_usr&#125; LOGFILE&#x3D;$&#123;v_imp_usr&#125;&quot;_&quot;$&#123;v_date&#125;&quot;.log&quot; table_exists_action&#x3D;replace RANSFORM&#x3D;segment_attributes:n&#125;#删除用户drop_user()&#123;    v_drop_usr&#x3D;$1    #删除用户及用户下的所有数据，删除表空间及表空间下的所有数据    sqlplus -S &#x2F; as sysdba &gt;&gt; $&#123;v_logfile&#125; &lt;&lt;EOF    set heading off feedback off verify off    drop user &#39;$&#123;v_drop_usr&#125;&#39; cascade;    exitEOF&#125;#删除表空间并删除表空间下的数据文件drop_tablespace()&#123;    v_drop_space&#x3D;$1    #删除用户及用户下的所有数据，删除表空间及表空间下的所有数据    sqlplus -S &#x2F; as sysdba &gt;&gt; $&#123;v_logfile&#125; &lt;&lt;EOF    set heading off feedback off verify off    drop tablespace &#39;$&#123;v_drop_space&#125;&#39; including contents and datafiles;    exitEOF    ##操作系统上表空间下的数据文件    [[ -f $&#123;v_backup_dir&#125;&#x2F;$&#123;v_drop_space&#125;.dbf ]] &amp;&amp; rm -rf $&#123;v_backup_dir&#125;&#x2F;$&#123;v_drop_space&#125;.dbf&#125;#创建dblinkcreate_dblink()&#123;    v_clink_usr&#x3D;$1    v_clink_pwd&#x3D;$2    #以管理员身份对创建dblink赋权    sqlplus -S &#x2F; as sysdba &gt;&gt; $&#123;v_logfile&#125; &lt;&lt;EOF    set heading off feedback off verify off    grant create database link to &#39;$&#123;v_clink_usr&#125;&#39;;    exit;EOF    #以普通用户登录创建dblink    sqlplus -S $&#123;v_clink_usr&#125;&#x2F;$&#123;v_clink_pwd&#125;@$&#123;v_db_instance&#125; &gt;&gt; $&#123;v_logfile&#125; &lt;&lt;EOF    set heading off feedback off verify off    CREATE DATABASE LINK $&#123;v_dblink&#125; CONNECT TO &#39;$&#123;v_clink_usr&#125;&#39; IDENTIFIED BY &#39;$&#123;v_clink_pwd&#125;&#39; USING &#39;&#123;v_db_instance&#125;&#39;;    exitEOF&#125;#判断dblink是否存在deal_dblink()&#123;    v_link&#x3D;$1    v_link_usr&#x3D;$2    v_link_pwd&#x3D;$3    sqlplus -S &#x2F; as sysdba &lt;&lt;EOF     set heading off feedback off verify off    spool tmp_space_flag.tmp    select object_name from dba_objects where object_name &#x3D; &#39;$&#123;v_link&#125;&#39;;     spool off    exit;EOF    ##如果当前dblink不存在，则创建，否则退出当前函数    if [[ &#96;grep $&#123;v_space_name&#125; tmp_space_flag.tmp | wc -l&#96; -eq 0 ]]; then        record_log &quot;创建&quot;$1&quot;开始&quot;        create_dblink $&#123;v_link_usr&#125; $&#123;v_link_pwd&#125;        record_log &quot;创建&quot;$1&quot;结束&quot;    else        record_log $1&quot;已存在&quot;        return    fi    ##注意清理临时标志文件    [[ -f .&#x2F;tmp_space_flag.tmp ]] &amp;&amp; rm -rf tmp_space_flag.tmp&#125;#主函数main()&#123;    v_start&#x3D;&#96;date +%s&#96;    if [[ $1 -eq &quot;exp&quot; ]]; then         record_log &quot;bl库导出开始...&quot;        exp_usrdata $&#123;v_usr_1&#125; $&#123;v_pwd_1&#125; $&#123;v_oradir_name&#125;        record_log &quot;bl库导出结束...&quot;        record_log &quot;hx库导出开始...&quot;        exp_usrdata $&#123;v_usr_2&#125; $&#123;v_pwd_2&#125; $&#123;v_oradir_name&#125;        record_log &quot;hx库导出结束...&quot;    elif [[ $1 -eq &quot;pre&quot; ]]; then        #1、创建备份目录        create_bankup_dir        #2、创建表空间        for v_sp in $&#123;v_tmp_space1&#125; $&#123;v_tmp_space2&#125; $&#123;v_space1&#125; $&#123;v_space2&#125; $&#123;v_idx_space1&#125; $&#123;v_idx_space2&#125;; do            deal_spaces $&#123;v_sp&#125;        done        #3、创建用户、赋权        record_log &quot;创建用户开始...&quot;        create_usrs $&#123;v_usr_1&#125; $&#123;v_pwd_1&#125; $&#123;v_tmp_space1&#125; $&#123;v_space1&#125;        create_usrs $&#123;v_usr_2&#125; $&#123;v_pwd_2&#125; $&#123;v_tmp_space2&#125; $&#123;v_space2&#125;        record_log &quot;创建用户结束...&quot;        #4、为hx库创建dblink        record_log &quot;创建dblink开始...&quot;        deal_dblink $&#123;v_dblink&#125; $&#123;v_usr_2&#125; $&#123;v_pwd_2&#125;        record_log &quot;创建dblink结束...&quot;    elif [[ $1 -eq &quot;imp&quot; ]]; then        record_log &quot;bl库导入开始...&quot;        imp_usrdata $&#123;v_usr_1&#125; $&#123;v_pwd_1&#125; $&#123;v_oradir_name&#125;        record_log &quot;bl库导入结束...&quot;        record_log &quot;hx库导入开始...&quot;        imp_usrdata $&#123;v_usr_2&#125; $&#123;v_pwd_2&#125; $&#123;v_oradir_name&#125;        record_log &quot;hx库导入结束...&quot;    elif [[ $1 -eq &quot;clean&quot; ]]; then        read -t 5 -p &quot;确认清除 0-否 1-是&quot; v_num        if [[ $&#123;v_num&#125; -eq 1 ]]; then            record_log &quot;清理数据文件开始...&quot;            for m in $&#123;&#125; $&#123;&#125;; do                drop_user $&#123;m&#125;            done            for n in $&#123;v_tmp_space1&#125; $&#123;v_tmp_space2&#125; $&#123;v_space1&#125; $&#123;v_space2&#125; $&#123;v_idx_space1&#125; $&#123;v_idx_space2&#125;; do                drop_tablespace $&#123;n&#125;            done            record_log &quot;清理数据文件结束...&quot;        else            exit        fi    else        echo &quot;Usage: sh script [exp|clean|pre|imp]&quot;        exit    fi    v_end&#x3D;&#96;date +%s&#96;    v_use_time&#x3D;$[ v_end - v_start ]    record_log &quot;本次脚本运行时间：&quot;$&#123;v_use_time&#125;&quot;秒&quot;&#125;main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> 数据迁移 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
